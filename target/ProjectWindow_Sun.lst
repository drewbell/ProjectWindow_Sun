
/Users/drewbell/sw_projects/ProjectWindow_Sun/target/ProjectWindow_Sun.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005d38  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a5d50  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         0000009c  20000300  080a5d54  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000684  2000039c  2000039c  0004039c  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a5df0  080a5df0  00035df0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a5e18  080a5e18  00035e18  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   000d8073  00000000  00000000  00035e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00013278  00000000  00000000  0010de8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000194c6  00000000  00000000  00121107  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000026e8  00000000  00000000  0013a5cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00003f70  00000000  00000000  0013ccb5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00029c25  00000000  00000000  00140c25  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0002b11a  00000000  00000000  0016a84a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a1f21  00000000  00000000  00195964  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000cd2c  00000000  00000000  00237888  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	ac 51 0a 08                                         .Q..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f004 ff71 	bl	80a4f14 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f004 ff91 	bl	80a4f60 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a5d54 	.word	0x080a5d54
 80a004c:	2000039c 	.word	0x2000039c
 80a0050:	2000039c 	.word	0x2000039c
 80a0054:	20000a20 	.word	0x20000a20
 80a0058:	20000a20 	.word	0x20000a20

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f004 fcb9 	bl	80a49d4 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a5d10 	.word	0x080a5d10
 80a0084:	080a5d50 	.word	0x080a5d50

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 be5c 	b.w	80a0d44 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 ffb9 	bl	80a1004 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f004 bc5f 	b.w	80a4958 <_post_loop>

080a009a <_Znwj>:
 80a009a:	f002 bc1b 	b.w	80a28d4 <malloc>

080a009e <_ZdlPv>:
 80a009e:	f002 bc21 	b.w	80a28e4 <free>
	...

080a00a4 <__cxa_pure_virtual>:
        ;
    }
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
 80a00a4:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a6:	4a03      	ldr	r2, [pc, #12]	; (80a00b4 <__cxa_pure_virtual+0x10>)
 80a00a8:	2100      	movs	r1, #0
 80a00aa:	200c      	movs	r0, #12
 80a00ac:	f002 fb96 	bl	80a27dc <panic_>
 80a00b0:	e7fe      	b.n	80a00b0 <__cxa_pure_virtual+0xc>
 80a00b2:	bf00      	nop
 80a00b4:	080a24c9 	.word	0x080a24c9

080a00b8 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b8:	7800      	ldrb	r0, [r0, #0]
 80a00ba:	fab0 f080 	clz	r0, r0
 80a00be:	0940      	lsrs	r0, r0, #5
 80a00c0:	4770      	bx	lr

080a00c2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00c2:	2301      	movs	r3, #1
 80a00c4:	7003      	strb	r3, [r0, #0]
 80a00c6:	4770      	bx	lr

080a00c8 <_ZN5spark10LogHandler5writeEPKcj>:
    if (level >= filter_.level(category)) {
        write(data, size);
    }
}

inline void spark::LogHandler::write(const char *data, size_t size) {
 80a00c8:	4770      	bx	lr

080a00ca <_ZN5spark16StreamLogHandler5writeEPKcj>:
inline Print* spark::StreamLogHandler::stream() const {
    return stream_;
}

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
 80a00ca:	6a00      	ldr	r0, [r0, #32]
 80a00cc:	6803      	ldr	r3, [r0, #0]
 80a00ce:	68db      	ldr	r3, [r3, #12]
 80a00d0:	4718      	bx	r3
	...

080a00d4 <_ZL14BLYNK_LOG_TIMEv>:
                                            BLYNK_PRINT.print(ip[2]); BLYNK_PRINT.print('.');  \
                                            BLYNK_PRINT.print(ip[1]); BLYNK_PRINT.print('.');  \
                                            BLYNK_PRINT.println(ip[0]); }

        static
        void BLYNK_LOG_TIME() {
 80a00d4:	b510      	push	{r4, lr}
            BLYNK_PRINT.print('[');
 80a00d6:	f004 fb95 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a00da:	215b      	movs	r1, #91	; 0x5b
 80a00dc:	f003 fe9a 	bl	80a3e14 <_ZN5Print5printEc>
            BLYNK_PRINT.print(BlynkMillis());
 80a00e0:	f004 fb90 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a00e4:	4604      	mov	r4, r0
 80a00e6:	f001 f849 	bl	80a117c <_Z11BlynkMillisv>
 80a00ea:	220a      	movs	r2, #10
 80a00ec:	4601      	mov	r1, r0
 80a00ee:	4620      	mov	r0, r4
 80a00f0:	f003 fec8 	bl	80a3e84 <_ZN5Print5printEmi>
            BLYNK_PRINT.print(BLYNK_F("] "));
 80a00f4:	f004 fb86 	bl	80a4804 <_Z16_fetch_usbserialv>
        }
 80a00f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

        static
        void BLYNK_LOG_TIME() {
            BLYNK_PRINT.print('[');
            BLYNK_PRINT.print(BlynkMillis());
            BLYNK_PRINT.print(BLYNK_F("] "));
 80a00fc:	4901      	ldr	r1, [pc, #4]	; (80a0104 <_ZL14BLYNK_LOG_TIMEv+0x30>)
 80a00fe:	f003 be85 	b.w	80a3e0c <_ZN5Print5printEPKc>
 80a0102:	bf00      	nop
 80a0104:	080a524a 	.word	0x080a524a

080a0108 <_ZN5spark16SerialLogHandlerD1Ev>:
            StreamLogHandler(Serial, level, filters) {
        Serial.begin(baud);
        LogManager::instance()->addHandler(this);
    }

    virtual ~SerialLogHandler() {
 80a0108:	b510      	push	{r4, lr}
 80a010a:	4604      	mov	r4, r0
 80a010c:	4b09      	ldr	r3, [pc, #36]	; (80a0134 <_ZN5spark16SerialLogHandlerD1Ev+0x2c>)
 80a010e:	6003      	str	r3, [r0, #0]
        LogManager::instance()->removeHandler(this);
 80a0110:	f003 f962 	bl	80a33d8 <_ZN5spark10LogManager8instanceEv>
 80a0114:	4621      	mov	r1, r4
 80a0116:	f003 fb5e 	bl	80a37d6 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>
        Serial.end();
 80a011a:	f004 fb73 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a011e:	f004 fb57 	bl	80a47d0 <_ZN9USBSerial3endEv>
    */
    LogHandler(LogLevel level, LogCategoryFilters filters);
    /*!
        \brief Destructor.
    */
    virtual ~LogHandler() = default;
 80a0122:	4620      	mov	r0, r4
 80a0124:	4b04      	ldr	r3, [pc, #16]	; (80a0138 <_ZN5spark16SerialLogHandlerD1Ev+0x30>)
 80a0126:	f840 3b04 	str.w	r3, [r0], #4
 80a012a:	f003 fa5b 	bl	80a35e4 <_ZN5spark6detail9LogFilterD1Ev>
    }
 80a012e:	4620      	mov	r0, r4
 80a0130:	bd10      	pop	{r4, pc}
 80a0132:	bf00      	nop
 80a0134:	080a51e0 	.word	0x080a51e0
 80a0138:	080a51c8 	.word	0x080a51c8

080a013c <_ZN5spark16SerialLogHandlerD0Ev>:
            StreamLogHandler(Serial, level, filters) {
        Serial.begin(baud);
        LogManager::instance()->addHandler(this);
    }

    virtual ~SerialLogHandler() {
 80a013c:	b510      	push	{r4, lr}
 80a013e:	4604      	mov	r4, r0
        LogManager::instance()->removeHandler(this);
        Serial.end();
    }
 80a0140:	f7ff ffe2 	bl	80a0108 <_ZN5spark16SerialLogHandlerD1Ev>
 80a0144:	4620      	mov	r0, r4
 80a0146:	f7ff ffaa 	bl	80a009e <_ZdlPv>
 80a014a:	4620      	mov	r0, r4
 80a014c:	bd10      	pop	{r4, pc}
	...

080a0150 <_ZN10CloudClass7processEv>:
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
 80a0150:	b508      	push	{r3, lr}
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a0152:	f002 f9c9 	bl	80a24e8 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a0156:	4b03      	ldr	r3, [pc, #12]	; (80a0164 <_ZN10CloudClass7processEv+0x14>)
 80a0158:	6018      	str	r0, [r3, #0]
    		application_checkin();
    		spark_process();
    }
 80a015a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
    		application_checkin();
    		spark_process();
 80a015e:	f002 bb89 	b.w	80a2874 <spark_process>
 80a0162:	bf00      	nop
 80a0164:	20000928 	.word	0x20000928

080a0168 <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
 80a0168:	b538      	push	{r3, r4, r5, lr}
 80a016a:	4b0b      	ldr	r3, [pc, #44]	; (80a0198 <_ZN9TCPClientD1Ev+0x30>)
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a016c:	6984      	ldr	r4, [r0, #24]
 80a016e:	4605      	mov	r5, r0
 80a0170:	6003      	str	r3, [r0, #0]
 80a0172:	b17c      	cbz	r4, 80a0194 <_ZN9TCPClientD1Ev+0x2c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a0174:	6863      	ldr	r3, [r4, #4]
 80a0176:	3b01      	subs	r3, #1
 80a0178:	6063      	str	r3, [r4, #4]
 80a017a:	b95b      	cbnz	r3, 80a0194 <_ZN9TCPClientD1Ev+0x2c>
        {
          _M_dispose();
 80a017c:	6823      	ldr	r3, [r4, #0]
 80a017e:	4620      	mov	r0, r4
 80a0180:	689b      	ldr	r3, [r3, #8]
 80a0182:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a0184:	68a3      	ldr	r3, [r4, #8]
 80a0186:	3b01      	subs	r3, #1
 80a0188:	60a3      	str	r3, [r4, #8]
 80a018a:	b91b      	cbnz	r3, 80a0194 <_ZN9TCPClientD1Ev+0x2c>
            _M_destroy();
 80a018c:	6823      	ldr	r3, [r4, #0]
 80a018e:	4620      	mov	r0, r4
 80a0190:	68db      	ldr	r3, [r3, #12]
 80a0192:	4798      	blx	r3
 80a0194:	4628      	mov	r0, r5
 80a0196:	bd38      	pop	{r3, r4, r5, pc}
 80a0198:	080a5ab0 	.word	0x080a5ab0

080a019c <_ZN22BlynkTransportParticleD1Ev>:
#define BlynkParticle_h

#include "BlynkApiParticle.h"
#include "Blynk/BlynkProtocol.h"

class BlynkTransportParticle
 80a019c:	b510      	push	{r4, lr}
 80a019e:	4604      	mov	r4, r0
 80a01a0:	f7ff ffe2 	bl	80a0168 <_ZN9TCPClientD1Ev>
 80a01a4:	4620      	mov	r0, r4
 80a01a6:	bd10      	pop	{r4, pc}

080a01a8 <_ZN9TCPClientD0Ev>:
 80a01a8:	b510      	push	{r4, lr}
 80a01aa:	4604      	mov	r4, r0
 80a01ac:	f7ff ffdc 	bl	80a0168 <_ZN9TCPClientD1Ev>
 80a01b0:	4620      	mov	r0, r4
 80a01b2:	f7ff ff74 	bl	80a009e <_ZdlPv>
 80a01b6:	4620      	mov	r0, r4
 80a01b8:	bd10      	pop	{r4, pc}

080a01ba <_ZNK5spark6Logger4infoEPKcz>:
    va_start(args, fmt);
    log(LOG_LEVEL_TRACE, fmt, args);
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
 80a01ba:	b40e      	push	{r1, r2, r3}
 80a01bc:	b500      	push	{lr}
 80a01be:	b08c      	sub	sp, #48	; 0x30
 80a01c0:	aa0d      	add	r2, sp, #52	; 0x34
 80a01c2:	f852 1b04 	ldr.w	r1, [r2], #4
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a01c6:	2320      	movs	r3, #32
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01c8:	e88d 0006 	stmia.w	sp, {r1, r2}
    va_end(args);
}

inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
 80a01cc:	9203      	str	r2, [sp, #12]
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a01ce:	9304      	str	r3, [sp, #16]
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01d0:	6801      	ldr	r1, [r0, #0]
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a01d2:	2300      	movs	r3, #0
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01d4:	aa04      	add	r2, sp, #16
 80a01d6:	201e      	movs	r0, #30
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a01d8:	9305      	str	r3, [sp, #20]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01da:	f002 fb0f 	bl	80a27fc <log_message_v>
inline void spark::Logger::info(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_INFO, fmt, args);
    va_end(args);
}
 80a01de:	b00c      	add	sp, #48	; 0x30
 80a01e0:	f85d eb04 	ldr.w	lr, [sp], #4
 80a01e4:	b003      	add	sp, #12
 80a01e6:	4770      	bx	lr

080a01e8 <_ZNK5spark6Logger4warnEPKcz>:

inline void spark::Logger::warn(const char *fmt, ...) const {
 80a01e8:	b40e      	push	{r1, r2, r3}
 80a01ea:	b500      	push	{lr}
 80a01ec:	b08c      	sub	sp, #48	; 0x30
 80a01ee:	aa0d      	add	r2, sp, #52	; 0x34
 80a01f0:	f852 1b04 	ldr.w	r1, [r2], #4
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a01f4:	2320      	movs	r3, #32
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01f6:	e88d 0006 	stmia.w	sp, {r1, r2}
    va_end(args);
}

inline void spark::Logger::warn(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
 80a01fa:	9203      	str	r2, [sp, #12]
    va_end(args);
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
 80a01fc:	9304      	str	r3, [sp, #16]
    attr.flags = 0;
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a01fe:	6801      	ldr	r1, [r0, #0]
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a0200:	2300      	movs	r3, #0
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0202:	aa04      	add	r2, sp, #16
 80a0204:	2028      	movs	r0, #40	; 0x28
}

inline void spark::Logger::log(LogLevel level, const char *fmt, va_list args) const {
    LogAttributes attr;
    attr.size = sizeof(LogAttributes);
    attr.flags = 0;
 80a0206:	9305      	str	r3, [sp, #20]
    log_message_v(level, name_, &attr, nullptr, fmt, args);
 80a0208:	f002 faf8 	bl	80a27fc <log_message_v>
inline void spark::Logger::warn(const char *fmt, ...) const {
    va_list args;
    va_start(args, fmt);
    log(LOG_LEVEL_WARN, fmt, args);
    va_end(args);
}
 80a020c:	b00c      	add	sp, #48	; 0x30
 80a020e:	f85d eb04 	ldr.w	lr, [sp], #4
 80a0212:	b003      	add	sp, #12
 80a0214:	4770      	bx	lr

080a0216 <_ZNK10BlynkParam8iterator5asIntEv>:
        //long long   asLongLong() const  { return atoll(ptr); }
#ifndef BLYNK_NO_FLOAT
        double      asDouble() const    { if(!isValid()) return 0; return atof(ptr); }
        float       asFloat() const     { if(!isValid()) return 0; return atof(ptr); }
#endif
        bool isValid() const            { return ptr != NULL && ptr < limit; }
 80a0216:	6803      	ldr	r3, [r0, #0]
 80a0218:	b12b      	cbz	r3, 80a0226 <_ZNK10BlynkParam8iterator5asIntEv+0x10>
 80a021a:	6842      	ldr	r2, [r0, #4]
 80a021c:	4293      	cmp	r3, r2
 80a021e:	d202      	bcs.n	80a0226 <_ZNK10BlynkParam8iterator5asIntEv+0x10>

        operator const char* () const   { return asStr(); }
        operator int () const           { return asInt(); }
        const char* asStr() const       { return ptr; }
        const char* asString() const    { return ptr; }
        int         asInt() const       { if(!isValid()) return 0; return atoi(ptr); }
 80a0220:	4618      	mov	r0, r3
 80a0222:	f004 be61 	b.w	80a4ee8 <atoi>
 80a0226:	2000      	movs	r0, #0
 80a0228:	4770      	bx	lr

080a022a <_ZN10BlynkParam8iteratorppEv>:
        bool isEmpty() const            { if(!isValid()) return true; return *ptr == '\0'; }

        bool operator <  (const iterator& it) const { return ptr < it.ptr; }
        bool operator >= (const iterator& it) const { return ptr >= it.ptr; }

        iterator& operator ++() {
 80a022a:	b538      	push	{r3, r4, r5, lr}
        //long long   asLongLong() const  { return atoll(ptr); }
#ifndef BLYNK_NO_FLOAT
        double      asDouble() const    { if(!isValid()) return 0; return atof(ptr); }
        float       asFloat() const     { if(!isValid()) return 0; return atof(ptr); }
#endif
        bool isValid() const            { return ptr != NULL && ptr < limit; }
 80a022c:	6805      	ldr	r5, [r0, #0]
        bool isEmpty() const            { if(!isValid()) return true; return *ptr == '\0'; }

        bool operator <  (const iterator& it) const { return ptr < it.ptr; }
        bool operator >= (const iterator& it) const { return ptr >= it.ptr; }

        iterator& operator ++() {
 80a022e:	4604      	mov	r4, r0
        //long long   asLongLong() const  { return atoll(ptr); }
#ifndef BLYNK_NO_FLOAT
        double      asDouble() const    { if(!isValid()) return 0; return atof(ptr); }
        float       asFloat() const     { if(!isValid()) return 0; return atof(ptr); }
#endif
        bool isValid() const            { return ptr != NULL && ptr < limit; }
 80a0230:	b145      	cbz	r5, 80a0244 <_ZN10BlynkParam8iteratorppEv+0x1a>
 80a0232:	6843      	ldr	r3, [r0, #4]
 80a0234:	429d      	cmp	r5, r3
 80a0236:	d205      	bcs.n	80a0244 <_ZN10BlynkParam8iteratorppEv+0x1a>
        bool operator <  (const iterator& it) const { return ptr < it.ptr; }
        bool operator >= (const iterator& it) const { return ptr >= it.ptr; }

        iterator& operator ++() {
            if(isValid()) {
                ptr += strlen(ptr) + 1;
 80a0238:	4628      	mov	r0, r5
 80a023a:	f004 fee3 	bl	80a5004 <strlen>
 80a023e:	3001      	adds	r0, #1
 80a0240:	4405      	add	r5, r0
 80a0242:	6025      	str	r5, [r4, #0]
            }
            return *this;
        }
 80a0244:	4620      	mov	r0, r4
 80a0246:	bd38      	pop	{r3, r4, r5, pc}

080a0248 <_ZN10BlynkParam3addEPKc>:
    len += l;
}

inline
void BlynkParam::add(const char* str)
{
 80a0248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a024a:	4604      	mov	r4, r0
    if (str == NULL) {
 80a024c:	460f      	mov	r7, r1
 80a024e:	6846      	ldr	r6, [r0, #4]
 80a0250:	b921      	cbnz	r1, 80a025c <_ZN10BlynkParam3addEPKc+0x14>
        buff[len++] = '\0';
 80a0252:	6803      	ldr	r3, [r0, #0]
 80a0254:	1c72      	adds	r2, r6, #1
 80a0256:	6042      	str	r2, [r0, #4]
 80a0258:	5599      	strb	r1, [r3, r6]
        return;
 80a025a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    add(str, strlen(str)+1);
 80a025c:	4608      	mov	r0, r1
 80a025e:	f004 fed1 	bl	80a5004 <strlen>
}

inline
void BlynkParam::add(const void* b, size_t l)
{
    if (len + l > buff_size)
 80a0262:	68a3      	ldr	r3, [r4, #8]
{
    if (str == NULL) {
        buff[len++] = '\0';
        return;
    }
    add(str, strlen(str)+1);
 80a0264:	1c45      	adds	r5, r0, #1
}

inline
void BlynkParam::add(const void* b, size_t l)
{
    if (len + l > buff_size)
 80a0266:	19aa      	adds	r2, r5, r6
 80a0268:	429a      	cmp	r2, r3
 80a026a:	d808      	bhi.n	80a027e <_ZN10BlynkParam3addEPKc+0x36>
        return;
    memcpy(buff+len, b, l);
 80a026c:	6820      	ldr	r0, [r4, #0]
 80a026e:	462a      	mov	r2, r5
 80a0270:	4639      	mov	r1, r7
 80a0272:	4430      	add	r0, r6
 80a0274:	f004 fe4e 	bl	80a4f14 <memcpy>
    len += l;
 80a0278:	6863      	ldr	r3, [r4, #4]
 80a027a:	441d      	add	r5, r3
 80a027c:	6065      	str	r5, [r4, #4]
 80a027e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0280 <_ZN10BlynkParam3addEi>:

    #include <stdio.h>

    inline
    void BlynkParam::add(int value)
    {
 80a0280:	b570      	push	{r4, r5, r6, lr}
 80a0282:	4604      	mov	r4, r0
        len += snprintf(buff+len, buff_size-len, "%i", value)+1;
 80a0284:	6840      	ldr	r0, [r0, #4]
 80a0286:	68a6      	ldr	r6, [r4, #8]
 80a0288:	6825      	ldr	r5, [r4, #0]
 80a028a:	460b      	mov	r3, r1
 80a028c:	4a04      	ldr	r2, [pc, #16]	; (80a02a0 <_ZN10BlynkParam3addEi+0x20>)
 80a028e:	1a31      	subs	r1, r6, r0
 80a0290:	4428      	add	r0, r5
 80a0292:	f002 fb37 	bl	80a2904 <snprintf>
 80a0296:	6863      	ldr	r3, [r4, #4]
 80a0298:	3001      	adds	r0, #1
 80a029a:	4418      	add	r0, r3
 80a029c:	6060      	str	r0, [r4, #4]
 80a029e:	bd70      	pop	{r4, r5, r6, pc}
 80a02a0:	080a524d 	.word	0x080a524d

080a02a4 <_ZN10BlynkParam3addEl>:
        len += snprintf(buff+len, buff_size-len, "%u", value)+1;
    }

    inline
    void BlynkParam::add(long value)
    {
 80a02a4:	b570      	push	{r4, r5, r6, lr}
 80a02a6:	4604      	mov	r4, r0
        len += snprintf(buff+len, buff_size-len, "%li", value)+1;
 80a02a8:	6840      	ldr	r0, [r0, #4]
 80a02aa:	68a6      	ldr	r6, [r4, #8]
 80a02ac:	6825      	ldr	r5, [r4, #0]
 80a02ae:	460b      	mov	r3, r1
 80a02b0:	4a04      	ldr	r2, [pc, #16]	; (80a02c4 <_ZN10BlynkParam3addEl+0x20>)
 80a02b2:	1a31      	subs	r1, r6, r0
 80a02b4:	4428      	add	r0, r5
 80a02b6:	f002 fb25 	bl	80a2904 <snprintf>
 80a02ba:	6863      	ldr	r3, [r4, #4]
 80a02bc:	3001      	adds	r0, #1
 80a02be:	4418      	add	r0, r3
 80a02c0:	6060      	str	r0, [r4, #4]
 80a02c2:	bd70      	pop	{r4, r5, r6, pc}
 80a02c4:	080a5250 	.word	0x080a5250

080a02c8 <_ZN22BlynkTransportParticle7connectEv>:
    void begin(const char* d, uint16_t p) {
        domain = d;
        port = p;
    }

    bool connect() {
 80a02c8:	b5f0      	push	{r4, r5, r6, r7, lr}
        if (domain) {
 80a02ca:	6b47      	ldr	r7, [r0, #52]	; 0x34
    void begin(const char* d, uint16_t p) {
        domain = d;
        port = p;
    }

    bool connect() {
 80a02cc:	b087      	sub	sp, #28
 80a02ce:	4604      	mov	r4, r0
        if (domain) {
 80a02d0:	b307      	cbz	r7, 80a0314 <_ZN22BlynkTransportParticle7connectEv+0x4c>
            BLYNK_LOG4(BLYNK_F("Connecting to "), domain, ':', port);
 80a02d2:	f7ff feff 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a02d6:	f004 fa95 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a02da:	4931      	ldr	r1, [pc, #196]	; (80a03a0 <_ZN22BlynkTransportParticle7connectEv+0xd8>)
 80a02dc:	f003 fd96 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a02e0:	f004 fa90 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a02e4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80a02e6:	f003 fd91 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a02ea:	f004 fa8b 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a02ee:	213a      	movs	r1, #58	; 0x3a
 80a02f0:	f003 fd90 	bl	80a3e14 <_ZN5Print5printEc>
 80a02f4:	f004 fa86 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a02f8:	220a      	movs	r2, #10
 80a02fa:	8f21      	ldrh	r1, [r4, #56]	; 0x38
 80a02fc:	f003 fdfb 	bl	80a3ef6 <_ZN5Print7printlnEii>
            return (1 == client.connect(domain, port));
 80a0300:	8f22      	ldrh	r2, [r4, #56]	; 0x38
 80a0302:	2300      	movs	r3, #0
 80a0304:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80a0306:	4620      	mov	r0, r4
 80a0308:	f003 ff6a 	bl	80a41e0 <_ZN9TCPClient7connectEPKctm>
 80a030c:	1e42      	subs	r2, r0, #1
 80a030e:	4250      	negs	r0, r2
 80a0310:	4150      	adcs	r0, r2
 80a0312:	e042      	b.n	80a039a <_ZN22BlynkTransportParticle7connectEv+0xd2>
        } else {
            BLYNK_LOG_IP("Connecting to ", addr);
 80a0314:	4625      	mov	r5, r4
 80a0316:	f7ff fedd 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a031a:	f004 fa73 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a031e:	4920      	ldr	r1, [pc, #128]	; (80a03a0 <_ZN22BlynkTransportParticle7connectEv+0xd8>)
 80a0320:	f003 fd74 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a0324:	f004 fa6e 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0328:	220a      	movs	r2, #10
 80a032a:	f894 1023 	ldrb.w	r1, [r4, #35]	; 0x23
 80a032e:	f003 fdb4 	bl	80a3e9a <_ZN5Print5printEhi>
 80a0332:	f004 fa67 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0336:	212e      	movs	r1, #46	; 0x2e
 80a0338:	f003 fd6c 	bl	80a3e14 <_ZN5Print5printEc>
 80a033c:	f004 fa62 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0340:	220a      	movs	r2, #10
 80a0342:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 80a0346:	f003 fda8 	bl	80a3e9a <_ZN5Print5printEhi>
 80a034a:	f004 fa5b 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a034e:	212e      	movs	r1, #46	; 0x2e
 80a0350:	f003 fd60 	bl	80a3e14 <_ZN5Print5printEc>
 80a0354:	f004 fa56 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0358:	220a      	movs	r2, #10
 80a035a:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
 80a035e:	f003 fd9c 	bl	80a3e9a <_ZN5Print5printEhi>
 80a0362:	f004 fa4f 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0366:	212e      	movs	r1, #46	; 0x2e
 80a0368:	f003 fd54 	bl	80a3e14 <_ZN5Print5printEc>
 80a036c:	f004 fa4a 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0370:	220a      	movs	r2, #10
 80a0372:	f815 1f20 	ldrb.w	r1, [r5, #32]!
 80a0376:	f003 fd92 	bl	80a3e9e <_ZN5Print7printlnEhi>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a037a:	4b0a      	ldr	r3, [pc, #40]	; (80a03a4 <_ZN22BlynkTransportParticle7connectEv+0xdc>)
 80a037c:	ae01      	add	r6, sp, #4
 80a037e:	9300      	str	r3, [sp, #0]
 80a0380:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a0382:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80a0384:	682b      	ldr	r3, [r5, #0]
            return (1 == client.connect(addr, port));
 80a0386:	8f22      	ldrh	r2, [r4, #56]	; 0x38
 80a0388:	7033      	strb	r3, [r6, #0]
 80a038a:	4669      	mov	r1, sp
 80a038c:	463b      	mov	r3, r7
 80a038e:	4620      	mov	r0, r4
 80a0390:	f004 f886 	bl	80a44a0 <_ZN9TCPClient7connectE9IPAddresstm>
 80a0394:	1e43      	subs	r3, r0, #1
 80a0396:	4258      	negs	r0, r3
 80a0398:	4158      	adcs	r0, r3
        }
        return 0;
    }
 80a039a:	b007      	add	sp, #28
 80a039c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a039e:	bf00      	nop
 80a03a0:	080a5254 	.word	0x080a5254
 80a03a4:	080a58fc 	.word	0x080a58fc

080a03a8 <BlynkWidgetWrite0>:

// Blynk Functions
// mode: this function will be called every time Slider Widget
// in Blynk app writes values to the Virtual Pin V1
BLYNK_WRITE(V0)
{
 80a03a8:	b508      	push	{r3, lr}
        : buff((char*)addr), len(length), buff_size(buffsize)
    {}

    const char* asStr() const       { return buff; }
    const char* asString() const    { return buff; }
    int         asInt() const       { return atoi(buff); }
 80a03aa:	6808      	ldr	r0, [r1, #0]
 80a03ac:	f004 fd9c 	bl	80a4ee8 <atoi>
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    mode = pinValue;  
 80a03b0:	4b05      	ldr	r3, [pc, #20]	; (80a03c8 <BlynkWidgetWrite0+0x20>)
    Log.info("New mode is %d.", mode);
 80a03b2:	4906      	ldr	r1, [pc, #24]	; (80a03cc <BlynkWidgetWrite0+0x24>)
// mode: this function will be called every time Slider Widget
// in Blynk app writes values to the Virtual Pin V1
BLYNK_WRITE(V0)
{
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    mode = pinValue;  
 80a03b4:	6018      	str	r0, [r3, #0]
    Log.info("New mode is %d.", mode);
 80a03b6:	681a      	ldr	r2, [r3, #0]
 80a03b8:	4805      	ldr	r0, [pc, #20]	; (80a03d0 <BlynkWidgetWrite0+0x28>)
 80a03ba:	f7ff fefe 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a03be:	4b05      	ldr	r3, [pc, #20]	; (80a03d4 <BlynkWidgetWrite0+0x2c>)
 80a03c0:	2201      	movs	r2, #1
 80a03c2:	701a      	strb	r2, [r3, #0]
 80a03c4:	bd08      	pop	{r3, pc}
 80a03c6:	bf00      	nop
 80a03c8:	20000300 	.word	0x20000300
 80a03cc:	080a5263 	.word	0x080a5263
 80a03d0:	200004a0 	.word	0x200004a0
 80a03d4:	20000304 	.word	0x20000304

080a03d8 <BlynkWidgetWrite1>:
}

// alarmTime - save as string? Need to handle  HH:MM:SS AM/PM
BLYNK_WRITE(V1)
{
 80a03d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    String pinValue = param.asString(); // assigning incoming value from pin V1 to a variable
    alarmTime = pinValue;
 80a03da:	4c0b      	ldr	r4, [pc, #44]	; (80a0408 <BlynkWidgetWrite1+0x30>)
}

// alarmTime - save as string? Need to handle  HH:MM:SS AM/PM
BLYNK_WRITE(V1)
{
    String pinValue = param.asString(); // assigning incoming value from pin V1 to a variable
 80a03dc:	6809      	ldr	r1, [r1, #0]
 80a03de:	4668      	mov	r0, sp
 80a03e0:	f003 fe82 	bl	80a40e8 <_ZN6StringC1EPK19__FlashStringHelper>
    alarmTime = pinValue;
 80a03e4:	4669      	mov	r1, sp
 80a03e6:	4620      	mov	r0, r4
 80a03e8:	f003 fe91 	bl	80a410e <_ZN6StringaSERKS_>
    Log.info("New time is %s.", alarmTime.c_str() );
 80a03ec:	6822      	ldr	r2, [r4, #0]
 80a03ee:	4907      	ldr	r1, [pc, #28]	; (80a040c <BlynkWidgetWrite1+0x34>)
 80a03f0:	4807      	ldr	r0, [pc, #28]	; (80a0410 <BlynkWidgetWrite1+0x38>)
 80a03f2:	f7ff fee2 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a03f6:	4b07      	ldr	r3, [pc, #28]	; (80a0414 <BlynkWidgetWrite1+0x3c>)
 80a03f8:	2201      	movs	r2, #1
}

// alarmTime - save as string? Need to handle  HH:MM:SS AM/PM
BLYNK_WRITE(V1)
{
    String pinValue = param.asString(); // assigning incoming value from pin V1 to a variable
 80a03fa:	4668      	mov	r0, sp
    alarmTime = pinValue;
    Log.info("New time is %s.", alarmTime.c_str() );
    blynkUpdateReady = true;
 80a03fc:	701a      	strb	r2, [r3, #0]
}

// alarmTime - save as string? Need to handle  HH:MM:SS AM/PM
BLYNK_WRITE(V1)
{
    String pinValue = param.asString(); // assigning incoming value from pin V1 to a variable
 80a03fe:	f003 fe2c 	bl	80a405a <_ZN6StringD1Ev>
    alarmTime = pinValue;
    Log.info("New time is %s.", alarmTime.c_str() );
    blynkUpdateReady = true;
}
 80a0402:	b004      	add	sp, #16
 80a0404:	bd10      	pop	{r4, pc}
 80a0406:	bf00      	nop
 80a0408:	200003a0 	.word	0x200003a0
 80a040c:	080a5273 	.word	0x080a5273
 80a0410:	200004a0 	.word	0x200004a0
 80a0414:	20000304 	.word	0x20000304

080a0418 <BlynkWidgetWrite2>:

// red
BLYNK_WRITE(V2)
{
 80a0418:	b508      	push	{r3, lr}
 80a041a:	6808      	ldr	r0, [r1, #0]
 80a041c:	f004 fd64 	bl	80a4ee8 <atoi>
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.red = pinValue;
 80a0420:	4b05      	ldr	r3, [pc, #20]	; (80a0438 <BlynkWidgetWrite2+0x20>)
    Log.info("New red value is %d.", color.red);
 80a0422:	4906      	ldr	r1, [pc, #24]	; (80a043c <BlynkWidgetWrite2+0x24>)

// red
BLYNK_WRITE(V2)
{
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.red = pinValue;
 80a0424:	6018      	str	r0, [r3, #0]
    Log.info("New red value is %d.", color.red);
 80a0426:	681a      	ldr	r2, [r3, #0]
 80a0428:	4805      	ldr	r0, [pc, #20]	; (80a0440 <BlynkWidgetWrite2+0x28>)
 80a042a:	f7ff fec6 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a042e:	4b05      	ldr	r3, [pc, #20]	; (80a0444 <BlynkWidgetWrite2+0x2c>)
 80a0430:	2201      	movs	r2, #1
 80a0432:	701a      	strb	r2, [r3, #0]
 80a0434:	bd08      	pop	{r3, pc}
 80a0436:	bf00      	nop
 80a0438:	2000045c 	.word	0x2000045c
 80a043c:	080a5283 	.word	0x080a5283
 80a0440:	200004a0 	.word	0x200004a0
 80a0444:	20000304 	.word	0x20000304

080a0448 <BlynkWidgetWrite3>:
}

// green 
BLYNK_WRITE(V3)
{
 80a0448:	b508      	push	{r3, lr}
 80a044a:	6808      	ldr	r0, [r1, #0]
 80a044c:	f004 fd4c 	bl	80a4ee8 <atoi>
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.green = pinValue;
 80a0450:	4b05      	ldr	r3, [pc, #20]	; (80a0468 <BlynkWidgetWrite3+0x20>)
    Log.info("New green value is %d.", color.green);
 80a0452:	4906      	ldr	r1, [pc, #24]	; (80a046c <BlynkWidgetWrite3+0x24>)

// green 
BLYNK_WRITE(V3)
{
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.green = pinValue;
 80a0454:	6058      	str	r0, [r3, #4]
    Log.info("New green value is %d.", color.green);
 80a0456:	685a      	ldr	r2, [r3, #4]
 80a0458:	4805      	ldr	r0, [pc, #20]	; (80a0470 <BlynkWidgetWrite3+0x28>)
 80a045a:	f7ff feae 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a045e:	4b05      	ldr	r3, [pc, #20]	; (80a0474 <BlynkWidgetWrite3+0x2c>)
 80a0460:	2201      	movs	r2, #1
 80a0462:	701a      	strb	r2, [r3, #0]
 80a0464:	bd08      	pop	{r3, pc}
 80a0466:	bf00      	nop
 80a0468:	2000045c 	.word	0x2000045c
 80a046c:	080a5298 	.word	0x080a5298
 80a0470:	200004a0 	.word	0x200004a0
 80a0474:	20000304 	.word	0x20000304

080a0478 <BlynkWidgetWrite4>:
}

// blue 
BLYNK_WRITE(V4)
{
 80a0478:	b508      	push	{r3, lr}
 80a047a:	6808      	ldr	r0, [r1, #0]
 80a047c:	f004 fd34 	bl	80a4ee8 <atoi>
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.blue = pinValue;
 80a0480:	4b05      	ldr	r3, [pc, #20]	; (80a0498 <BlynkWidgetWrite4+0x20>)
    Log.info("New blue value is %d.", color.blue);
 80a0482:	4906      	ldr	r1, [pc, #24]	; (80a049c <BlynkWidgetWrite4+0x24>)

// blue 
BLYNK_WRITE(V4)
{
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    color.blue = pinValue;
 80a0484:	6098      	str	r0, [r3, #8]
    Log.info("New blue value is %d.", color.blue);
 80a0486:	689a      	ldr	r2, [r3, #8]
 80a0488:	4805      	ldr	r0, [pc, #20]	; (80a04a0 <BlynkWidgetWrite4+0x28>)
 80a048a:	f7ff fe96 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a048e:	4b05      	ldr	r3, [pc, #20]	; (80a04a4 <BlynkWidgetWrite4+0x2c>)
 80a0490:	2201      	movs	r2, #1
 80a0492:	701a      	strb	r2, [r3, #0]
 80a0494:	bd08      	pop	{r3, pc}
 80a0496:	bf00      	nop
 80a0498:	2000045c 	.word	0x2000045c
 80a049c:	080a52af 	.word	0x080a52af
 80a04a0:	200004a0 	.word	0x200004a0
 80a04a4:	20000304 	.word	0x20000304

080a04a8 <BlynkWidgetWrite5>:
}

// brightness 
BLYNK_WRITE(V5)
{
 80a04a8:	b508      	push	{r3, lr}
 80a04aa:	6808      	ldr	r0, [r1, #0]
 80a04ac:	f004 fd1c 	bl	80a4ee8 <atoi>
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    brightness = pinValue;
 80a04b0:	4b05      	ldr	r3, [pc, #20]	; (80a04c8 <BlynkWidgetWrite5+0x20>)
    Log.info("New brightness value is %d.", brightness);
 80a04b2:	4906      	ldr	r1, [pc, #24]	; (80a04cc <BlynkWidgetWrite5+0x24>)

// brightness 
BLYNK_WRITE(V5)
{
    int pinValue = param.asInt(); // assigning incoming value from pin V1 to a variable
    brightness = pinValue;
 80a04b4:	6018      	str	r0, [r3, #0]
    Log.info("New brightness value is %d.", brightness);
 80a04b6:	681a      	ldr	r2, [r3, #0]
 80a04b8:	4805      	ldr	r0, [pc, #20]	; (80a04d0 <BlynkWidgetWrite5+0x28>)
 80a04ba:	f7ff fe7e 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
    blynkUpdateReady = true;
 80a04be:	4b05      	ldr	r3, [pc, #20]	; (80a04d4 <BlynkWidgetWrite5+0x2c>)
 80a04c0:	2201      	movs	r2, #1
 80a04c2:	701a      	strb	r2, [r3, #0]
 80a04c4:	bd08      	pop	{r3, pc}
 80a04c6:	bf00      	nop
 80a04c8:	200003c4 	.word	0x200003c4
 80a04cc:	080a52c5 	.word	0x080a52c5
 80a04d0:	200004a0 	.word	0x200004a0
 80a04d4:	20000304 	.word	0x20000304

080a04d8 <_Z8setColorv>:
}

// setColor
void setColor(void){ 
 80a04d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    struct RGB newColor;
    switch(mode){
 80a04da:	4b13      	ldr	r3, [pc, #76]	; (80a0528 <_Z8setColorv+0x50>)
 80a04dc:	4d13      	ldr	r5, [pc, #76]	; (80a052c <_Z8setColorv+0x54>)
 80a04de:	681b      	ldr	r3, [r3, #0]
 80a04e0:	2b02      	cmp	r3, #2
 80a04e2:	d007      	beq.n	80a04f4 <_Z8setColorv+0x1c>
 80a04e4:	2b04      	cmp	r3, #4
 80a04e6:	d10a      	bne.n	80a04fe <_Z8setColorv+0x26>
            newColor.red = color.red;
            newColor.green = color.green;
            newColor.blue = color.blue;
            break;
        case WINDOW_MODE:
            newColor.red = windowColor.red;
 80a04e8:	4b11      	ldr	r3, [pc, #68]	; (80a0530 <_Z8setColorv+0x58>)
            newColor.green = windowColor.green;
            newColor.blue = windowColor.blue;
            break;
 80a04ea:	2400      	movs	r4, #0
            newColor.red = color.red;
            newColor.green = color.green;
            newColor.blue = color.blue;
            break;
        case WINDOW_MODE:
            newColor.red = windowColor.red;
 80a04ec:	681a      	ldr	r2, [r3, #0]
            newColor.green = windowColor.green;
 80a04ee:	685a      	ldr	r2, [r3, #4]
            newColor.blue = windowColor.blue;
 80a04f0:	689b      	ldr	r3, [r3, #8]
            break;
 80a04f2:	e005      	b.n	80a0500 <_Z8setColorv+0x28>
        // switch based on the mode
        case OFF_MODE:
            newColor.red = newColor.green = newColor.blue = 0;
            break;
        case RGB_MODE:
            newColor.red = color.red;
 80a04f4:	682b      	ldr	r3, [r5, #0]
            newColor.green = color.green;
            newColor.blue = color.blue;
            break;
 80a04f6:	2400      	movs	r4, #0
        case OFF_MODE:
            newColor.red = newColor.green = newColor.blue = 0;
            break;
        case RGB_MODE:
            newColor.red = color.red;
            newColor.green = color.green;
 80a04f8:	686b      	ldr	r3, [r5, #4]
            newColor.blue = color.blue;
 80a04fa:	68ab      	ldr	r3, [r5, #8]
            break;
 80a04fc:	e000      	b.n	80a0500 <_Z8setColorv+0x28>
}

// setColor
void setColor(void){ 
    struct RGB newColor;
    switch(mode){
 80a04fe:	2400      	movs	r4, #0
            newColor.red = newColor.green = newColor.blue = 200;
    }
    
    for(int led = 0; led < PIXEL_COUNT; led++)
    {
        strip.setPixelColor(led, color.red, color.green, color.blue);
 80a0500:	682a      	ldr	r2, [r5, #0]
 80a0502:	686b      	ldr	r3, [r5, #4]
 80a0504:	68a9      	ldr	r1, [r5, #8]
 80a0506:	b2db      	uxtb	r3, r3
 80a0508:	b2c9      	uxtb	r1, r1
 80a050a:	9100      	str	r1, [sp, #0]
 80a050c:	b2d2      	uxtb	r2, r2
 80a050e:	b2a1      	uxth	r1, r4
 80a0510:	4808      	ldr	r0, [pc, #32]	; (80a0534 <_Z8setColorv+0x5c>)
            break;
        default:
            newColor.red = newColor.green = newColor.blue = 200;
    }
    
    for(int led = 0; led < PIXEL_COUNT; led++)
 80a0512:	3401      	adds	r4, #1
    {
        strip.setPixelColor(led, color.red, color.green, color.blue);
 80a0514:	f001 ff6e 	bl	80a23f4 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
            break;
        default:
            newColor.red = newColor.green = newColor.blue = 200;
    }
    
    for(int led = 0; led < PIXEL_COUNT; led++)
 80a0518:	2c3c      	cmp	r4, #60	; 0x3c
 80a051a:	d1f1      	bne.n	80a0500 <_Z8setColorv+0x28>
    {
        strip.setPixelColor(led, color.red, color.green, color.blue);
    }
    strip.show();
 80a051c:	4805      	ldr	r0, [pc, #20]	; (80a0534 <_Z8setColorv+0x5c>)
}
 80a051e:	b003      	add	sp, #12
 80a0520:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    
    for(int led = 0; led < PIXEL_COUNT; led++)
    {
        strip.setPixelColor(led, color.red, color.green, color.blue);
    }
    strip.show();
 80a0524:	f000 beac 	b.w	80a1280 <_ZN17Adafruit_NeoPixel4showEv>
 80a0528:	20000300 	.word	0x20000300
 80a052c:	2000045c 	.word	0x2000045c
 80a0530:	200003b8 	.word	0x200003b8
 80a0534:	200003c8 	.word	0x200003c8

080a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a0538:	b570      	push	{r4, r5, r6, lr}
 80a053a:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a053c:	6804      	ldr	r4, [r0, #0]
 80a053e:	6843      	ldr	r3, [r0, #4]
 80a0540:	2614      	movs	r6, #20
 80a0542:	fb06 4603 	mla	r6, r6, r3, r4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a0546:	42a6      	cmp	r6, r4
 80a0548:	d004      	beq.n	80a0554 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0x1c>
    static int nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found);
};

} // namespace spark::detail

class LogCategoryFilter {
 80a054a:	4620      	mov	r0, r4
 80a054c:	f003 fd85 	bl	80a405a <_ZN6StringD1Ev>
 80a0550:	3414      	adds	r4, #20
 80a0552:	e7f8      	b.n	80a0546 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev+0xe>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a0554:	6828      	ldr	r0, [r5, #0]
 80a0556:	f002 f9c5 	bl	80a28e4 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a055a:	4628      	mov	r0, r5
 80a055c:	bd70      	pop	{r4, r5, r6, pc}

080a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>:
#endif
    }

private:

    void internalReconnect() {
 80a055e:	b508      	push	{r3, lr}
        state = CONNECTING;
 80a0560:	2300      	movs	r3, #0
 80a0562:	7743      	strb	r3, [r0, #29]

    void disconnect() { client.stop(); }
 80a0564:	6800      	ldr	r0, [r0, #0]
 80a0566:	f003 ff3f 	bl	80a43e8 <_ZN9TCPClient4stopEv>
        conn.disconnect();
        BlynkOnDisconnected();
    }
 80a056a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
private:

    void internalReconnect() {
        state = CONNECTING;
        conn.disconnect();
        BlynkOnDisconnected();
 80a056e:	f000 be0b 	b.w	80a1188 <BlynkNoOpCbk>

080a0572 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a0572:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a0574:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0576:	4606      	mov	r6, r0
 80a0578:	460c      	mov	r4, r1
 80a057a:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
 80a057c:	d916      	bls.n	80a05ac <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3a>
 80a057e:	4290      	cmp	r0, r2
 80a0580:	d215      	bcs.n	80a05ae <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3c>
            // Move elements in reverse order
            --p;
            --end;
 80a0582:	f1a2 0514 	sub.w	r5, r2, #20
            dest += end - p - 1;
 80a0586:	1a6c      	subs	r4, r5, r1
 80a0588:	f1a1 0714 	sub.w	r7, r1, #20
 80a058c:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a058e:	42af      	cmp	r7, r5
 80a0590:	d01c      	beq.n	80a05cc <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
                new(dest) T(std::move(*end));
 80a0592:	b12c      	cbz	r4, 80a05a0 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x2e>
 80a0594:	4629      	mov	r1, r5
 80a0596:	4620      	mov	r0, r4
 80a0598:	f003 fd4f 	bl	80a403a <_ZN6StringC1EOS_>
 80a059c:	7c2b      	ldrb	r3, [r5, #16]
 80a059e:	7423      	strb	r3, [r4, #16]
 80a05a0:	4628      	mov	r0, r5
 80a05a2:	f003 fd5a 	bl	80a405a <_ZN6StringD1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a05a6:	3d14      	subs	r5, #20
 80a05a8:	3c14      	subs	r4, #20
 80a05aa:	e7f0      	b.n	80a058e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x1c>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a05ac:	d00e      	beq.n	80a05cc <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
            for (; p != end; ++p, ++dest) {
 80a05ae:	42ac      	cmp	r4, r5
 80a05b0:	d00c      	beq.n	80a05cc <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x5a>
                new(dest) T(std::move(*p));
 80a05b2:	b12e      	cbz	r6, 80a05c0 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x4e>
 80a05b4:	4621      	mov	r1, r4
 80a05b6:	4630      	mov	r0, r6
 80a05b8:	f003 fd3f 	bl	80a403a <_ZN6StringC1EOS_>
 80a05bc:	7c23      	ldrb	r3, [r4, #16]
 80a05be:	7433      	strb	r3, [r6, #16]
 80a05c0:	4620      	mov	r0, r4
 80a05c2:	f003 fd4a 	bl	80a405a <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a05c6:	3414      	adds	r4, #20
 80a05c8:	3614      	adds	r6, #20
 80a05ca:	e7f0      	b.n	80a05ae <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x3c>
 80a05cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>:
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a05ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a05d2:	2300      	movs	r3, #0
 80a05d4:	6003      	str	r3, [r0, #0]
 80a05d6:	6043      	str	r3, [r0, #4]
 80a05d8:	6083      	str	r3, [r0, #8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a05da:	684e      	ldr	r6, [r1, #4]
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a05dc:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a05de:	429e      	cmp	r6, r3
        size_ = n;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
 80a05e0:	460f      	mov	r7, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
 80a05e2:	dd24      	ble.n	80a062e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x60>

} // namespace spark

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a05e4:	f04f 0814 	mov.w	r8, #20
 80a05e8:	fb08 f006 	mul.w	r0, r8, r6
 80a05ec:	f002 f972 	bl	80a28d4 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a05f0:	4605      	mov	r5, r0
 80a05f2:	b1e0      	cbz	r0, 80a062e <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x60>
                return false;
            }
            move(d, data_, data_ + size_);
 80a05f4:	e894 0006 	ldmia.w	r4, {r1, r2}
 80a05f8:	fb08 1202 	mla	r2, r8, r2, r1
 80a05fc:	f7ff ffb9 	bl	80a0572 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a0600:	6820      	ldr	r0, [r4, #0]
 80a0602:	f002 f96f 	bl	80a28e4 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a0606:	6025      	str	r5, [r4, #0]
        capacity_ = n;
 80a0608:	60a6      	str	r6, [r4, #8]
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
        copy(data_, vector.data_, vector.data_ + vector.size_);
 80a060a:	683e      	ldr	r6, [r7, #0]
 80a060c:	687b      	ldr	r3, [r7, #4]
 80a060e:	fb08 6803 	mla	r8, r8, r3, r6
        }
    }

    template<typename IteratorT>
    static void copy(IteratorT dest, IteratorT it, IteratorT end) {
        for (; it != end; ++it, ++dest) {
 80a0612:	4546      	cmp	r6, r8
 80a0614:	d009      	beq.n	80a062a <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x5c>
            new(dest) T(*it);
 80a0616:	b12d      	cbz	r5, 80a0624 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x56>
 80a0618:	4631      	mov	r1, r6
 80a061a:	4628      	mov	r0, r5
 80a061c:	f003 fd86 	bl	80a412c <_ZN6StringC1ERKS_>
 80a0620:	7c33      	ldrb	r3, [r6, #16]
 80a0622:	742b      	strb	r3, [r5, #16]
        }
    }

    template<typename IteratorT>
    static void copy(IteratorT dest, IteratorT it, IteratorT end) {
        for (; it != end; ++it, ++dest) {
 80a0624:	3614      	adds	r6, #20
 80a0626:	3514      	adds	r5, #20
 80a0628:	e7f3      	b.n	80a0612 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_+0x44>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
    if (vector.size_ > 0 && realloc(vector.size_)) {
        copy(data_, vector.data_, vector.data_ + vector.size_);
        size_ = vector.size_;
 80a062a:	687b      	ldr	r3, [r7, #4]
 80a062c:	6063      	str	r3, [r4, #4]
    }
}
 80a062e:	4620      	mov	r0, r4
 80a0630:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a0634 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj>:
    #endif
#endif

template<class Proto>
BLYNK_FORCE_INLINE
void BlynkApi<Proto>::processCmd(const void* buff, size_t len)
 80a0634:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    double      asDouble() const    { return atof(buff); }
    float       asFloat() const     { return atof(buff); }
#endif
    bool isEmpty() const            { return *buff == '\0'; }

    iterator begin() const { return iterator(buff, buff+len); }
 80a0638:	188f      	adds	r7, r1, r2
 80a063a:	b08e      	sub	sp, #56	; 0x38
{
    BlynkParam param((void*)buff, len);
    BlynkParam::iterator it = param.begin();
    if (it >= param.end())
 80a063c:	42b9      	cmp	r1, r7
    #endif
#endif

template<class Proto>
BLYNK_FORCE_INLINE
void BlynkApi<Proto>::processCmd(const void* buff, size_t len)
 80a063e:	4606      	mov	r6, r0
 80a0640:	460d      	mov	r5, r1
 80a0642:	4690      	mov	r8, r2
{
public:
    class iterator
    {
    public:
        iterator(const char* c, const char* l) : ptr(c), limit(l) {}
 80a0644:	9105      	str	r1, [sp, #20]
 80a0646:	9706      	str	r7, [sp, #24]
{
    BlynkParam param((void*)buff, len);
    BlynkParam::iterator it = param.begin();
    if (it >= param.end())
 80a0648:	f080 80fc 	bcs.w	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
        return;
    const char* cmd = it.asStr();
    uint16_t cmd16;
    memcpy(&cmd16, cmd, sizeof(cmd16));
 80a064c:	880b      	ldrh	r3, [r1, #0]
    if (++it >= param.end())
 80a064e:	a805      	add	r0, sp, #20
    BlynkParam::iterator it = param.begin();
    if (it >= param.end())
        return;
    const char* cmd = it.asStr();
    uint16_t cmd16;
    memcpy(&cmd16, cmd, sizeof(cmd16));
 80a0650:	f8ad 3012 	strh.w	r3, [sp, #18]
    if (++it >= param.end())
 80a0654:	f7ff fde9 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a0658:	6803      	ldr	r3, [r0, #0]
 80a065a:	429f      	cmp	r7, r3
 80a065c:	f240 80f2 	bls.w	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
        return;

    uint8_t pin = BLYNK_DECODE_PIN(it);
 80a0660:	a805      	add	r0, sp, #20
 80a0662:	f7ff fdd8 	bl	80a0216 <_ZNK10BlynkParam8iterator5asIntEv>

    switch(cmd16) {
 80a0666:	f247 2276 	movw	r2, #29302	; 0x7276
 80a066a:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    uint16_t cmd16;
    memcpy(&cmd16, cmd, sizeof(cmd16));
    if (++it >= param.end())
        return;

    uint8_t pin = BLYNK_DECODE_PIN(it);
 80a066e:	b2c4      	uxtb	r4, r0

    switch(cmd16) {
 80a0670:	4293      	cmp	r3, r2
 80a0672:	f000 809f 	beq.w	80a07b4 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x180>
 80a0676:	d80d      	bhi.n	80a0694 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x60>
 80a0678:	f247 2261 	movw	r2, #29281	; 0x7261
 80a067c:	4293      	cmp	r3, r2
 80a067e:	d065      	beq.n	80a074c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x118>
 80a0680:	f247 2264 	movw	r2, #29284	; 0x7264
 80a0684:	4293      	cmp	r3, r2
 80a0686:	d039      	beq.n	80a06fc <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0xc8>
 80a0688:	f646 5270 	movw	r2, #28016	; 0x6d70
 80a068c:	4293      	cmp	r3, r2
 80a068e:	f040 80bd 	bne.w	80a080c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x1d8>
 80a0692:	e02f      	b.n	80a06f4 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0xc0>
 80a0694:	f247 7264 	movw	r2, #30564	; 0x7764
 80a0698:	4293      	cmp	r3, r2
 80a069a:	d041      	beq.n	80a0720 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0xec>
 80a069c:	f247 7276 	movw	r2, #30582	; 0x7776
 80a06a0:	4293      	cmp	r3, r2
 80a06a2:	f000 8098 	beq.w	80a07d6 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x1a2>
 80a06a6:	f247 7261 	movw	r2, #30561	; 0x7761
 80a06aa:	4293      	cmp	r3, r2
 80a06ac:	f040 80ae 	bne.w	80a080c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x1d8>
 80a06b0:	e06d      	b.n	80a078e <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x15a>

#ifndef BLYNK_NO_BUILTIN

    case BLYNK_HW_PM: {
        while (it < param.end()) {
            pin = BLYNK_DECODE_PIN(it);
 80a06b2:	a805      	add	r0, sp, #20
 80a06b4:	f7ff fdaf 	bl	80a0216 <_ZNK10BlynkParam8iterator5asIntEv>
 80a06b8:	b2c5      	uxtb	r5, r0
            ++it;
 80a06ba:	a805      	add	r0, sp, #20
 80a06bc:	f7ff fdb5 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a06c0:	9c05      	ldr	r4, [sp, #20]
            if (!strcmp(it.asStr(), "in")) {
 80a06c2:	4962      	ldr	r1, [pc, #392]	; (80a084c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x218>)
 80a06c4:	4620      	mov	r0, r4
 80a06c6:	f004 fc93 	bl	80a4ff0 <strcmp>
 80a06ca:	4601      	mov	r1, r0
 80a06cc:	2800      	cmp	r0, #0
 80a06ce:	f000 80b5 	beq.w	80a083c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x208>
                pinMode(pin, INPUT);
            } else if (!strcmp(it.asStr(), "out") || !strcmp(it.asStr(), "pwm")) {
 80a06d2:	495f      	ldr	r1, [pc, #380]	; (80a0850 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x21c>)
 80a06d4:	4620      	mov	r0, r4
 80a06d6:	f004 fc8b 	bl	80a4ff0 <strcmp>
 80a06da:	2800      	cmp	r0, #0
 80a06dc:	f000 80ad 	beq.w	80a083a <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x206>
 80a06e0:	495c      	ldr	r1, [pc, #368]	; (80a0854 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x220>)
 80a06e2:	4620      	mov	r0, r4
 80a06e4:	f004 fc84 	bl	80a4ff0 <strcmp>
 80a06e8:	2800      	cmp	r0, #0
 80a06ea:	f000 80a6 	beq.w	80a083a <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x206>
            } else {
#ifdef BLYNK_DEBUG
                BLYNK_LOG4(BLYNK_F("Invalid pin "), pin, BLYNK_F(" mode "), it.asStr());
#endif
            }
            ++it;
 80a06ee:	a805      	add	r0, sp, #20
 80a06f0:	f7ff fd9b 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
    switch(cmd16) {

#ifndef BLYNK_NO_BUILTIN

    case BLYNK_HW_PM: {
        while (it < param.end()) {
 80a06f4:	9b05      	ldr	r3, [sp, #20]
 80a06f6:	429f      	cmp	r7, r3
 80a06f8:	d8db      	bhi.n	80a06b2 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x7e>
 80a06fa:	e0a3      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
        : buff((char*)addr), len(length), buff_size(length)
    {}

    explicit
    BlynkParam(void* addr, size_t length, size_t buffsize)
        : buff((char*)addr), len(length), buff_size(buffsize)
 80a06fc:	ab0a      	add	r3, sp, #40	; 0x28
 80a06fe:	9307      	str	r3, [sp, #28]
        }
    } break;
    case BLYNK_HW_DR: {
        char mem[16];
        BlynkParam rsp(mem, 0, sizeof(mem));
        rsp.add("dw");
 80a0700:	a807      	add	r0, sp, #28
 80a0702:	2310      	movs	r3, #16
 80a0704:	2500      	movs	r5, #0
 80a0706:	4954      	ldr	r1, [pc, #336]	; (80a0858 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x224>)
 80a0708:	9309      	str	r3, [sp, #36]	; 0x24
 80a070a:	9508      	str	r5, [sp, #32]
 80a070c:	f7ff fd9c 	bl	80a0248 <_ZN10BlynkParam3addEPKc>
        rsp.add(pin);
 80a0710:	a807      	add	r0, sp, #28
 80a0712:	4621      	mov	r1, r4
 80a0714:	f7ff fdb4 	bl	80a0280 <_ZN10BlynkParam3addEi>
        rsp.add(digitalRead(pin));
 80a0718:	4620      	mov	r0, r4
 80a071a:	f004 f9d5 	bl	80a4ac8 <digitalRead>
 80a071e:	e026      	b.n	80a076e <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x13a>
        static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_HARDWARE, 0, rsp.getBuffer(), rsp.getLength()-1);
    } break;
    case BLYNK_HW_DW: {
        // Should be 1 parameter (value)
        if (++it >= param.end())
 80a0720:	a805      	add	r0, sp, #20
 80a0722:	f7ff fd82 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a0726:	6803      	ldr	r3, [r0, #0]
 80a0728:	429f      	cmp	r7, r3
 80a072a:	f240 808b 	bls.w	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
#ifdef ESP8266
        // Disable PWM...
        analogWrite(pin, 0);
#endif
#ifndef BLYNK_MINIMIZE_PINMODE_USAGE
        pinMode(pin, OUTPUT);
 80a072e:	b2a4      	uxth	r4, r4
 80a0730:	2101      	movs	r1, #1
 80a0732:	4620      	mov	r0, r4
 80a0734:	f004 f99e 	bl	80a4a74 <pinMode>
#endif
        digitalWrite(pin, it.asInt() ? HIGH : LOW);
 80a0738:	a805      	add	r0, sp, #20
 80a073a:	f7ff fd6c 	bl	80a0216 <_ZNK10BlynkParam8iterator5asIntEv>
 80a073e:	1c01      	adds	r1, r0, #0
 80a0740:	bf18      	it	ne
 80a0742:	2101      	movne	r1, #1
 80a0744:	4620      	mov	r0, r4
 80a0746:	f004 f9a6 	bl	80a4a96 <digitalWrite>
    } break;
 80a074a:	e07b      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
 80a074c:	ab0a      	add	r3, sp, #40	; 0x28
 80a074e:	9307      	str	r3, [sp, #28]
    case BLYNK_HW_AR: {
        char mem[16];
        BlynkParam rsp(mem, 0, sizeof(mem));
        rsp.add("aw");
 80a0750:	4942      	ldr	r1, [pc, #264]	; (80a085c <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x228>)
 80a0752:	2310      	movs	r3, #16
 80a0754:	a807      	add	r0, sp, #28
 80a0756:	2500      	movs	r5, #0
 80a0758:	9309      	str	r3, [sp, #36]	; 0x24
 80a075a:	9508      	str	r5, [sp, #32]
 80a075c:	f7ff fd74 	bl	80a0248 <_ZN10BlynkParam3addEPKc>
        rsp.add(pin);
 80a0760:	a807      	add	r0, sp, #28
 80a0762:	4621      	mov	r1, r4
 80a0764:	f7ff fd8c 	bl	80a0280 <_ZN10BlynkParam3addEi>
        rsp.add(analogRead(pin));
 80a0768:	4620      	mov	r0, r4
 80a076a:	f004 f9c0 	bl	80a4aee <analogRead>
 80a076e:	4601      	mov	r1, r0
 80a0770:	a807      	add	r0, sp, #28
 80a0772:	f7ff fd97 	bl	80a02a4 <_ZN10BlynkParam3addEl>
        static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_HARDWARE, 0, rsp.getBuffer(), rsp.getLength()-1);
 80a0776:	9b08      	ldr	r3, [sp, #32]
 80a0778:	9502      	str	r5, [sp, #8]
 80a077a:	3b01      	subs	r3, #1
 80a077c:	9300      	str	r3, [sp, #0]
 80a077e:	9501      	str	r5, [sp, #4]
 80a0780:	9b07      	ldr	r3, [sp, #28]
 80a0782:	462a      	mov	r2, r5
 80a0784:	2114      	movs	r1, #20
 80a0786:	4630      	mov	r0, r6
 80a0788:	f000 fb72 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
    } break;
 80a078c:	e05a      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
    case BLYNK_HW_AW: {
        // Should be 1 parameter (value)
        if (++it >= param.end())
 80a078e:	a805      	add	r0, sp, #20
 80a0790:	f7ff fd4b 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a0794:	6803      	ldr	r3, [r0, #0]
 80a0796:	429f      	cmp	r7, r3
 80a0798:	d954      	bls.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
            return;

#ifndef BLYNK_MINIMIZE_PINMODE_USAGE
        pinMode(pin, OUTPUT);
 80a079a:	b2a4      	uxth	r4, r4
 80a079c:	2101      	movs	r1, #1
 80a079e:	4620      	mov	r0, r4
 80a07a0:	f004 f968 	bl	80a4a74 <pinMode>
#endif
        analogWrite(pin, it.asInt());
 80a07a4:	a805      	add	r0, sp, #20
 80a07a6:	f7ff fd36 	bl	80a0216 <_ZNK10BlynkParam8iterator5asIntEv>
 80a07aa:	4601      	mov	r1, r0
 80a07ac:	4620      	mov	r0, r4
 80a07ae:	f004 f9b5 	bl	80a4b1c <_Z11analogWritetm>
    } break;
 80a07b2:	e047      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>

#endif

    case BLYNK_HW_VR: {
        BlynkReq req = { pin };
 80a07b4:	ad0e      	add	r5, sp, #56	; 0x38
        WidgetReadHandler handler = GetReadHandler(pin);
 80a07b6:	4620      	mov	r0, r4
    } break;

#endif

    case BLYNK_HW_VR: {
        BlynkReq req = { pin };
 80a07b8:	f805 4d10 	strb.w	r4, [r5, #-16]!
        WidgetReadHandler handler = GetReadHandler(pin);
 80a07bc:	f000 fce6 	bl	80a118c <GetReadHandler>
        if (handler && (handler != BlynkWidgetRead)) {
 80a07c0:	4603      	mov	r3, r0
            handler(req);
 80a07c2:	4628      	mov	r0, r5
#endif

    case BLYNK_HW_VR: {
        BlynkReq req = { pin };
        WidgetReadHandler handler = GetReadHandler(pin);
        if (handler && (handler != BlynkWidgetRead)) {
 80a07c4:	b123      	cbz	r3, 80a07d0 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x19c>
 80a07c6:	4a26      	ldr	r2, [pc, #152]	; (80a0860 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x22c>)
 80a07c8:	4293      	cmp	r3, r2
 80a07ca:	d001      	beq.n	80a07d0 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x19c>
            handler(req);
 80a07cc:	4798      	blx	r3
 80a07ce:	e039      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
        } else {
            BlynkWidgetReadDefault(req);
 80a07d0:	f000 fcd8 	bl	80a1184 <BlynkWidgetRead>
        }
    } break;
 80a07d4:	e036      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
    case BLYNK_HW_VW: {
        ++it;
 80a07d6:	a805      	add	r0, sp, #20
 80a07d8:	f7ff fd27 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a07dc:	9b05      	ldr	r3, [sp, #20]
        char* start = (char*)it.asStr();
        BlynkParam param2(start, len - (start - (char*)buff));
        BlynkReq req = { pin };
        WidgetWriteHandler handler = GetWriteHandler(pin);
 80a07de:	4620      	mov	r0, r4
        }
    } break;
    case BLYNK_HW_VW: {
        ++it;
        char* start = (char*)it.asStr();
        BlynkParam param2(start, len - (start - (char*)buff));
 80a07e0:	1b5d      	subs	r5, r3, r5
 80a07e2:	ebc5 0508 	rsb	r5, r5, r8
    };

public:
    explicit
    BlynkParam(const void* addr, size_t length)
        : buff((char*)addr), len(length), buff_size(length)
 80a07e6:	930a      	str	r3, [sp, #40]	; 0x28
 80a07e8:	950b      	str	r5, [sp, #44]	; 0x2c
 80a07ea:	950c      	str	r5, [sp, #48]	; 0x30
        BlynkReq req = { pin };
 80a07ec:	f88d 401c 	strb.w	r4, [sp, #28]
        WidgetWriteHandler handler = GetWriteHandler(pin);
 80a07f0:	f000 fcd6 	bl	80a11a0 <GetWriteHandler>
        if (handler && (handler != BlynkWidgetWrite)) {
 80a07f4:	4603      	mov	r3, r0
            handler(req, param2);
 80a07f6:	a90a      	add	r1, sp, #40	; 0x28
 80a07f8:	a807      	add	r0, sp, #28
        ++it;
        char* start = (char*)it.asStr();
        BlynkParam param2(start, len - (start - (char*)buff));
        BlynkReq req = { pin };
        WidgetWriteHandler handler = GetWriteHandler(pin);
        if (handler && (handler != BlynkWidgetWrite)) {
 80a07fa:	b123      	cbz	r3, 80a0806 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x1d2>
 80a07fc:	4a19      	ldr	r2, [pc, #100]	; (80a0864 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x230>)
 80a07fe:	4293      	cmp	r3, r2
 80a0800:	d001      	beq.n	80a0806 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x1d2>
            handler(req, param2);
 80a0802:	4798      	blx	r3
 80a0804:	e01e      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
        } else {
            BlynkWidgetWriteDefault(req, param2);
 80a0806:	f000 fcbe 	bl	80a1186 <BlynkWidgetWrite>
        }
    } break;
 80a080a:	e01b      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
    default:
        BLYNK_LOG2(BLYNK_F("Invalid HW cmd: "), cmd);
 80a080c:	f7ff fc62 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0810:	f003 fff8 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0814:	4914      	ldr	r1, [pc, #80]	; (80a0868 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x234>)
 80a0816:	f003 faf9 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a081a:	f003 fff3 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a081e:	4629      	mov	r1, r5
 80a0820:	f003 fb07 	bl	80a3e32 <_ZN5Print7printlnEPKc>
        static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_RESPONSE, static_cast<Proto*>(this)->msgIdOutOverride, NULL, BLYNK_ILLEGAL_COMMAND);
 80a0824:	2300      	movs	r3, #0
 80a0826:	2102      	movs	r1, #2
 80a0828:	9100      	str	r1, [sp, #0]
 80a082a:	8b72      	ldrh	r2, [r6, #26]
 80a082c:	9302      	str	r3, [sp, #8]
 80a082e:	9301      	str	r3, [sp, #4]
 80a0830:	4619      	mov	r1, r3
 80a0832:	4630      	mov	r0, r6
 80a0834:	f000 fb1c 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
 80a0838:	e004      	b.n	80a0844 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0x210>
            pin = BLYNK_DECODE_PIN(it);
            ++it;
            if (!strcmp(it.asStr(), "in")) {
                pinMode(pin, INPUT);
            } else if (!strcmp(it.asStr(), "out") || !strcmp(it.asStr(), "pwm")) {
                pinMode(pin, OUTPUT);
 80a083a:	2101      	movs	r1, #1
 80a083c:	4628      	mov	r0, r5
 80a083e:	f004 f919 	bl	80a4a74 <pinMode>
 80a0842:	e754      	b.n	80a06ee <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj+0xba>
    } break;
    default:
        BLYNK_LOG2(BLYNK_F("Invalid HW cmd: "), cmd);
        static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_RESPONSE, static_cast<Proto*>(this)->msgIdOutOverride, NULL, BLYNK_ILLEGAL_COMMAND);
    }
}
 80a0844:	b00e      	add	sp, #56	; 0x38
 80a0846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a084a:	bf00      	nop
 80a084c:	080a52e1 	.word	0x080a52e1
 80a0850:	080a5388 	.word	0x080a5388
 80a0854:	080a52e4 	.word	0x080a52e4
 80a0858:	080a52e8 	.word	0x080a52e8
 80a085c:	080a52eb 	.word	0x080a52eb
 80a0860:	080a1185 	.word	0x080a1185
 80a0864:	080a1187 	.word	0x080a1187
 80a0868:	080a52ee 	.word	0x080a52ee

080a086c <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv>:
    return true;
}

template <class Transp>
BLYNK_FORCE_INLINE
bool BlynkProtocol<Transp>::processInput(void)
 80a086c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0870:	b08e      	sub	sp, #56	; 0x38
 80a0872:	af04      	add	r7, sp, #16
 80a0874:	4605      	mov	r5, r0

    size_t read(void* buf, size_t len) {
        return client.readBytes((char*)buf, len);
 80a0876:	2205      	movs	r2, #5
 80a0878:	f107 010c 	add.w	r1, r7, #12
 80a087c:	6800      	ldr	r0, [r0, #0]
 80a087e:	f003 fbc7 	bl	80a4010 <_ZN6Stream9readBytesEPcj>

template <class Transp>
int BlynkProtocol<Transp>::readHeader(BlynkHeader& hdr)
{
    size_t rlen = conn.read(&hdr, sizeof(hdr));
    if (rlen == 0) {
 80a0882:	2800      	cmp	r0, #0
 80a0884:	f000 8195 	beq.w	80a0bb2 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x346>
        return 0;
    }

    if (sizeof(hdr) != rlen) {
 80a0888:	2805      	cmp	r0, #5
 80a088a:	d001      	beq.n	80a0890 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x24>

    if (ret < 0 || hdr.msg_id == 0) {
#ifdef BLYNK_DEBUG
        BLYNK_LOG2(BLYNK_F("Bad hdr len: "), ret);
#endif
        return false;
 80a088c:	2000      	movs	r0, #0
 80a088e:	e195      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
        return -1;
    }

    BLYNK_DBG_DUMP(">", &hdr, sizeof(BlynkHeader));

    hdr.msg_id = ntohs(hdr.msg_id);
 80a0890:	f8b7 200d 	ldrh.w	r2, [r7, #13]
    hdr.length = ntohs(hdr.length);
 80a0894:	f8b7 400f 	ldrh.w	r4, [r7, #15]
        return -1;
    }

    BLYNK_DBG_DUMP(">", &hdr, sizeof(BlynkHeader));

    hdr.msg_id = ntohs(hdr.msg_id);
 80a0898:	0a13      	lsrs	r3, r2, #8
 80a089a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    hdr.length = ntohs(hdr.length);
 80a089e:	0a23      	lsrs	r3, r4, #8
 80a08a0:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
        return -1;
    }

    BLYNK_DBG_DUMP(">", &hdr, sizeof(BlynkHeader));

    hdr.msg_id = ntohs(hdr.msg_id);
 80a08a4:	b292      	uxth	r2, r2
    hdr.length = ntohs(hdr.length);
 80a08a6:	b2a4      	uxth	r4, r4
        return -1;
    }

    BLYNK_DBG_DUMP(">", &hdr, sizeof(BlynkHeader));

    hdr.msg_id = ntohs(hdr.msg_id);
 80a08a8:	f8a7 200d 	strh.w	r2, [r7, #13]
    hdr.length = ntohs(hdr.length);
 80a08ac:	f8a7 400f 	strh.w	r4, [r7, #15]

    if (ret == 0) {
        return true; // Considered OK (no data on input)
    }

    if (ret < 0 || hdr.msg_id == 0) {
 80a08b0:	2a00      	cmp	r2, #0
 80a08b2:	d0eb      	beq.n	80a088c <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x20>
        BLYNK_LOG2(BLYNK_F("Bad hdr len: "), ret);
#endif
        return false;
    }

    if (hdr.type == BLYNK_CMD_RESPONSE) {
 80a08b4:	7b3b      	ldrb	r3, [r7, #12]
 80a08b6:	2b00      	cmp	r3, #0
 80a08b8:	d14f      	bne.n	80a095a <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0xee>
        lastActivityIn = BlynkMillis();
 80a08ba:	f000 fc5f 	bl	80a117c <_Z11BlynkMillisv>

#ifndef BLYNK_USE_DIRECT_CONNECT
        if (state == CONNECTING && (1 == hdr.msg_id)) {
 80a08be:	7f6c      	ldrb	r4, [r5, #29]
#endif
        return false;
    }

    if (hdr.type == BLYNK_CMD_RESPONSE) {
        lastActivityIn = BlynkMillis();
 80a08c0:	60e8      	str	r0, [r5, #12]
 80a08c2:	f8b7 000f 	ldrh.w	r0, [r7, #15]

#ifndef BLYNK_USE_DIRECT_CONNECT
        if (state == CONNECTING && (1 == hdr.msg_id)) {
 80a08c6:	2c00      	cmp	r4, #0
 80a08c8:	d143      	bne.n	80a0952 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0xe6>
 80a08ca:	f8b7 300d 	ldrh.w	r3, [r7, #13]
 80a08ce:	2b01      	cmp	r3, #1
 80a08d0:	d13f      	bne.n	80a0952 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0xe6>
            switch (hdr.length) {
 80a08d2:	2809      	cmp	r0, #9
 80a08d4:	d024      	beq.n	80a0920 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0xb4>
 80a08d6:	28c8      	cmp	r0, #200	; 0xc8
 80a08d8:	d001      	beq.n	80a08de <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x72>
 80a08da:	2804      	cmp	r0, #4
 80a08dc:	d129      	bne.n	80a0932 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0xc6>
            case BLYNK_SUCCESS:
            case BLYNK_ALREADY_REGISTERED:
                BLYNK_LOG3(BLYNK_F("Ready (ping: "), lastActivityIn-lastHeartbeat, BLYNK_F("ms)."));
 80a08de:	f7ff fbf9 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a08e2:	f003 ff8f 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a08e6:	49b7      	ldr	r1, [pc, #732]	; (80a0bc4 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x358>)
 80a08e8:	f003 fa90 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a08ec:	f003 ff8a 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a08f0:	696b      	ldr	r3, [r5, #20]
 80a08f2:	68e9      	ldr	r1, [r5, #12]
 80a08f4:	220a      	movs	r2, #10
 80a08f6:	1ac9      	subs	r1, r1, r3
 80a08f8:	f003 fac4 	bl	80a3e84 <_ZN5Print5printEmi>
 80a08fc:	f003 ff82 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0900:	49b1      	ldr	r1, [pc, #708]	; (80a0bc8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x35c>)
 80a0902:	f003 fa96 	bl	80a3e32 <_ZN5Print7printlnEPKc>
                lastHeartbeat = lastActivityIn;
 80a0906:	68eb      	ldr	r3, [r5, #12]
                state = CONNECTED;
 80a0908:	2401      	movs	r4, #1
#ifdef BLYNK_DEBUG
                if (size_t ram = BlynkFreeRam()) {
                    BLYNK_LOG2(BLYNK_F("Free RAM: "), ram);
                }
#endif
                this->sendInfo();
 80a090a:	4628      	mov	r0, r5
        if (state == CONNECTING && (1 == hdr.msg_id)) {
            switch (hdr.length) {
            case BLYNK_SUCCESS:
            case BLYNK_ALREADY_REGISTERED:
                BLYNK_LOG3(BLYNK_F("Ready (ping: "), lastActivityIn-lastHeartbeat, BLYNK_F("ms)."));
                lastHeartbeat = lastActivityIn;
 80a090c:	616b      	str	r3, [r5, #20]
                state = CONNECTED;
 80a090e:	776c      	strb	r4, [r5, #29]
#ifdef BLYNK_DEBUG
                if (size_t ram = BlynkFreeRam()) {
                    BLYNK_LOG2(BLYNK_F("Free RAM: "), ram);
                }
#endif
                this->sendInfo();
 80a0910:	f000 fb68 	bl	80a0fe4 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE8sendInfoEv>
                BLYNK_RUN_YIELD();
 80a0914:	f7ff fc1c 	bl	80a0150 <_ZN10CloudClass7processEv>
                BlynkOnConnected();
 80a0918:	f000 fc36 	bl	80a1188 <BlynkNoOpCbk>
 80a091c:	4620      	mov	r0, r4
 80a091e:	e14d      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
                return true;
            case BLYNK_INVALID_TOKEN:
                BLYNK_LOG1(BLYNK_F("Invalid auth token"));
 80a0920:	f7ff fbd8 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0924:	f003 ff6e 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0928:	49a8      	ldr	r1, [pc, #672]	; (80a0bcc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x360>)
 80a092a:	f003 fa82 	bl	80a3e32 <_ZN5Print7printlnEPKc>
                break;
            default:
                BLYNK_LOG2(BLYNK_F("Connect failed. code: "), hdr.length);
            }
            return false;
 80a092e:	4620      	mov	r0, r4
                BLYNK_RUN_YIELD();
                BlynkOnConnected();
                return true;
            case BLYNK_INVALID_TOKEN:
                BLYNK_LOG1(BLYNK_F("Invalid auth token"));
                break;
 80a0930:	e144      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
            default:
                BLYNK_LOG2(BLYNK_F("Connect failed. code: "), hdr.length);
 80a0932:	f7ff fbcf 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0936:	f003 ff65 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a093a:	49a5      	ldr	r1, [pc, #660]	; (80a0bd0 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x364>)
 80a093c:	f003 fa66 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a0940:	f003 ff60 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0944:	220a      	movs	r2, #10
 80a0946:	f8b7 100f 	ldrh.w	r1, [r7, #15]
 80a094a:	f003 fad4 	bl	80a3ef6 <_ZN5Print7printlnEii>
            }
            return false;
 80a094e:	4620      	mov	r0, r4
 80a0950:	e134      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
        }
        if (BLYNK_NOT_AUTHENTICATED == hdr.length) {
 80a0952:	3805      	subs	r0, #5
 80a0954:	bf18      	it	ne
 80a0956:	2001      	movne	r0, #1
 80a0958:	e130      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
#endif
        // TODO: return code may indicate App presence
        return true;
    }

    if (hdr.length > BLYNK_MAX_READBYTES) {
 80a095a:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
 80a095e:	d912      	bls.n	80a0986 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x11a>
        BLYNK_LOG2(BLYNK_F("Packet too big: "), hdr.length);
 80a0960:	f7ff fbb8 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0964:	f003 ff4e 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0968:	499a      	ldr	r1, [pc, #616]	; (80a0bd4 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x368>)
 80a096a:	f003 fa4f 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a096e:	f003 ff49 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0972:	220a      	movs	r2, #10
 80a0974:	f8b7 100f 	ldrh.w	r1, [r7, #15]
 80a0978:	f003 fabd 	bl	80a3ef6 <_ZN5Print7printlnEii>
        // TODO: Flush
        internalReconnect();
 80a097c:	4628      	mov	r0, r5
 80a097e:	f7ff fdee 	bl	80a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>
        return true;
 80a0982:	2001      	movs	r0, #1
 80a0984:	e11a      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
    }

    uint8_t inputBuffer[hdr.length+1]; // Add 1 to zero-terminate
 80a0986:	f104 0308 	add.w	r3, r4, #8
 80a098a:	f023 0307 	bic.w	r3, r3, #7
 80a098e:	46e8      	mov	r8, sp
 80a0990:	ebad 0d03 	sub.w	sp, sp, r3
 80a0994:	ae04      	add	r6, sp, #16
 80a0996:	4622      	mov	r2, r4
 80a0998:	4631      	mov	r1, r6
 80a099a:	6828      	ldr	r0, [r5, #0]
 80a099c:	f003 fb38 	bl	80a4010 <_ZN6Stream9readBytesEPcj>
    if (hdr.length != conn.read(inputBuffer, hdr.length)) {
 80a09a0:	4284      	cmp	r4, r0
 80a09a2:	f04f 0400 	mov.w	r4, #0
 80a09a6:	f040 80ff 	bne.w	80a0ba8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x33c>
#ifdef BLYNK_DEBUG
        BLYNK_LOG1(BLYNK_F("Can't read body"));
#endif
        return false;
    }
    inputBuffer[hdr.length] = '\0';
 80a09aa:	f8b7 300f 	ldrh.w	r3, [r7, #15]
 80a09ae:	54f4      	strb	r4, [r6, r3]

    BLYNK_DBG_DUMP(">", inputBuffer, hdr.length);

    lastActivityIn = BlynkMillis();
 80a09b0:	f000 fbe4 	bl	80a117c <_Z11BlynkMillisv>

    switch (hdr.type)
 80a09b4:	7b3b      	ldrb	r3, [r7, #12]
    }
    inputBuffer[hdr.length] = '\0';

    BLYNK_DBG_DUMP(">", inputBuffer, hdr.length);

    lastActivityIn = BlynkMillis();
 80a09b6:	60e8      	str	r0, [r5, #12]

    switch (hdr.type)
 80a09b8:	2b11      	cmp	r3, #17
 80a09ba:	f000 809b 	beq.w	80a0af4 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x288>
 80a09be:	d807      	bhi.n	80a09d0 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x164>
 80a09c0:	2b06      	cmp	r3, #6
 80a09c2:	d02d      	beq.n	80a0a20 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x1b4>
 80a09c4:	2b0f      	cmp	r3, #15
 80a09c6:	f000 8087 	beq.w	80a0ad8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x26c>
 80a09ca:	2b02      	cmp	r3, #2
 80a09cc:	d009      	beq.n	80a09e2 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x176>
 80a09ce:	e0e6      	b.n	80a0b9e <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x332>
 80a09d0:	2b29      	cmp	r3, #41	; 0x29
 80a09d2:	d032      	beq.n	80a0a3a <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x1ce>
 80a09d4:	2b37      	cmp	r3, #55	; 0x37
 80a09d6:	f000 80d1 	beq.w	80a0b7c <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x310>
 80a09da:	2b14      	cmp	r3, #20
 80a09dc:	f040 80df 	bne.w	80a0b9e <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x332>
 80a09e0:	e07a      	b.n	80a0ad8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x26c>
            BLYNK_LOG1(BLYNK_F("Invalid token"));
            sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_INVALID_TOKEN);
            break;
        }
#endif
        if (state == CONNECTING) {
 80a09e2:	7f6b      	ldrb	r3, [r5, #29]
 80a09e4:	b97b      	cbnz	r3, 80a0a06 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x19a>
            BLYNK_LOG1(BLYNK_F("Ready"));
 80a09e6:	f7ff fb75 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a09ea:	f003 ff0b 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a09ee:	497a      	ldr	r1, [pc, #488]	; (80a0bd8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x36c>)
 80a09f0:	f003 fa1f 	bl	80a3e32 <_ZN5Print7printlnEPKc>
            state = CONNECTED;
 80a09f4:	2301      	movs	r3, #1
 80a09f6:	776b      	strb	r3, [r5, #29]
#ifdef BLYNK_DEBUG
            if (size_t ram = BlynkFreeRam()) {
                BLYNK_LOG2(BLYNK_F("Free RAM: "), ram);
            }
#endif
            this->sendInfo();
 80a09f8:	4628      	mov	r0, r5
 80a09fa:	f000 faf3 	bl	80a0fe4 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE8sendInfoEv>
            BLYNK_RUN_YIELD();
 80a09fe:	f7ff fba7 	bl	80a0150 <_ZN10CloudClass7processEv>
            BlynkOnConnected();
 80a0a02:	f000 fbc1 	bl	80a1188 <BlynkNoOpCbk>
        }
        sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_SUCCESS);
 80a0a06:	2300      	movs	r3, #0
 80a0a08:	21c8      	movs	r1, #200	; 0xc8
 80a0a0a:	f8b7 200d 	ldrh.w	r2, [r7, #13]
 80a0a0e:	4628      	mov	r0, r5
 80a0a10:	9100      	str	r1, [sp, #0]
 80a0a12:	9302      	str	r3, [sp, #8]
 80a0a14:	9301      	str	r3, [sp, #4]
 80a0a16:	4619      	mov	r1, r3
 80a0a18:	f000 fa2a 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0a1c:	2001      	movs	r0, #1
            this->sendInfo();
            BLYNK_RUN_YIELD();
            BlynkOnConnected();
        }
        sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_SUCCESS);
    } break;
 80a0a1e:	e0c6      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    case BLYNK_CMD_PING: {
        sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_SUCCESS);
 80a0a20:	23c8      	movs	r3, #200	; 0xc8
 80a0a22:	f8b7 200d 	ldrh.w	r2, [r7, #13]
 80a0a26:	4628      	mov	r0, r5
 80a0a28:	9300      	str	r3, [sp, #0]
 80a0a2a:	9402      	str	r4, [sp, #8]
 80a0a2c:	9401      	str	r4, [sp, #4]
 80a0a2e:	4623      	mov	r3, r4
 80a0a30:	4621      	mov	r1, r4
 80a0a32:	f000 fa1d 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0a36:	2001      	movs	r0, #1
        }
        sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_SUCCESS);
    } break;
    case BLYNK_CMD_PING: {
        sendCmd(BLYNK_CMD_RESPONSE, hdr.msg_id, NULL, BLYNK_SUCCESS);
    } break;
 80a0a38:	e0b9      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    case BLYNK_CMD_REDIRECT: {
        if (!redir_serv) {
 80a0a3a:	68ab      	ldr	r3, [r5, #8]
 80a0a3c:	b91b      	cbnz	r3, 80a0a46 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x1da>
             redir_serv = (char*)malloc(32);
 80a0a3e:	2020      	movs	r0, #32
 80a0a40:	f001 ff48 	bl	80a28d4 <malloc>
 80a0a44:	60a8      	str	r0, [r5, #8]
    double      asDouble() const    { return atof(buff); }
    float       asFloat() const     { return atof(buff); }
#endif
    bool isEmpty() const            { return *buff == '\0'; }

    iterator begin() const { return iterator(buff, buff+len); }
 80a0a46:	f8b7 400f 	ldrh.w	r4, [r7, #15]
{
public:
    class iterator
    {
    public:
        iterator(const char* c, const char* l) : ptr(c), limit(l) {}
 80a0a4a:	61fe      	str	r6, [r7, #28]
    double      asDouble() const    { return atof(buff); }
    float       asFloat() const     { return atof(buff); }
#endif
    bool isEmpty() const            { return *buff == '\0'; }

    iterator begin() const { return iterator(buff, buff+len); }
 80a0a4c:	4434      	add	r4, r6
        }
        BlynkParam param(inputBuffer, hdr.length);
        uint16_t redir_port = BLYNK_DEFAULT_PORT; // TODO: Fixit

        BlynkParam::iterator it = param.begin();
        if (it >= param.end())
 80a0a4e:	42a6      	cmp	r6, r4
{
public:
    class iterator
    {
    public:
        iterator(const char* c, const char* l) : ptr(c), limit(l) {}
 80a0a50:	623c      	str	r4, [r7, #32]
 80a0a52:	d301      	bcc.n	80a0a58 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x1ec>
            return false;
 80a0a54:	2000      	movs	r0, #0
 80a0a56:	e0aa      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
        strncpy(redir_serv, it.asStr(), 32);
 80a0a58:	2220      	movs	r2, #32
 80a0a5a:	4631      	mov	r1, r6
 80a0a5c:	68a8      	ldr	r0, [r5, #8]
 80a0a5e:	f004 faee 	bl	80a503e <strncpy>
        if (++it < param.end())
 80a0a62:	f107 001c 	add.w	r0, r7, #28
 80a0a66:	f7ff fbe0 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a0a6a:	6803      	ldr	r3, [r0, #0]
 80a0a6c:	42a3      	cmp	r3, r4
 80a0a6e:	d208      	bcs.n	80a0a82 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x216>
        //long long   asLongLong() const  { return atoll(ptr); }
#ifndef BLYNK_NO_FLOAT
        double      asDouble() const    { if(!isValid()) return 0; return atof(ptr); }
        float       asFloat() const     { if(!isValid()) return 0; return atof(ptr); }
#endif
        bool isValid() const            { return ptr != NULL && ptr < limit; }
 80a0a70:	69f8      	ldr	r0, [r7, #28]
 80a0a72:	b120      	cbz	r0, 80a0a7e <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x212>
 80a0a74:	6a3b      	ldr	r3, [r7, #32]
 80a0a76:	4298      	cmp	r0, r3
 80a0a78:	f0c0 809d 	bcc.w	80a0bb6 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x34a>
        operator const char* () const   { return asStr(); }
        operator int () const           { return asInt(); }
        const char* asStr() const       { return ptr; }
        const char* asString() const    { return ptr; }
        int         asInt() const       { if(!isValid()) return 0; return atoi(ptr); }
        long        asLong() const      { if(!isValid()) return 0; return atol(ptr); }
 80a0a7c:	2000      	movs	r0, #0
            redir_port = it.asLong();
 80a0a7e:	b284      	uxth	r4, r0
 80a0a80:	e000      	b.n	80a0a84 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x218>
    case BLYNK_CMD_REDIRECT: {
        if (!redir_serv) {
             redir_serv = (char*)malloc(32);
        }
        BlynkParam param(inputBuffer, hdr.length);
        uint16_t redir_port = BLYNK_DEFAULT_PORT; // TODO: Fixit
 80a0a82:	2450      	movs	r4, #80	; 0x50
        if (it >= param.end())
            return false;
        strncpy(redir_serv, it.asStr(), 32);
        if (++it < param.end())
            redir_port = it.asLong();
        BLYNK_LOG4(BLYNK_F("Redirecting to "), redir_serv, ':', redir_port);
 80a0a84:	f7ff fb26 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0a88:	f003 febc 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0a8c:	4953      	ldr	r1, [pc, #332]	; (80a0bdc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x370>)
 80a0a8e:	f003 f9bd 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a0a92:	f003 feb7 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0a96:	68a9      	ldr	r1, [r5, #8]
 80a0a98:	f003 f9b8 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a0a9c:	f003 feb2 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0aa0:	213a      	movs	r1, #58	; 0x3a
 80a0aa2:	f003 f9b7 	bl	80a3e14 <_ZN5Print5printEc>
 80a0aa6:	f003 fead 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0aaa:	220a      	movs	r2, #10
 80a0aac:	4621      	mov	r1, r4
 80a0aae:	f003 fa22 	bl	80a3ef6 <_ZN5Print7printlnEii>
            return (1 == client.connect(addr, port));
        }
        return 0;
    }

    void disconnect() { client.stop(); }
 80a0ab2:	6828      	ldr	r0, [r5, #0]
 80a0ab4:	f003 fc98 	bl	80a43e8 <_ZN9TCPClient4stopEv>
        conn.disconnect();
        conn.begin(redir_serv, redir_port);
 80a0ab8:	682b      	ldr	r3, [r5, #0]
 80a0aba:	68aa      	ldr	r2, [r5, #8]
        addr = a;
    }

    void begin(const char* d, uint16_t p) {
        domain = d;
        port = p;
 80a0abc:	871c      	strh	r4, [r3, #56]	; 0x38
        port = p;
        addr = a;
    }

    void begin(const char* d, uint16_t p) {
        domain = d;
 80a0abe:	635a      	str	r2, [r3, #52]	; 0x34
        state = CONNECTING;
 80a0ac0:	2300      	movs	r3, #0
 80a0ac2:	776b      	strb	r3, [r5, #29]
        lastHeartbeat = lastActivityIn = lastActivityOut = (BlynkMillis() - 5000UL);
 80a0ac4:	f000 fb5a 	bl	80a117c <_Z11BlynkMillisv>
 80a0ac8:	f5a0 509c 	sub.w	r0, r0, #4992	; 0x1380
 80a0acc:	3808      	subs	r0, #8
 80a0ace:	6128      	str	r0, [r5, #16]
 80a0ad0:	60e8      	str	r0, [r5, #12]
 80a0ad2:	6168      	str	r0, [r5, #20]
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0ad4:	2001      	movs	r0, #1
        BLYNK_LOG4(BLYNK_F("Redirecting to "), redir_serv, ':', redir_port);
        conn.disconnect();
        conn.begin(redir_serv, redir_port);
        state = CONNECTING;
        lastHeartbeat = lastActivityIn = lastActivityOut = (BlynkMillis() - 5000UL);
    } break;
 80a0ad6:	e06a      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    case BLYNK_CMD_HARDWARE:
    case BLYNK_CMD_BRIDGE: {
        msgIdOutOverride = hdr.msg_id;
 80a0ad8:	68fb      	ldr	r3, [r7, #12]
        this->processCmd(inputBuffer, hdr.length);
 80a0ada:	4628      	mov	r0, r5
        state = CONNECTING;
        lastHeartbeat = lastActivityIn = lastActivityOut = (BlynkMillis() - 5000UL);
    } break;
    case BLYNK_CMD_HARDWARE:
    case BLYNK_CMD_BRIDGE: {
        msgIdOutOverride = hdr.msg_id;
 80a0adc:	f3c3 230f 	ubfx	r3, r3, #8, #16
 80a0ae0:	836b      	strh	r3, [r5, #26]
        this->processCmd(inputBuffer, hdr.length);
 80a0ae2:	f8b7 200f 	ldrh.w	r2, [r7, #15]
 80a0ae6:	4631      	mov	r1, r6
 80a0ae8:	f7ff fda4 	bl	80a0634 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE10processCmdEPKvj>
        msgIdOutOverride = 0;
 80a0aec:	2300      	movs	r3, #0
 80a0aee:	836b      	strh	r3, [r5, #26]
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0af0:	2001      	movs	r0, #1
    case BLYNK_CMD_HARDWARE:
    case BLYNK_CMD_BRIDGE: {
        msgIdOutOverride = hdr.msg_id;
        this->processCmd(inputBuffer, hdr.length);
        msgIdOutOverride = 0;
    } break;
 80a0af2:	e05c      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    double      asDouble() const    { return atof(buff); }
    float       asFloat() const     { return atof(buff); }
#endif
    bool isEmpty() const            { return *buff == '\0'; }

    iterator begin() const { return iterator(buff, buff+len); }
 80a0af4:	f8b7 300f 	ldrh.w	r3, [r7, #15]
    case BLYNK_CMD_INTERNAL: {
        BlynkReq req = { 0 };
 80a0af8:	713c      	strb	r4, [r7, #4]
 80a0afa:	4433      	add	r3, r6
        BlynkParam param(inputBuffer, hdr.length);
        BlynkParam::iterator it = param.begin();
        if (it >= param.end())
 80a0afc:	429e      	cmp	r6, r3
{
public:
    class iterator
    {
    public:
        iterator(const char* c, const char* l) : ptr(c), limit(l) {}
 80a0afe:	617e      	str	r6, [r7, #20]
 80a0b00:	61bb      	str	r3, [r7, #24]
 80a0b02:	d253      	bcs.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
            return true;

        uint32_t cmd32;
        memcpy(&cmd32, it.asStr(), sizeof(cmd32));
 80a0b04:	6830      	ldr	r0, [r6, #0]
 80a0b06:	60b8      	str	r0, [r7, #8]

        ++it;
 80a0b08:	f107 0014 	add.w	r0, r7, #20
 80a0b0c:	f7ff fb8d 	bl	80a022a <_ZN10BlynkParam8iteratorppEv>
 80a0b10:	697a      	ldr	r2, [r7, #20]
        char* start = (char*)(it).asStr();
        unsigned length = hdr.length - (start - (char*)inputBuffer);
 80a0b12:	f8b7 300f 	ldrh.w	r3, [r7, #15]
 80a0b16:	1b96      	subs	r6, r2, r6
 80a0b18:	1b9e      	subs	r6, r3, r6
    };

public:
    explicit
    BlynkParam(const void* addr, size_t length)
        : buff((char*)addr), len(length), buff_size(length)
 80a0b1a:	61fa      	str	r2, [r7, #28]
        BlynkParam param2(start, length);

        switch (cmd32) {
 80a0b1c:	68bb      	ldr	r3, [r7, #8]
 80a0b1e:	4a30      	ldr	r2, [pc, #192]	; (80a0be0 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x374>)
 80a0b20:	623e      	str	r6, [r7, #32]
 80a0b22:	4293      	cmp	r3, r2
 80a0b24:	627e      	str	r6, [r7, #36]	; 0x24
 80a0b26:	d01d      	beq.n	80a0b64 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x2f8>
 80a0b28:	d80b      	bhi.n	80a0b42 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x2d6>
 80a0b2a:	f102 32fd 	add.w	r2, r2, #4261281277	; 0xfdfdfdfd
 80a0b2e:	f102 2202 	add.w	r2, r2, #33554944	; 0x2000200
 80a0b32:	4293      	cmp	r3, r2
 80a0b34:	d13a      	bne.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        case BLYNK_INT_RTC:  BlynkWidgetWriteInternalPinRTC(req, param2);    break;
        case BLYNK_INT_OTA:  BlynkWidgetWriteInternalPinOTA(req, param2);    break;
 80a0b36:	f107 011c 	add.w	r1, r7, #28
 80a0b3a:	1d38      	adds	r0, r7, #4
 80a0b3c:	f000 fb23 	bl	80a1186 <BlynkWidgetWrite>
 80a0b40:	e034      	b.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        ++it;
        char* start = (char*)(it).asStr();
        unsigned length = hdr.length - (start - (char*)inputBuffer);
        BlynkParam param2(start, length);

        switch (cmd32) {
 80a0b42:	4a28      	ldr	r2, [pc, #160]	; (80a0be4 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x378>)
 80a0b44:	4293      	cmp	r3, r2
 80a0b46:	d013      	beq.n	80a0b70 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x304>
 80a0b48:	f102 629f 	add.w	r2, r2, #83361792	; 0x4f80000
 80a0b4c:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
 80a0b50:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80a0b54:	4293      	cmp	r3, r2
 80a0b56:	d129      	bne.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        case BLYNK_INT_RTC:  BlynkWidgetWriteInternalPinRTC(req, param2);    break;
        case BLYNK_INT_OTA:  BlynkWidgetWriteInternalPinOTA(req, param2);    break;
        case BLYNK_INT_ACON: BlynkWidgetWriteInternalPinACON(req, param2);   break;
        case BLYNK_INT_ADIS: BlynkWidgetWriteInternalPinADIS(req, param2);   break;
 80a0b58:	f107 011c 	add.w	r1, r7, #28
 80a0b5c:	1d38      	adds	r0, r7, #4
 80a0b5e:	f000 fb12 	bl	80a1186 <BlynkWidgetWrite>
 80a0b62:	e023      	b.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        char* start = (char*)(it).asStr();
        unsigned length = hdr.length - (start - (char*)inputBuffer);
        BlynkParam param2(start, length);

        switch (cmd32) {
        case BLYNK_INT_RTC:  BlynkWidgetWriteInternalPinRTC(req, param2);    break;
 80a0b64:	f107 011c 	add.w	r1, r7, #28
 80a0b68:	1d38      	adds	r0, r7, #4
 80a0b6a:	f000 fb0c 	bl	80a1186 <BlynkWidgetWrite>
 80a0b6e:	e01d      	b.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        case BLYNK_INT_OTA:  BlynkWidgetWriteInternalPinOTA(req, param2);    break;
        case BLYNK_INT_ACON: BlynkWidgetWriteInternalPinACON(req, param2);   break;
 80a0b70:	f107 011c 	add.w	r1, r7, #28
 80a0b74:	1d38      	adds	r0, r7, #4
 80a0b76:	f000 fb06 	bl	80a1186 <BlynkWidgetWrite>
 80a0b7a:	e017      	b.n	80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
        default:             BLYNK_LOG2(BLYNK_F("Invalid internal cmd:"), param.asStr());
#endif
        }
    } break;
    case BLYNK_CMD_DEBUG_PRINT: {
        if (hdr.length) {
 80a0b7c:	f8b7 300f 	ldrh.w	r3, [r7, #15]
 80a0b80:	b1a3      	cbz	r3, 80a0bac <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x340>
            BLYNK_LOG2(BLYNK_F("Server: "), (char*)inputBuffer);
 80a0b82:	f7ff faa7 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0b86:	f003 fe3d 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0b8a:	4917      	ldr	r1, [pc, #92]	; (80a0be8 <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x37c>)
 80a0b8c:	f003 f93e 	bl	80a3e0c <_ZN5Print5printEPKc>
 80a0b90:	f003 fe38 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0b94:	4631      	mov	r1, r6
 80a0b96:	f003 f94c 	bl	80a3e32 <_ZN5Print7printlnEPKc>
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0b9a:	2001      	movs	r0, #1
 80a0b9c:	e007      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    default: {
#ifdef BLYNK_DEBUG
        BLYNK_LOG2(BLYNK_F("Invalid header type: "), hdr.type);
#endif
        // TODO: Flush
        internalReconnect();
 80a0b9e:	4628      	mov	r0, r5
 80a0ba0:	f7ff fcdd 	bl	80a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>
    } break;
    }

    return true;
 80a0ba4:	2001      	movs	r0, #1
#ifdef BLYNK_DEBUG
        BLYNK_LOG2(BLYNK_F("Invalid header type: "), hdr.type);
#endif
        // TODO: Flush
        internalReconnect();
    } break;
 80a0ba6:	e002      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
    uint8_t inputBuffer[hdr.length+1]; // Add 1 to zero-terminate
    if (hdr.length != conn.read(inputBuffer, hdr.length)) {
#ifdef BLYNK_DEBUG
        BLYNK_LOG1(BLYNK_F("Can't read body"));
#endif
        return false;
 80a0ba8:	4620      	mov	r0, r4
 80a0baa:	e000      	b.n	80a0bae <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x342>
        // TODO: Flush
        internalReconnect();
    } break;
    }

    return true;
 80a0bac:	2001      	movs	r0, #1
 80a0bae:	46c5      	mov	sp, r8
 80a0bb0:	e004      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
{
    BlynkHeader hdr;
    const int ret = readHeader(hdr);

    if (ret == 0) {
        return true; // Considered OK (no data on input)
 80a0bb2:	2001      	movs	r0, #1
 80a0bb4:	e002      	b.n	80a0bbc <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x350>
        operator const char* () const   { return asStr(); }
        operator int () const           { return asInt(); }
        const char* asStr() const       { return ptr; }
        const char* asString() const    { return ptr; }
        int         asInt() const       { if(!isValid()) return 0; return atoi(ptr); }
        long        asLong() const      { if(!isValid()) return 0; return atol(ptr); }
 80a0bb6:	f004 f99b 	bl	80a4ef0 <atol>
 80a0bba:	e760      	b.n	80a0a7e <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv+0x212>
        internalReconnect();
    } break;
    }

    return true;
}
 80a0bbc:	3728      	adds	r7, #40	; 0x28
 80a0bbe:	46bd      	mov	sp, r7
 80a0bc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0bc4:	080a52ff 	.word	0x080a52ff
 80a0bc8:	080a530d 	.word	0x080a530d
 80a0bcc:	080a5312 	.word	0x080a5312
 80a0bd0:	080a5325 	.word	0x080a5325
 80a0bd4:	080a533c 	.word	0x080a533c
 80a0bd8:	080a534d 	.word	0x080a534d
 80a0bdc:	080a5353 	.word	0x080a5353
 80a0be0:	00637472 	.word	0x00637472
 80a0be4:	6e6f6361 	.word	0x6e6f6361
 80a0be8:	080a5363 	.word	0x080a5363

080a0bec <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb>:
protected:
    BlynkState state;
};

template <class Transp>
bool BlynkProtocol<Transp>::run(bool avail)
 80a0bec:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a0bf0:	4604      	mov	r4, r0
 80a0bf2:	460d      	mov	r5, r1
{
    BLYNK_RUN_YIELD();
 80a0bf4:	f7ff faac 	bl	80a0150 <_ZN10CloudClass7processEv>

    if (state == DISCONNECTED) {
 80a0bf8:	7f63      	ldrb	r3, [r4, #29]
 80a0bfa:	2b02      	cmp	r3, #2
 80a0bfc:	f000 808a 	beq.w	80a0d14 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x128>
      avg -= 1;
}

class BlynkHelperAutoInc {
public:
    BlynkHelperAutoInc(uint8_t& counter) : c(counter) { ++c; }
 80a0c00:	7f23      	ldrb	r3, [r4, #28]
        return false;
    }

    // Detect nesting
    BlynkHelperAutoInc guard(nesting);
    if (msgIdOutOverride || nesting > 2) {
 80a0c02:	8b62      	ldrh	r2, [r4, #26]
 80a0c04:	3301      	adds	r3, #1
 80a0c06:	b2db      	uxtb	r3, r3
 80a0c08:	7723      	strb	r3, [r4, #28]
 80a0c0a:	2a00      	cmp	r2, #0
 80a0c0c:	d147      	bne.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
 80a0c0e:	2b02      	cmp	r3, #2
 80a0c10:	d845      	bhi.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
    size_t write(const void* buf, size_t len) {
        return client.write((const uint8_t*)buf, len);
    }

    void flush() { client.flush(); }
    bool connected() { return client.connected(); }
 80a0c12:	6820      	ldr	r0, [r4, #0]
 80a0c14:	f003 fcec 	bl	80a45f0 <_ZN9TCPClient9connectedEv>
      //BLYNK_LOG1(BLYNK_F("Nested run() skipped"));
      return true;
    }

    if (conn.connected()) {
 80a0c18:	b130      	cbz	r0, 80a0c28 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x3c>
        while (avail || conn.available() > 0) {
 80a0c1a:	2d00      	cmp	r5, #0
 80a0c1c:	d17c      	bne.n	80a0d18 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x12c>
    int available() { return client.available(); }
 80a0c1e:	6820      	ldr	r0, [r4, #0]
 80a0c20:	f003 fba4 	bl	80a436c <_ZN9TCPClient9availableEv>
 80a0c24:	2800      	cmp	r0, #0
 80a0c26:	dc77      	bgt.n	80a0d18 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x12c>
            avail = false;
            //BLYNK_LOG2(BLYNK_F("Proc time: "), micros() - t);
        }
    }

    const millis_time_t t = BlynkMillis();
 80a0c28:	f000 faa8 	bl	80a117c <_Z11BlynkMillisv>
 80a0c2c:	4607      	mov	r7, r0
    size_t write(const void* buf, size_t len) {
        return client.write((const uint8_t*)buf, len);
    }

    void flush() { client.flush(); }
    bool connected() { return client.connected(); }
 80a0c2e:	6820      	ldr	r0, [r4, #0]
 80a0c30:	f003 fcde 	bl	80a45f0 <_ZN9TCPClient9connectedEv>

    // Update connection status after running commands
    const bool tconn = conn.connected();

    if (state == CONNECTED) {
 80a0c34:	7f65      	ldrb	r5, [r4, #29]
 80a0c36:	4606      	mov	r6, r0
 80a0c38:	2d01      	cmp	r5, #1
 80a0c3a:	d132      	bne.n	80a0ca2 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb6>
        if (!tconn) {
 80a0c3c:	b928      	cbnz	r0, 80a0c4a <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x5e>
            lastHeartbeat = t;
 80a0c3e:	6167      	str	r7, [r4, #20]
            internalReconnect();
 80a0c40:	4620      	mov	r0, r4
 80a0c42:	f7ff fc8c 	bl	80a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>
            return false;
 80a0c46:	4635      	mov	r5, r6
 80a0c48:	e060      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
        }

        if (t - lastActivityIn > (1000UL * BLYNK_HEARTBEAT + BLYNK_TIMEOUT_MS*3)) {
 80a0c4a:	f644 2238 	movw	r2, #19000	; 0x4a38
 80a0c4e:	68e3      	ldr	r3, [r4, #12]
 80a0c50:	1afb      	subs	r3, r7, r3
 80a0c52:	4293      	cmp	r3, r2
 80a0c54:	d90b      	bls.n	80a0c6e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x82>
#ifdef BLYNK_DEBUG
            BLYNK_LOG6(BLYNK_F("Heartbeat timeout: "), t, BLYNK_F(", "), lastActivityIn, BLYNK_F(", "), lastHeartbeat);
#else
            BLYNK_LOG1(BLYNK_F("Heartbeat timeout"));
 80a0c56:	f7ff fa3d 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0c5a:	f003 fdd3 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0c5e:	4937      	ldr	r1, [pc, #220]	; (80a0d3c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x150>)
 80a0c60:	f003 f8e7 	bl	80a3e32 <_ZN5Print7printlnEPKc>
#endif
            internalReconnect();
 80a0c64:	4620      	mov	r0, r4
 80a0c66:	f7ff fc7a 	bl	80a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>
            return false;
 80a0c6a:	2500      	movs	r5, #0
 80a0c6c:	e04e      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
        } else if ((t - lastActivityIn  > 1000UL * BLYNK_HEARTBEAT ||
 80a0c6e:	f242 7210 	movw	r2, #10000	; 0x2710
 80a0c72:	4293      	cmp	r3, r2
 80a0c74:	d803      	bhi.n	80a0c7e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x92>
 80a0c76:	6923      	ldr	r3, [r4, #16]
 80a0c78:	1afb      	subs	r3, r7, r3
 80a0c7a:	4293      	cmp	r3, r2
 80a0c7c:	d90f      	bls.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
 80a0c7e:	f640 32b8 	movw	r2, #3000	; 0xbb8
 80a0c82:	6963      	ldr	r3, [r4, #20]
 80a0c84:	1afb      	subs	r3, r7, r3
 80a0c86:	4293      	cmp	r3, r2
 80a0c88:	d909      	bls.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
                    t - lastActivityOut > 1000UL * BLYNK_HEARTBEAT) &&
                    t - lastHeartbeat   > BLYNK_TIMEOUT_MS)
        {
            // Send ping if we didn't either send or receive something
            // for BLYNK_HEARTBEAT seconds
            sendCmd(BLYNK_CMD_PING);
 80a0c8a:	2300      	movs	r3, #0
 80a0c8c:	9302      	str	r3, [sp, #8]
 80a0c8e:	9301      	str	r3, [sp, #4]
 80a0c90:	9300      	str	r3, [sp, #0]
 80a0c92:	461a      	mov	r2, r3
 80a0c94:	2106      	movs	r1, #6
 80a0c96:	4620      	mov	r0, r4
 80a0c98:	f000 f8ea 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
            lastHeartbeat = t;
 80a0c9c:	6167      	str	r7, [r4, #20]
            lastLogin = lastActivityOut;
            return true;
        }
#endif
    }
    return true;
 80a0c9e:	2501      	movs	r5, #1
 80a0ca0:	e034      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
            // Send ping if we didn't either send or receive something
            // for BLYNK_HEARTBEAT seconds
            sendCmd(BLYNK_CMD_PING);
            lastHeartbeat = t;
        }
    } else if (state == CONNECTING) {
 80a0ca2:	2d00      	cmp	r5, #0
 80a0ca4:	d1fb      	bne.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
 80a0ca6:	6960      	ldr	r0, [r4, #20]
#ifdef BLYNK_USE_DIRECT_CONNECT
        if (!tconn)
            conn.connect();
#else
        if (tconn && (t - lastLogin > BLYNK_TIMEOUT_MS)) {
 80a0ca8:	1a38      	subs	r0, r7, r0
 80a0caa:	b17e      	cbz	r6, 80a0ccc <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xe0>
 80a0cac:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80a0cb0:	4298      	cmp	r0, r3
 80a0cb2:	d9f4      	bls.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
            BLYNK_LOG1(BLYNK_F("Login timeout"));
 80a0cb4:	f7ff fa0e 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0cb8:	f003 fda4 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0cbc:	4920      	ldr	r1, [pc, #128]	; (80a0d40 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x154>)
 80a0cbe:	f003 f8b8 	bl	80a3e32 <_ZN5Print7printlnEPKc>
            return (1 == client.connect(addr, port));
        }
        return 0;
    }

    void disconnect() { client.stop(); }
 80a0cc2:	6820      	ldr	r0, [r4, #0]
 80a0cc4:	f003 fb90 	bl	80a43e8 <_ZN9TCPClient4stopEv>
            conn.disconnect();
            state = CONNECTING;
 80a0cc8:	7765      	strb	r5, [r4, #29]
            return false;
 80a0cca:	e01f      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
        } else if (!tconn && (t - lastLogin > 5000UL)) {
 80a0ccc:	f241 3388 	movw	r3, #5000	; 0x1388
 80a0cd0:	4298      	cmp	r0, r3
 80a0cd2:	d9e4      	bls.n	80a0c9e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xb2>
 80a0cd4:	6820      	ldr	r0, [r4, #0]
 80a0cd6:	f003 fb87 	bl	80a43e8 <_ZN9TCPClient4stopEv>
            conn.disconnect();
            if (!conn.connect()) {
 80a0cda:	6820      	ldr	r0, [r4, #0]
 80a0cdc:	f7ff faf4 	bl	80a02c8 <_ZN22BlynkTransportParticle7connectEv>
 80a0ce0:	4605      	mov	r5, r0
 80a0ce2:	b908      	cbnz	r0, 80a0ce8 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0xfc>
                lastLogin = t;
 80a0ce4:	6167      	str	r7, [r4, #20]
                return false;
 80a0ce6:	e011      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
            }

            msgIdOut = 1;
            sendCmd(BLYNK_CMD_LOGIN, 1, authkey, strlen(authkey));
 80a0ce8:	f8d4 8004 	ldr.w	r8, [r4, #4]
            if (!conn.connect()) {
                lastLogin = t;
                return false;
            }

            msgIdOut = 1;
 80a0cec:	2701      	movs	r7, #1
 80a0cee:	8327      	strh	r7, [r4, #24]
            sendCmd(BLYNK_CMD_LOGIN, 1, authkey, strlen(authkey));
 80a0cf0:	4640      	mov	r0, r8
 80a0cf2:	f004 f987 	bl	80a5004 <strlen>
 80a0cf6:	4643      	mov	r3, r8
 80a0cf8:	e88d 0041 	stmia.w	sp, {r0, r6}
 80a0cfc:	9602      	str	r6, [sp, #8]
 80a0cfe:	463a      	mov	r2, r7
 80a0d00:	2102      	movs	r1, #2
 80a0d02:	4620      	mov	r0, r4
 80a0d04:	f000 f8b4 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
            lastLogin = lastActivityOut;
 80a0d08:	6923      	ldr	r3, [r4, #16]
 80a0d0a:	6163      	str	r3, [r4, #20]
    ~BlynkHelperAutoInc() { --c; }
 80a0d0c:	7f23      	ldrb	r3, [r4, #28]
 80a0d0e:	3b01      	subs	r3, #1
 80a0d10:	7723      	strb	r3, [r4, #28]
 80a0d12:	e00e      	b.n	80a0d32 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x146>
bool BlynkProtocol<Transp>::run(bool avail)
{
    BLYNK_RUN_YIELD();

    if (state == DISCONNECTED) {
        return false;
 80a0d14:	2500      	movs	r5, #0
 80a0d16:	e00c      	b.n	80a0d32 <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x146>

    if (conn.connected()) {
        while (avail || conn.available() > 0) {
            //BLYNK_LOG2(BLYNK_F("Available: "), conn.available());
            //const unsigned long t = micros();
            if (!processInput()) {
 80a0d18:	4620      	mov	r0, r4
 80a0d1a:	f7ff fda7 	bl	80a086c <_ZN13BlynkProtocolI22BlynkTransportParticleE12processInputEv>
 80a0d1e:	4605      	mov	r5, r0
 80a0d20:	2800      	cmp	r0, #0
 80a0d22:	f47f af7c 	bne.w	80a0c1e <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x32>
 80a0d26:	6820      	ldr	r0, [r4, #0]
 80a0d28:	f003 fb5e 	bl	80a43e8 <_ZN9TCPClient4stopEv>
                conn.disconnect();
// TODO: Only when in direct mode?
#ifdef BLYNK_USE_DIRECT_CONNECT
                state = CONNECTING;
#endif
                BlynkOnDisconnected();
 80a0d2c:	f000 fa2c 	bl	80a1188 <BlynkNoOpCbk>
                return false;
 80a0d30:	e7ec      	b.n	80a0d0c <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb+0x120>
            return true;
        }
#endif
    }
    return true;
}
 80a0d32:	4628      	mov	r0, r5
 80a0d34:	b004      	add	sp, #16
 80a0d36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0d3a:	bf00      	nop
 80a0d3c:	080a536c 	.word	0x080a536c
 80a0d40:	080a537e 	.word	0x080a537e

080a0d44 <setup>:
}

SYSTEM_MODE(AUTOMATIC);

// setup() runs once, when the device is first turned on.
void setup() {
 80a0d44:	b5f0      	push	{r4, r5, r6, r7, lr}

    // Use primary serial over USB interface for logging output, not serial
    //Serial.begin(9600);
    Log.info("Starting setup."); 
 80a0d46:	493d      	ldr	r1, [pc, #244]	; (80a0e3c <setup+0xf8>)
}

SYSTEM_MODE(AUTOMATIC);

// setup() runs once, when the device is first turned on.
void setup() {
 80a0d48:	b095      	sub	sp, #84	; 0x54

    // Use primary serial over USB interface for logging output, not serial
    //Serial.begin(9600);
    Log.info("Starting setup."); 
 80a0d4a:	483d      	ldr	r0, [pc, #244]	; (80a0e40 <setup+0xfc>)
 80a0d4c:	f7ff fa35 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>

    bool setCredentials(const char *ssid, unsigned int ssidLen, const char *password,
            unsigned int passwordLen, unsigned long security=WLAN_SEC_UNSEC, unsigned long cipher=WLAN_CIPHER_NOT_SET) {

        WLanCredentials creds;
        memset(&creds, 0, sizeof(creds));
 80a0d50:	244c      	movs	r4, #76	; 0x4c
    
    // Put initialization like pinMode and begin functions here.
    // set up pinmodes for the 3 mosfets
    // set up handling of iphone app
    delay(5000); // Allow board to settle
 80a0d52:	f241 3088 	movw	r0, #5000	; 0x1388
 80a0d56:	f001 fde5 	bl	80a2924 <delay>
 80a0d5a:	4622      	mov	r2, r4
 80a0d5c:	2100      	movs	r1, #0
 80a0d5e:	a801      	add	r0, sp, #4
 80a0d60:	f004 f8fe 	bl	80a4f60 <memset>
        creds.size = sizeof(creds);
        creds.ssid = ssid;
 80a0d64:	4b37      	ldr	r3, [pc, #220]	; (80a0e44 <setup+0x100>)
        creds.ssid_len = ssidLen;
        creds.password = password;
        creds.password_len = passwordLen;
        creds.security = WLanSecurityType(security);
        creds.cipher = WLanSecurityCipher(cipher);
        return (network_set_credentials(*this, 0, &creds, NULL) == 0);
 80a0d66:	aa01      	add	r2, sp, #4
            unsigned int passwordLen, unsigned long security=WLAN_SEC_UNSEC, unsigned long cipher=WLAN_CIPHER_NOT_SET) {

        WLanCredentials creds;
        memset(&creds, 0, sizeof(creds));
        creds.size = sizeof(creds);
        creds.ssid = ssid;
 80a0d68:	9302      	str	r3, [sp, #8]
        creds.ssid_len = ssidLen;
 80a0d6a:	230a      	movs	r3, #10
 80a0d6c:	9303      	str	r3, [sp, #12]
        creds.password = password;
 80a0d6e:	4b36      	ldr	r3, [pc, #216]	; (80a0e48 <setup+0x104>)
    bool setCredentials(const char *ssid, unsigned int ssidLen, const char *password,
            unsigned int passwordLen, unsigned long security=WLAN_SEC_UNSEC, unsigned long cipher=WLAN_CIPHER_NOT_SET) {

        WLanCredentials creds;
        memset(&creds, 0, sizeof(creds));
        creds.size = sizeof(creds);
 80a0d70:	9401      	str	r4, [sp, #4]
        creds.ssid = ssid;
        creds.ssid_len = ssidLen;
        creds.password = password;
 80a0d72:	9304      	str	r3, [sp, #16]
        creds.password_len = passwordLen;
 80a0d74:	230c      	movs	r3, #12
 80a0d76:	9305      	str	r3, [sp, #20]
        creds.security = WLanSecurityType(security);
 80a0d78:	2303      	movs	r3, #3
 80a0d7a:	f88d 3018 	strb.w	r3, [sp, #24]
        creds.cipher = WLanSecurityCipher(cipher);
        return (network_set_credentials(*this, 0, &creds, NULL) == 0);
 80a0d7e:	2300      	movs	r3, #0
 80a0d80:	4619      	mov	r1, r3
 80a0d82:	4618      	mov	r0, r3
 80a0d84:	f001 fd9e 	bl	80a28c4 <network_set_credentials>
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
 80a0d88:	f001 fd7c 	bl	80a2884 <spark_cloud_flag_connect>
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a0d8c:	2200      	movs	r2, #0
 80a0d8e:	4611      	mov	r1, r2
 80a0d90:	4610      	mov	r0, r2
 80a0d92:	f001 fd8f 	bl	80a28b4 <network_ready>

    // wifi
    WiFi.setCredentials("ATT6GW55sY", "4cgp3w4uik42");
    Particle.connect();         // connects wifi and particle cloud
    if( WiFi.ready() )
 80a0d96:	b120      	cbz	r0, 80a0da2 <setup+0x5e>
    {
        Log.info("WiFi ready."); 
 80a0d98:	492c      	ldr	r1, [pc, #176]	; (80a0e4c <setup+0x108>)
 80a0d9a:	4829      	ldr	r0, [pc, #164]	; (80a0e40 <setup+0xfc>)
 80a0d9c:	f7ff fa0d 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
 80a0da0:	e003      	b.n	80a0daa <setup+0x66>
    } else {
        Log.warn("WiFi setup failed.");
 80a0da2:	492b      	ldr	r1, [pc, #172]	; (80a0e50 <setup+0x10c>)
 80a0da4:	4826      	ldr	r0, [pc, #152]	; (80a0e40 <setup+0xfc>)
 80a0da6:	f7ff fa1f 	bl	80a01e8 <_ZNK5spark6Logger4warnEPKcz>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a0daa:	f001 fd73 	bl	80a2894 <spark_cloud_flag_connected>
    }
    
    if( Particle.connected() )
 80a0dae:	b120      	cbz	r0, 80a0dba <setup+0x76>
    {
        Log.info("Particle connected to CLOUD."); 
 80a0db0:	4928      	ldr	r1, [pc, #160]	; (80a0e54 <setup+0x110>)
 80a0db2:	4823      	ldr	r0, [pc, #140]	; (80a0e40 <setup+0xfc>)
 80a0db4:	f7ff fa01 	bl	80a01ba <_ZNK5spark6Logger4infoEPKcz>
 80a0db8:	e003      	b.n	80a0dc2 <setup+0x7e>
    } else {
        Log.warn("Particle not connected to CLOUD.");
 80a0dba:	4927      	ldr	r1, [pc, #156]	; (80a0e58 <setup+0x114>)
 80a0dbc:	4820      	ldr	r0, [pc, #128]	; (80a0e40 <setup+0xfc>)
 80a0dbe:	f7ff fa13 	bl	80a01e8 <_ZNK5spark6Logger4warnEPKcz>

    void begin( const char* auth,
                const char* domain = BLYNK_DEFAULT_DOMAIN,
                uint16_t port      = BLYNK_DEFAULT_PORT)
    {
        BlynkDelay(3000); // Give the board time to settle
 80a0dc2:	f640 30b8 	movw	r0, #3000	; 0xbb8
 80a0dc6:	f000 f9d7 	bl	80a1178 <_Z10BlynkDelaym>
    int readHeader(BlynkHeader& hdr);
    uint16_t getNextMsgId();

protected:
    void begin(const char* auth) {
        this->authkey = auth;
 80a0dca:	4c24      	ldr	r4, [pc, #144]	; (80a0e5c <setup+0x118>)
 80a0dcc:	4b24      	ldr	r3, [pc, #144]	; (80a0e60 <setup+0x11c>)

    bool connect(uint32_t timeout = BLYNK_TIMEOUT_MS*3) {
        conn.disconnect();
        state = CONNECTING;
        millis_time_t started = BlynkMillis();
        while ((state != CONNECTED) &&
 80a0dce:	f242 3627 	movw	r6, #8999	; 0x2327
    int readHeader(BlynkHeader& hdr);
    uint16_t getNextMsgId();

protected:
    void begin(const char* auth) {
        this->authkey = auth;
 80a0dd2:	6063      	str	r3, [r4, #4]
        lastHeartbeat = lastActivityIn = lastActivityOut = (BlynkMillis() - 5000UL);
 80a0dd4:	f000 f9d2 	bl	80a117c <_Z11BlynkMillisv>
 80a0dd8:	f5a0 509c 	sub.w	r0, r0, #4992	; 0x1380
 80a0ddc:	3808      	subs	r0, #8
 80a0dde:	6120      	str	r0, [r4, #16]
 80a0de0:	60e0      	str	r0, [r4, #12]
 80a0de2:	6160      	str	r0, [r4, #20]

    void printBanner() {
#if defined(BLYNK_NO_FANCY_LOGO)
        BLYNK_LOG1(BLYNK_F("Blynk v" BLYNK_VERSION " on " BLYNK_INFO_DEVICE));
#else
        BLYNK_LOG1(BLYNK_F(BLYNK_NEWLINE
 80a0de4:	f7ff f976 	bl	80a00d4 <_ZL14BLYNK_LOG_TIMEv>
 80a0de8:	f003 fd0c 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a0dec:	491d      	ldr	r1, [pc, #116]	; (80a0e64 <setup+0x120>)
 80a0dee:	f003 f820 	bl	80a3e32 <_ZN5Print7printlnEPKc>
    void config(const char* auth,
                const char* domain = BLYNK_DEFAULT_DOMAIN,
                uint16_t port      = BLYNK_DEFAULT_PORT)
    {
        Base::begin(auth);
        this->conn.begin(domain, port);
 80a0df2:	6823      	ldr	r3, [r4, #0]
        port = p;
        addr = a;
    }

    void begin(const char* d, uint16_t p) {
        domain = d;
 80a0df4:	4a1c      	ldr	r2, [pc, #112]	; (80a0e68 <setup+0x124>)

    bool connected() { return state == CONNECTED; }

    bool connect(uint32_t timeout = BLYNK_TIMEOUT_MS*3) {
        conn.disconnect();
        state = CONNECTING;
 80a0df6:	2500      	movs	r5, #0
 80a0df8:	635a      	str	r2, [r3, #52]	; 0x34
        port = p;
 80a0dfa:	2250      	movs	r2, #80	; 0x50
 80a0dfc:	871a      	strh	r2, [r3, #56]	; 0x38
            return (1 == client.connect(addr, port));
        }
        return 0;
    }

    void disconnect() { client.stop(); }
 80a0dfe:	6820      	ldr	r0, [r4, #0]
 80a0e00:	f003 faf2 	bl	80a43e8 <_ZN9TCPClient4stopEv>
 80a0e04:	7765      	strb	r5, [r4, #29]
        millis_time_t started = BlynkMillis();
 80a0e06:	f000 f9b9 	bl	80a117c <_Z11BlynkMillisv>
 80a0e0a:	4607      	mov	r7, r0
        while ((state != CONNECTED) &&
 80a0e0c:	7f63      	ldrb	r3, [r4, #29]
 80a0e0e:	2b01      	cmp	r3, #1
 80a0e10:	d009      	beq.n	80a0e26 <setup+0xe2>
               (BlynkMillis() - started < timeout))
 80a0e12:	f000 f9b3 	bl	80a117c <_Z11BlynkMillisv>

    bool connect(uint32_t timeout = BLYNK_TIMEOUT_MS*3) {
        conn.disconnect();
        state = CONNECTING;
        millis_time_t started = BlynkMillis();
        while ((state != CONNECTED) &&
 80a0e16:	1bc0      	subs	r0, r0, r7
 80a0e18:	42b0      	cmp	r0, r6
 80a0e1a:	d804      	bhi.n	80a0e26 <setup+0xe2>
               (BlynkMillis() - started < timeout))
        {
            run();
 80a0e1c:	2100      	movs	r1, #0
 80a0e1e:	480f      	ldr	r0, [pc, #60]	; (80a0e5c <setup+0x118>)
 80a0e20:	f7ff fee4 	bl	80a0bec <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb>
 80a0e24:	e7f2      	b.n	80a0e0c <setup+0xc8>
                const char* domain = BLYNK_DEFAULT_DOMAIN,
                uint16_t port      = BLYNK_DEFAULT_PORT)
    {
        BlynkDelay(3000); // Give the board time to settle
        config(auth, domain, port);
        while(this->connect() != true) {}
 80a0e26:	7f63      	ldrb	r3, [r4, #29]
 80a0e28:	2b01      	cmp	r3, #1
 80a0e2a:	d1e8      	bne.n	80a0dfe <setup+0xba>
    }

    Blynk.begin(auth);

    // initialize strip to be dark
    strip.begin();
 80a0e2c:	480f      	ldr	r0, [pc, #60]	; (80a0e6c <setup+0x128>)
 80a0e2e:	f000 f9f1 	bl	80a1214 <_ZN17Adafruit_NeoPixel5beginEv>
    strip.show();
 80a0e32:	480e      	ldr	r0, [pc, #56]	; (80a0e6c <setup+0x128>)
 80a0e34:	f000 fa24 	bl	80a1280 <_ZN17Adafruit_NeoPixel4showEv>
}
 80a0e38:	b015      	add	sp, #84	; 0x54
 80a0e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0e3c:	080a538c 	.word	0x080a538c
 80a0e40:	200004a0 	.word	0x200004a0
 80a0e44:	080a539c 	.word	0x080a539c
 80a0e48:	080a53a7 	.word	0x080a53a7
 80a0e4c:	080a53b4 	.word	0x080a53b4
 80a0e50:	080a53c0 	.word	0x080a53c0
 80a0e54:	080a53d3 	.word	0x080a53d3
 80a0e58:	080a53f0 	.word	0x080a53f0
 80a0e5c:	200003dc 	.word	0x200003dc
 80a0e60:	20000305 	.word	0x20000305
 80a0e64:	080a5411 	.word	0x080a5411
 80a0e68:	080a54a6 	.word	0x080a54a6
 80a0e6c:	200003c8 	.word	0x200003c8

080a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>:
#ifndef BLYNK_SEND_CHUNK
#define BLYNK_SEND_CHUNK 1024 // Just a big number
#endif

template <class Transp>
void BlynkProtocol<Transp>::sendCmd(uint8_t cmd, uint16_t id, const void* data, size_t length, const void* data2, size_t length2)
 80a0e70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a0e74:	b083      	sub	sp, #12
 80a0e76:	4604      	mov	r4, r0
 80a0e78:	af00      	add	r7, sp, #0
    size_t write(const void* buf, size_t len) {
        return client.write((const uint8_t*)buf, len);
    }

    void flush() { client.flush(); }
    bool connected() { return client.connected(); }
 80a0e7a:	6800      	ldr	r0, [r0, #0]
 80a0e7c:	4689      	mov	r9, r1
 80a0e7e:	4616      	mov	r6, r2
 80a0e80:	469b      	mov	fp, r3
 80a0e82:	6b3d      	ldr	r5, [r7, #48]	; 0x30
#endif
        internalReconnect();
        return;
    }

    lastActivityOut = BlynkMillis();
 80a0e84:	46ea      	mov	sl, sp
 80a0e86:	f003 fbb3 	bl	80a45f0 <_ZN9TCPClient9connectedEv>
#endif

template <class Transp>
void BlynkProtocol<Transp>::sendCmd(uint8_t cmd, uint16_t id, const void* data, size_t length, const void* data2, size_t length2)
{
    if (!conn.connected() || (cmd != BLYNK_CMD_RESPONSE && cmd != BLYNK_CMD_PING && cmd != BLYNK_CMD_LOGIN && state != CONNECTED) ) {
 80a0e8a:	2800      	cmp	r0, #0
 80a0e8c:	d061      	beq.n	80a0f52 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xe2>
 80a0e8e:	f019 0ffd 	tst.w	r9, #253	; 0xfd
 80a0e92:	f000 809f 	beq.w	80a0fd4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x164>
 80a0e96:	f1b9 0f06 	cmp.w	r9, #6
 80a0e9a:	f000 809b 	beq.w	80a0fd4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x164>
 80a0e9e:	7f63      	ldrb	r3, [r4, #29]
 80a0ea0:	2b01      	cmp	r3, #1
 80a0ea2:	d156      	bne.n	80a0f52 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xe2>
        BLYNK_LOG2(BLYNK_F("Cmd skipped:"), cmd);
#endif
        return;
    }

    if (0 == id) {
 80a0ea4:	b916      	cbnz	r6, 80a0eac <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x3c>
}

template <class Transp>
uint16_t BlynkProtocol<Transp>::getNextMsgId()
{
    if (msgIdOutOverride != 0)
 80a0ea6:	8b66      	ldrh	r6, [r4, #26]
 80a0ea8:	2e00      	cmp	r6, #0
 80a0eaa:	d054      	beq.n	80a0f56 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xe6>
    if (0 == id) {
        id = getNextMsgId();
    }

#if defined(BLYNK_MSG_LIMIT) && BLYNK_MSG_LIMIT > 0
    if (cmd >= BLYNK_CMD_TWEET && cmd <= BLYNK_CMD_HARDWARE) {
 80a0eac:	f1a9 030c 	sub.w	r3, r9, #12
 80a0eb0:	2b08      	cmp	r3, #8
 80a0eb2:	d958      	bls.n	80a0f66 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xf6>
    }
#endif

    const size_t full_length = (sizeof(BlynkHeader)) +
                               (data  ? length  : 0) +
                               (data2 ? length2 : 0);
 80a0eb4:	f1bb 0f00 	cmp.w	fp, #0
 80a0eb8:	bf18      	it	ne
 80a0eba:	46a8      	movne	r8, r5
 80a0ebc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80a0ebe:	bf08      	it	eq
 80a0ec0:	f04f 0800 	moveq.w	r8, #0
 80a0ec4:	2a00      	cmp	r2, #0
 80a0ec6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80a0ec8:	f108 0305 	add.w	r3, r8, #5
 80a0ecc:	bf14      	ite	ne
 80a0ece:	4690      	movne	r8, r2
 80a0ed0:	f04f 0800 	moveq.w	r8, #0
 80a0ed4:	4498      	add	r8, r3

#if defined(BLYNK_SEND_ATOMIC) || defined(ESP8266) || defined(ESP32) || defined(SPARK) || defined(PARTICLE) || defined(ENERGIA)
    // Those have more RAM and like single write at a time...

    uint8_t buff[full_length];
 80a0ed6:	f108 0307 	add.w	r3, r8, #7
 80a0eda:	f023 0307 	bic.w	r3, r3, #7

    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
    hdr->msg_id = htons(id);
    hdr->length = htons(length+length2);
 80a0ede:	18aa      	adds	r2, r5, r2
                               (data2 ? length2 : 0);

#if defined(BLYNK_SEND_ATOMIC) || defined(ESP8266) || defined(ESP32) || defined(SPARK) || defined(PARTICLE) || defined(ENERGIA)
    // Those have more RAM and like single write at a time...

    uint8_t buff[full_length];
 80a0ee0:	ebad 0d03 	sub.w	sp, sp, r3

    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
    hdr->msg_id = htons(id);
    hdr->length = htons(length+length2);
 80a0ee4:	f3c2 2307 	ubfx	r3, r2, #8, #8

    uint8_t buff[full_length];

    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
    hdr->msg_id = htons(id);
 80a0ee8:	ba76      	rev16	r6, r6
    hdr->length = htons(length+length2);
 80a0eea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                               (data2 ? length2 : 0);

#if defined(BLYNK_SEND_ATOMIC) || defined(ESP8266) || defined(ESP32) || defined(SPARK) || defined(PARTICLE) || defined(ENERGIA)
    // Those have more RAM and like single write at a time...

    uint8_t buff[full_length];
 80a0eee:	f8c7 d004 	str.w	sp, [r7, #4]

    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
 80a0ef2:	f88d 9000 	strb.w	r9, [sp]
    hdr->msg_id = htons(id);
 80a0ef6:	f8ad 6001 	strh.w	r6, [sp, #1]
    hdr->length = htons(length+length2);
 80a0efa:	f8ad 3003 	strh.w	r3, [sp, #3]

    size_t pos = sizeof(BlynkHeader);
    if (data && length) {
 80a0efe:	f1bb 0f00 	cmp.w	fp, #0
 80a0f02:	d04f      	beq.n	80a0fa4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x134>
 80a0f04:	2d00      	cmp	r5, #0
 80a0f06:	d04d      	beq.n	80a0fa4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x134>
        memcpy(buff + pos, data, length);
 80a0f08:	462a      	mov	r2, r5
 80a0f0a:	4659      	mov	r1, fp
 80a0f0c:	f10d 0005 	add.w	r0, sp, #5
 80a0f10:	f004 f800 	bl	80a4f14 <memcpy>
        pos += length;
 80a0f14:	1d68      	adds	r0, r5, #5
    }
    if (data2 && length2) {
 80a0f16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80a0f18:	2b00      	cmp	r3, #0
 80a0f1a:	d145      	bne.n	80a0fa8 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x138>
    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
    hdr->msg_id = htons(id);
    hdr->length = htons(length+length2);

    size_t pos = sizeof(BlynkHeader);
 80a0f1c:	2500      	movs	r5, #0
    if (data2 && length2) {
        memcpy(buff + pos, data2, length2);
    }

    size_t wlen = 0;
    while (wlen < full_length) {
 80a0f1e:	4545      	cmp	r5, r8
 80a0f20:	d24e      	bcs.n	80a0fc0 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x150>
        const size_t chunk = BlynkMin(size_t(BLYNK_SEND_CHUNK), full_length - wlen);
 80a0f22:	ebc5 0208 	rsb	r2, r5, r8
    size_t read(void* buf, size_t len) {
        return client.readBytes((char*)buf, len);
    }

    size_t write(const void* buf, size_t len) {
        return client.write((const uint8_t*)buf, len);
 80a0f26:	687b      	ldr	r3, [r7, #4]
 80a0f28:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80a0f2c:	bf28      	it	cs
 80a0f2e:	f44f 6280 	movcs.w	r2, #1024	; 0x400
 80a0f32:	1959      	adds	r1, r3, r5
 80a0f34:	6820      	ldr	r0, [r4, #0]
 80a0f36:	f003 f932 	bl	80a419e <_ZN9TCPClient5writeEPKhj>
 80a0f3a:	4606      	mov	r6, r0
        BLYNK_DBG_DUMP("<", buff + wlen, chunk);
        const size_t w = conn.write(buff + wlen, chunk);
        BlynkDelay(BLYNK_SEND_THROTTLE);
 80a0f3c:	2000      	movs	r0, #0
 80a0f3e:	f000 f91b 	bl	80a1178 <_Z10BlynkDelaym>
        if (w == 0) {
 80a0f42:	2e00      	cmp	r6, #0
 80a0f44:	d13a      	bne.n	80a0fbc <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x14c>
            return (1 == client.connect(addr, port));
        }
        return 0;
    }

    void disconnect() { client.stop(); }
 80a0f46:	6820      	ldr	r0, [r4, #0]
 80a0f48:	f003 fa4e 	bl	80a43e8 <_ZN9TCPClient4stopEv>
#ifdef BLYNK_DEBUG
            BLYNK_LOG1(BLYNK_F("Cmd error"));
#endif
            conn.disconnect();
            state = CONNECTING;
 80a0f4c:	7766      	strb	r6, [r4, #29]
            BlynkOnDisconnected();
 80a0f4e:	f000 f91b 	bl	80a1188 <BlynkNoOpCbk>
{
    if (!conn.connected() || (cmd != BLYNK_CMD_RESPONSE && cmd != BLYNK_CMD_PING && cmd != BLYNK_CMD_LOGIN && state != CONNECTED) ) {
#ifdef BLYNK_DEBUG_ALL
        BLYNK_LOG2(BLYNK_F("Cmd skipped:"), cmd);
#endif
        return;
 80a0f52:	46d5      	mov	sp, sl
 80a0f54:	e042      	b.n	80a0fdc <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x16c>
template <class Transp>
uint16_t BlynkProtocol<Transp>::getNextMsgId()
{
    if (msgIdOutOverride != 0)
        return msgIdOutOverride;
    if (++msgIdOut == 0)
 80a0f56:	8b23      	ldrh	r3, [r4, #24]
 80a0f58:	3301      	adds	r3, #1
 80a0f5a:	b29b      	uxth	r3, r3
 80a0f5c:	b903      	cbnz	r3, 80a0f60 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xf0>
        msgIdOut = 1;
 80a0f5e:	2301      	movs	r3, #1
 80a0f60:	8323      	strh	r3, [r4, #24]
    return msgIdOut;
 80a0f62:	8b26      	ldrh	r6, [r4, #24]
 80a0f64:	e7a2      	b.n	80a0eac <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x3c>
        id = getNextMsgId();
    }

#if defined(BLYNK_MSG_LIMIT) && BLYNK_MSG_LIMIT > 0
    if (cmd >= BLYNK_CMD_TWEET && cmd <= BLYNK_CMD_HARDWARE) {
        const millis_time_t allowed_time = BlynkMax(lastActivityOut, lastActivityIn) + 1000/BLYNK_MSG_LIMIT;
 80a0f66:	68e3      	ldr	r3, [r4, #12]
 80a0f68:	6922      	ldr	r2, [r4, #16]
 80a0f6a:	4293      	cmp	r3, r2
 80a0f6c:	bf38      	it	cc
 80a0f6e:	4613      	movcc	r3, r2
 80a0f70:	f103 0842 	add.w	r8, r3, #66	; 0x42
        int32_t wait_time = allowed_time - BlynkMillis();
 80a0f74:	f000 f902 	bl	80a117c <_Z11BlynkMillisv>
        if (wait_time >= 0) {
 80a0f78:	ebc0 0008 	rsb	r0, r0, r8
 80a0f7c:	2800      	cmp	r0, #0
 80a0f7e:	db0a      	blt.n	80a0f96 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x126>
#ifdef BLYNK_DEBUG_ALL
            BLYNK_LOG2(BLYNK_F("Waiting:"), wait_time);
#endif
            while (wait_time >= 0) {
                run();
 80a0f80:	2100      	movs	r1, #0
 80a0f82:	4620      	mov	r0, r4
 80a0f84:	f7ff fe32 	bl	80a0bec <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb>
                wait_time = allowed_time - BlynkMillis();
 80a0f88:	f000 f8f8 	bl	80a117c <_Z11BlynkMillisv>
        int32_t wait_time = allowed_time - BlynkMillis();
        if (wait_time >= 0) {
#ifdef BLYNK_DEBUG_ALL
            BLYNK_LOG2(BLYNK_F("Waiting:"), wait_time);
#endif
            while (wait_time >= 0) {
 80a0f8c:	ebc0 0008 	rsb	r0, r0, r8
 80a0f90:	2800      	cmp	r0, #0
 80a0f92:	daf5      	bge.n	80a0f80 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x110>
 80a0f94:	e78e      	b.n	80a0eb4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x44>
                run();
                wait_time = allowed_time - BlynkMillis();
            }
        } else if (nesting == 0) {
 80a0f96:	7f21      	ldrb	r1, [r4, #28]
 80a0f98:	2900      	cmp	r1, #0
 80a0f9a:	d18b      	bne.n	80a0eb4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x44>
            run();
 80a0f9c:	4620      	mov	r0, r4
 80a0f9e:	f7ff fe25 	bl	80a0bec <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb>
 80a0fa2:	e787      	b.n	80a0eb4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x44>
    BlynkHeader* hdr = (BlynkHeader*)buff;
    hdr->type = cmd;
    hdr->msg_id = htons(id);
    hdr->length = htons(length+length2);

    size_t pos = sizeof(BlynkHeader);
 80a0fa4:	2005      	movs	r0, #5
 80a0fa6:	e7b6      	b.n	80a0f16 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xa6>
    if (data && length) {
        memcpy(buff + pos, data, length);
        pos += length;
    }
    if (data2 && length2) {
 80a0fa8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80a0faa:	2b00      	cmp	r3, #0
 80a0fac:	d0b6      	beq.n	80a0f1c <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xac>
        memcpy(buff + pos, data2, length2);
 80a0fae:	461a      	mov	r2, r3
 80a0fb0:	687b      	ldr	r3, [r7, #4]
 80a0fb2:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80a0fb4:	4418      	add	r0, r3
 80a0fb6:	f003 ffad 	bl	80a4f14 <memcpy>
 80a0fba:	e7af      	b.n	80a0f1c <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xac>
            conn.disconnect();
            state = CONNECTING;
            BlynkOnDisconnected();
            return;
        }
        wlen += w;
 80a0fbc:	4435      	add	r5, r6
    if (data2 && length2) {
        memcpy(buff + pos, data2, length2);
    }

    size_t wlen = 0;
    while (wlen < full_length) {
 80a0fbe:	e7ae      	b.n	80a0f1e <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xae>
        }
    }

#endif

    if (wlen != full_length) {
 80a0fc0:	d003      	beq.n	80a0fca <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x15a>
#ifdef BLYNK_DEBUG
        BLYNK_LOG4(BLYNK_F("Sent "), wlen, '/', full_length);
#endif
        internalReconnect();
 80a0fc2:	4620      	mov	r0, r4
 80a0fc4:	f7ff facb 	bl	80a055e <_ZN13BlynkProtocolI22BlynkTransportParticleE17internalReconnectEv>
        return;
 80a0fc8:	e7c3      	b.n	80a0f52 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0xe2>
    }

    lastActivityOut = BlynkMillis();
 80a0fca:	f000 f8d7 	bl	80a117c <_Z11BlynkMillisv>
 80a0fce:	6120      	str	r0, [r4, #16]
 80a0fd0:	46d5      	mov	sp, sl
 80a0fd2:	e003      	b.n	80a0fdc <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x16c>
        BLYNK_LOG2(BLYNK_F("Cmd skipped:"), cmd);
#endif
        return;
    }

    if (0 == id) {
 80a0fd4:	2e00      	cmp	r6, #0
 80a0fd6:	f47f af6d 	bne.w	80a0eb4 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x44>
 80a0fda:	e764      	b.n	80a0ea6 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j+0x36>
        return;
    }

    lastActivityOut = BlynkMillis();

}
 80a0fdc:	370c      	adds	r7, #12
 80a0fde:	46bd      	mov	sp, r7
 80a0fe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a0fe4 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE8sendInfoEv>:

#else

template<class Proto>
BLYNK_FORCE_INLINE
void BlynkApi<Proto>::sendInfo()
 80a0fe4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
#ifdef BLYNK_HAS_PROGMEM
    char mem[profile_len];
    memcpy_P(mem, profile+8, profile_len);
    static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_INTERNAL, 0, mem, profile_len);
#else
    static_cast<Proto*>(this)->sendCmd(BLYNK_CMD_INTERNAL, 0, profile+8, profile_len);
 80a0fe6:	2200      	movs	r2, #0
 80a0fe8:	2350      	movs	r3, #80	; 0x50
 80a0fea:	9300      	str	r3, [sp, #0]
 80a0fec:	9202      	str	r2, [sp, #8]
 80a0fee:	9201      	str	r2, [sp, #4]
 80a0ff0:	4b03      	ldr	r3, [pc, #12]	; (80a1000 <_ZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE8sendInfoEv+0x1c>)
 80a0ff2:	2111      	movs	r1, #17
 80a0ff4:	f7ff ff3c 	bl	80a0e70 <_ZN13BlynkProtocolI22BlynkTransportParticleE7sendCmdEhtPKvjS3_j>
#endif
    return;
}
 80a0ff8:	b005      	add	sp, #20
 80a0ffa:	f85d fb04 	ldr.w	pc, [sp], #4
 80a0ffe:	bf00      	nop
 80a1000:	080a51f8 	.word	0x080a51f8

080a1004 <loop>:

void loop() {
 80a1004:	b508      	push	{r3, lr}
    Blynk.run();
 80a1006:	2100      	movs	r1, #0
 80a1008:	4805      	ldr	r0, [pc, #20]	; (80a1020 <loop+0x1c>)
 80a100a:	f7ff fdef 	bl	80a0bec <_ZN13BlynkProtocolI22BlynkTransportParticleE3runEb>
    if(blynkUpdateReady){
 80a100e:	4b05      	ldr	r3, [pc, #20]	; (80a1024 <loop+0x20>)
 80a1010:	781b      	ldrb	r3, [r3, #0]
 80a1012:	b11b      	cbz	r3, 80a101c <loop+0x18>
        setColor();  
    }
}
 80a1014:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void loop() {
    Blynk.run();
    if(blynkUpdateReady){
        setColor();  
 80a1018:	f7ff ba5e 	b.w	80a04d8 <_Z8setColorv>
 80a101c:	bd08      	pop	{r3, pc}
 80a101e:	bf00      	nop
 80a1020:	200003dc 	.word	0x200003dc
 80a1024:	20000304 	.word	0x20000304

080a1028 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz>:
    }
}
 80a1028:	b570      	push	{r4, r5, r6, lr}

class BlynkTransportParticle
{
public:
    BlynkTransportParticle()
        : domain(NULL), port(0)
 80a102a:	4d44      	ldr	r5, [pc, #272]	; (80a113c <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x114>)
 80a102c:	b08c      	sub	sp, #48	; 0x30
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a102e:	f001 fa63 	bl	80a24f8 <HAL_Pin_Map>
 80a1032:	4628      	mov	r0, r5
 80a1034:	f003 fa2a 	bl	80a448c <_ZN9TCPClientC1Ev>
 80a1038:	f105 001c 	add.w	r0, r5, #28
 80a103c:	2400      	movs	r4, #0
 80a103e:	f001 fcfb 	bl	80a2a38 <_ZN9IPAddressC1Ev>
#ifndef BlynkSimpleParticle_h
#define BlynkSimpleParticle_h

#include "BlynkParticle.h"

static BlynkTransportParticle _blynkTransport;
 80a1042:	4a3f      	ldr	r2, [pc, #252]	; (80a1140 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x118>)
 80a1044:	493f      	ldr	r1, [pc, #252]	; (80a1144 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x11c>)
 80a1046:	4628      	mov	r0, r5
 80a1048:	636c      	str	r4, [r5, #52]	; 0x34
 80a104a:	872c      	strh	r4, [r5, #56]	; 0x38
 80a104c:	f003 fde6 	bl	80a4c1c <__aeabi_atexit>
        , lastActivityOut(0)
        , lastHeartbeat(0)
        , msgIdOut(0)
        , msgIdOutOverride(0)
        , nesting(0)
        , state(CONNECTING)
 80a1050:	4b3d      	ldr	r3, [pc, #244]	; (80a1148 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x120>)
// IMPORTANT: Set pixel COUNT, PIN and TYPE
#define PIXEL_PIN D2
#define PIXEL_COUNT 60
#define PIXEL_TYPE WS2812B

Adafruit_NeoPixel strip(PIXEL_COUNT, PIXEL_PIN, PIXEL_TYPE);
 80a1052:	213c      	movs	r1, #60	; 0x3c
 80a1054:	601d      	str	r5, [r3, #0]
 80a1056:	605c      	str	r4, [r3, #4]
 80a1058:	609c      	str	r4, [r3, #8]
 80a105a:	60dc      	str	r4, [r3, #12]
 80a105c:	611c      	str	r4, [r3, #16]
 80a105e:	615c      	str	r4, [r3, #20]
 80a1060:	831c      	strh	r4, [r3, #24]
 80a1062:	835c      	strh	r4, [r3, #26]
 80a1064:	771c      	strb	r4, [r3, #28]
 80a1066:	775c      	strb	r4, [r3, #29]
 80a1068:	2302      	movs	r3, #2
 80a106a:	461a      	mov	r2, r3
 80a106c:	4837      	ldr	r0, [pc, #220]	; (80a114c <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x124>)
 80a106e:	f000 f8f6 	bl	80a125e <_ZN17Adafruit_NeoPixelC1Ethh>
 80a1072:	4a33      	ldr	r2, [pc, #204]	; (80a1140 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x118>)
 80a1074:	4936      	ldr	r1, [pc, #216]	; (80a1150 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x128>)
 80a1076:	4835      	ldr	r0, [pc, #212]	; (80a114c <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x124>)
 80a1078:	f003 fdd0 	bl	80a4c1c <__aeabi_atexit>

volatile struct RGB color;
volatile struct RGB last_color;
volatile struct RGB windowColor; 
volatile int mode = 1;
String alarmTime; 
 80a107c:	4935      	ldr	r1, [pc, #212]	; (80a1154 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x12c>)
 80a107e:	4836      	ldr	r0, [pc, #216]	; (80a1158 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x130>)
 80a1080:	f003 f832 	bl	80a40e8 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1084:	4a2e      	ldr	r2, [pc, #184]	; (80a1140 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x118>)
 80a1086:	4935      	ldr	r1, [pc, #212]	; (80a115c <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x134>)
 80a1088:	4833      	ldr	r0, [pc, #204]	; (80a1158 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x130>)
 80a108a:	f003 fdc7 	bl	80a4c1c <__aeabi_atexit>
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a108e:	9400      	str	r4, [sp, #0]
 80a1090:	9401      	str	r4, [sp, #4]
 80a1092:	9402      	str	r4, [sp, #8]
namespace spark {

class SerialLogHandler: public StreamLogHandler {
public:
    explicit SerialLogHandler(LogLevel level = LOG_LEVEL_INFO, LogCategoryFilters filters = {}) :
            StreamLogHandler(Serial, level, filters) {
 80a1094:	f003 fbb6 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a1098:	4606      	mov	r6, r0
 80a109a:	4669      	mov	r1, sp
 80a109c:	a803      	add	r0, sp, #12
 80a109e:	f7ff fa96 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a10a2:	a903      	add	r1, sp, #12
 80a10a4:	a806      	add	r0, sp, #24
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
        filter_(level, filters) {
 80a10a6:	4d2e      	ldr	r5, [pc, #184]	; (80a1160 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x138>)
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a10a8:	f7ff fa91 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
        filter_(level, filters) {
 80a10ac:	4b2d      	ldr	r3, [pc, #180]	; (80a1164 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x13c>)
 80a10ae:	a906      	add	r1, sp, #24
 80a10b0:	602b      	str	r3, [r5, #0]
 80a10b2:	a809      	add	r0, sp, #36	; 0x24
 80a10b4:	f7ff fa8b 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a10b8:	aa09      	add	r2, sp, #36	; 0x24
 80a10ba:	211e      	movs	r1, #30
 80a10bc:	1d28      	adds	r0, r5, #4
 80a10be:	f002 fcec 	bl	80a3a9a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a10c2:	a809      	add	r0, sp, #36	; 0x24
 80a10c4:	f7ff fa38 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a10c8:	a806      	add	r0, sp, #24
 80a10ca:	f7ff fa35 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a10ce:	4b26      	ldr	r3, [pc, #152]	; (80a1168 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x140>)
 80a10d0:	622e      	str	r6, [r5, #32]
 80a10d2:	602b      	str	r3, [r5, #0]
 80a10d4:	a803      	add	r0, sp, #12
 80a10d6:	f7ff fa2f 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a10da:	4b24      	ldr	r3, [pc, #144]	; (80a116c <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x144>)
 80a10dc:	602b      	str	r3, [r5, #0]
        Serial.begin();
 80a10de:	f003 fb91 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a10e2:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a10e6:	f003 fb6f 	bl	80a47c8 <_ZN9USBSerial5beginEl>
        LogManager::instance()->addHandler(this);
 80a10ea:	f002 f975 	bl	80a33d8 <_ZN5spark10LogManager8instanceEv>
 80a10ee:	4629      	mov	r1, r5
 80a10f0:	f002 fc67 	bl	80a39c2 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>

// You should get Auth Token in the Blynk App.
// Go to the Project Settings (nut icon).
char auth[] = "19e91bbb75a24afe9895491df395c67d";

SerialLogHandler logHandler;
 80a10f4:	4668      	mov	r0, sp
 80a10f6:	f7ff fa1f 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a10fa:	4a11      	ldr	r2, [pc, #68]	; (80a1140 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x118>)
 80a10fc:	491c      	ldr	r1, [pc, #112]	; (80a1170 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x148>)
 80a10fe:	4628      	mov	r0, r5
 80a1100:	f003 fd8c 	bl	80a4c1c <__aeabi_atexit>
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a1104:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a1108:	4d1a      	ldr	r5, [pc, #104]	; (80a1174 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x14c>)

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a110a:	2001      	movs	r0, #1
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a110c:	806b      	strh	r3, [r5, #2]
 80a110e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80a1112:	702c      	strb	r4, [r5, #0]
 80a1114:	80ab      	strh	r3, [r5, #4]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1116:	f001 fb89 	bl	80a282c <set_system_mode>
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a111a:	4622      	mov	r2, r4
 80a111c:	4621      	mov	r1, r4
 80a111e:	a809      	add	r0, sp, #36	; 0x24
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a1120:	9409      	str	r4, [sp, #36]	; 0x24
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a1122:	f001 f9c1 	bl	80a24a8 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a1126:	9b09      	ldr	r3, [sp, #36]	; 0x24
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a1128:	2b1e      	cmp	r3, #30
 80a112a:	d104      	bne.n	80a1136 <_GLOBAL__sub_I__Z15blynk_dbg_printPKcz+0x10e>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a112c:	2303      	movs	r3, #3
 80a112e:	702b      	strb	r3, [r5, #0]
 80a1130:	2311      	movs	r3, #17
 80a1132:	806c      	strh	r4, [r5, #2]
 80a1134:	80ab      	strh	r3, [r5, #4]
void loop() {
    Blynk.run();
    if(blynkUpdateReady){
        setColor();  
    }
}
 80a1136:	b00c      	add	sp, #48	; 0x30
 80a1138:	bd70      	pop	{r4, r5, r6, pc}
 80a113a:	bf00      	nop
 80a113c:	200003fc 	.word	0x200003fc
 80a1140:	2000039c 	.word	0x2000039c
 80a1144:	080a019d 	.word	0x080a019d
 80a1148:	200003dc 	.word	0x200003dc
 80a114c:	200003c8 	.word	0x200003c8
 80a1150:	080a11c1 	.word	0x080a11c1
 80a1154:	080a54a5 	.word	0x080a54a5
 80a1158:	200003a0 	.word	0x200003a0
 80a115c:	080a405b 	.word	0x080a405b
 80a1160:	20000438 	.word	0x20000438
 80a1164:	080a51c8 	.word	0x080a51c8
 80a1168:	080a5a54 	.word	0x080a5a54
 80a116c:	080a51e0 	.word	0x080a51e0
 80a1170:	080a0109 	.word	0x080a0109
 80a1174:	200003b0 	.word	0x200003b0

080a1178 <_Z10BlynkDelaym>:
#endif

#ifdef _BLYNK_USE_DEFAULT_DELAY
    void BlynkDelay(millis_time_t ms)
    {
        return delay(ms);
 80a1178:	f001 bbd4 	b.w	80a2924 <delay>

080a117c <_Z11BlynkMillisv>:
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a117c:	f001 b9b4 	b.w	80a24e8 <HAL_Timer_Get_Milli_Seconds>

080a1180 <_GLOBAL__sub_I__Z10BlynkResetv>:
 80a1180:	f001 b9ba 	b.w	80a24f8 <HAL_Pin_Map>

080a1184 <BlynkWidgetRead>:

void BlynkNoOpCbk()
{}

void BlynkWidgetRead(BlynkReq BLYNK_UNUSED &request)
{
 80a1184:	4770      	bx	lr

080a1186 <BlynkWidgetWrite>:
    BLYNK_LOG2(BLYNK_F("No handler for reading from pin "), request.pin);
}

void BlynkWidgetWrite(BlynkReq BLYNK_UNUSED &request, const BlynkParam BLYNK_UNUSED &param)
{
 80a1186:	4770      	bx	lr

080a1188 <BlynkNoOpCbk>:
#include <Blynk/BlynkConfig.h>
#include <Blynk/BlynkHandlers.h>
#include <Blynk/BlynkDebug.h>

void BlynkNoOpCbk()
{}
 80a1188:	4770      	bx	lr
	...

080a118c <GetReadHandler>:
#endif
};

WidgetReadHandler GetReadHandler(uint8_t pin)
{
    if (pin >= BLYNK_COUNT_OF(BlynkReadHandlerVector))
 80a118c:	287f      	cmp	r0, #127	; 0x7f
        return NULL;
#ifdef BLYNK_HAS_PROGMEM
    return (WidgetReadHandler)pgm_read_word(&BlynkReadHandlerVector[pin]);
#else
    return BlynkReadHandlerVector[pin];
 80a118e:	bf9a      	itte	ls
 80a1190:	4b02      	ldrls	r3, [pc, #8]	; (80a119c <GetReadHandler+0x10>)
 80a1192:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
};

WidgetReadHandler GetReadHandler(uint8_t pin)
{
    if (pin >= BLYNK_COUNT_OF(BlynkReadHandlerVector))
        return NULL;
 80a1196:	2000      	movhi	r0, #0
#ifdef BLYNK_HAS_PROGMEM
    return (WidgetReadHandler)pgm_read_word(&BlynkReadHandlerVector[pin]);
#else
    return BlynkReadHandlerVector[pin];
#endif
}
 80a1198:	4770      	bx	lr
 80a119a:	bf00      	nop
 80a119c:	080a56b8 	.word	0x080a56b8

080a11a0 <GetWriteHandler>:

WidgetWriteHandler GetWriteHandler(uint8_t pin)
{
    if (pin >= BLYNK_COUNT_OF(BlynkWriteHandlerVector))
 80a11a0:	287f      	cmp	r0, #127	; 0x7f
        return NULL;
#ifdef BLYNK_HAS_PROGMEM
    return (WidgetWriteHandler)pgm_read_word(&BlynkWriteHandlerVector[pin]);
#else
    return BlynkWriteHandlerVector[pin];
 80a11a2:	bf9a      	itte	ls
 80a11a4:	4b02      	ldrls	r3, [pc, #8]	; (80a11b0 <GetWriteHandler+0x10>)
 80a11a6:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
}

WidgetWriteHandler GetWriteHandler(uint8_t pin)
{
    if (pin >= BLYNK_COUNT_OF(BlynkWriteHandlerVector))
        return NULL;
 80a11aa:	2000      	movhi	r0, #0
#ifdef BLYNK_HAS_PROGMEM
    return (WidgetWriteHandler)pgm_read_word(&BlynkWriteHandlerVector[pin]);
#else
    return BlynkWriteHandlerVector[pin];
#endif
}
 80a11ac:	4770      	bx	lr
 80a11ae:	bf00      	nop
 80a11b0:	080a54b8 	.word	0x080a54b8

080a11b4 <_GLOBAL__sub_I_BlynkNoOpCbk>:
 80a11b4:	f001 b9a0 	b.w	80a24f8 <HAL_Pin_Map>

080a11b8 <_GLOBAL__sub_I__ZN10BlynkTimerC2Ev>:
 80a11b8:	f001 b99e 	b.w	80a24f8 <HAL_Pin_Map>

080a11bc <micros>:
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a11bc:	f001 b98c 	b.w	80a24d8 <HAL_Timer_Get_Micro_Seconds>

080a11c0 <_ZN17Adafruit_NeoPixelD1Ev>:
{
  updateLength(n);
  setPin(p);
}

Adafruit_NeoPixel::~Adafruit_NeoPixel() {
 80a11c0:	b510      	push	{r4, lr}
 80a11c2:	4604      	mov	r4, r0
  if (pixels) free(pixels);
 80a11c4:	68c0      	ldr	r0, [r0, #12]
 80a11c6:	b108      	cbz	r0, 80a11cc <_ZN17Adafruit_NeoPixelD1Ev+0xc>
 80a11c8:	f001 fb8c 	bl	80a28e4 <free>
  if (begun) pinMode(pin, INPUT);
 80a11cc:	7823      	ldrb	r3, [r4, #0]
 80a11ce:	b11b      	cbz	r3, 80a11d8 <_ZN17Adafruit_NeoPixelD1Ev+0x18>
 80a11d0:	2100      	movs	r1, #0
 80a11d2:	79e0      	ldrb	r0, [r4, #7]
 80a11d4:	f003 fc4e 	bl	80a4a74 <pinMode>
}
 80a11d8:	4620      	mov	r0, r4
 80a11da:	bd10      	pop	{r4, pc}

080a11dc <_ZN17Adafruit_NeoPixel12updateLengthEt>:

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a11dc:	b538      	push	{r3, r4, r5, lr}
 80a11de:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a11e0:	68c0      	ldr	r0, [r0, #12]
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a11e2:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a11e4:	b108      	cbz	r0, 80a11ea <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a11e6:	f001 fb7d 	bl	80a28e4 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a11ea:	79a3      	ldrb	r3, [r4, #6]
 80a11ec:	2b06      	cmp	r3, #6
 80a11ee:	bf0c      	ite	eq
 80a11f0:	2004      	moveq	r0, #4
 80a11f2:	2003      	movne	r0, #3
 80a11f4:	4368      	muls	r0, r5
 80a11f6:	b280      	uxth	r0, r0
 80a11f8:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a11fa:	f001 fb6b 	bl	80a28d4 <malloc>
 80a11fe:	60e0      	str	r0, [r4, #12]
 80a1200:	b128      	cbz	r0, 80a120e <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a1202:	88a2      	ldrh	r2, [r4, #4]
 80a1204:	2100      	movs	r1, #0
 80a1206:	f003 feab 	bl	80a4f60 <memset>
    numLEDs = n;
 80a120a:	8065      	strh	r5, [r4, #2]
 80a120c:	bd38      	pop	{r3, r4, r5, pc}
  } else {
    numLEDs = numBytes = 0;
 80a120e:	80a0      	strh	r0, [r4, #4]
 80a1210:	8060      	strh	r0, [r4, #2]
 80a1212:	bd38      	pop	{r3, r4, r5, pc}

080a1214 <_ZN17Adafruit_NeoPixel5beginEv>:
  }
}

void Adafruit_NeoPixel::begin(void) {
 80a1214:	b510      	push	{r4, lr}
 80a1216:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a1218:	2101      	movs	r1, #1
 80a121a:	79c0      	ldrb	r0, [r0, #7]
 80a121c:	f003 fc2a 	bl	80a4a74 <pinMode>
  digitalWrite(pin, LOW);
 80a1220:	2100      	movs	r1, #0
 80a1222:	79e0      	ldrb	r0, [r4, #7]
 80a1224:	f003 fc37 	bl	80a4a96 <digitalWrite>
  begun = true;
 80a1228:	2301      	movs	r3, #1
 80a122a:	7023      	strb	r3, [r4, #0]
 80a122c:	bd10      	pop	{r4, pc}

080a122e <_ZN17Adafruit_NeoPixel6setPinEh>:
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a122e:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a1230:	7803      	ldrb	r3, [r0, #0]
  digitalWrite(pin, LOW);
  begun = true;
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a1232:	4605      	mov	r5, r0
 80a1234:	460c      	mov	r4, r1
    if (begun) {
 80a1236:	b11b      	cbz	r3, 80a1240 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a1238:	2100      	movs	r1, #0
 80a123a:	79c0      	ldrb	r0, [r0, #7]
 80a123c:	f003 fc1a 	bl	80a4a74 <pinMode>
    }
    pin = p;
    if (begun) {
 80a1240:	782b      	ldrb	r3, [r5, #0]
// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    if (begun) {
        pinMode(pin, INPUT);
    }
    pin = p;
 80a1242:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a1244:	b153      	cbz	r3, 80a125c <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a1246:	b2a4      	uxth	r4, r4
 80a1248:	4620      	mov	r0, r4
 80a124a:	2101      	movs	r1, #1
 80a124c:	f003 fc12 	bl	80a4a74 <pinMode>
        digitalWrite(p, LOW);
 80a1250:	4620      	mov	r0, r4
    }
}
 80a1252:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pinMode(pin, INPUT);
    }
    pin = p;
    if (begun) {
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
 80a1256:	2100      	movs	r1, #0
 80a1258:	f003 bc1d 	b.w	80a4a96 <digitalWrite>
 80a125c:	bd38      	pop	{r3, r4, r5, pc}

080a125e <_ZN17Adafruit_NeoPixelC1Ethh>:
  #error "*** PLATFORM_ID not supported by this library. PLATFORM should be Particle Core, Photon, Electron, Argon, Boron, Xenon and RedBear Duo ***"
#endif
// fast pin access
#define pinSet(_pin, _hilo) (_hilo ? pinHI(_pin) : pinLO(_pin))

Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a125e:	b570      	push	{r4, r5, r6, lr}
 80a1260:	4604      	mov	r4, r0
 80a1262:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a1264:	2500      	movs	r5, #0
 80a1266:	7183      	strb	r3, [r0, #6]
 80a1268:	7005      	strb	r5, [r0, #0]
 80a126a:	7205      	strb	r5, [r0, #8]
 80a126c:	60c5      	str	r5, [r0, #12]
 80a126e:	6105      	str	r5, [r0, #16]
{
  updateLength(n);
 80a1270:	f7ff ffb4 	bl	80a11dc <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a1274:	4620      	mov	r0, r4
 80a1276:	4631      	mov	r1, r6
 80a1278:	f7ff ffd9 	bl	80a122e <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a127c:	4620      	mov	r0, r4
 80a127e:	bd70      	pop	{r4, r5, r6, pc}

080a1280 <_ZN17Adafruit_NeoPixel4showEv>:
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a1280:	68c3      	ldr	r3, [r0, #12]
 80a1282:	2b00      	cmp	r3, #0
 80a1284:	f000 858e 	beq.w	80a1da4 <_ZN17Adafruit_NeoPixel4showEv+0xb24>
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
 80a1288:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a128c:	4604      	mov	r4, r0
 80a128e:	7983      	ldrb	r3, [r0, #6]
 80a1290:	b086      	sub	sp, #24
 80a1292:	3b02      	subs	r3, #2
 80a1294:	b2db      	uxtb	r3, r3
 80a1296:	2b04      	cmp	r3, #4
 80a1298:	bf96      	itet	ls
 80a129a:	4a29      	ldrls	r2, [pc, #164]	; (80a1340 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a129c:	2532      	movhi	r5, #50	; 0x32
 80a129e:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a12a2:	f7ff ff8b 	bl	80a11bc <micros>
 80a12a6:	6923      	ldr	r3, [r4, #16]
 80a12a8:	1ac0      	subs	r0, r0, r3
 80a12aa:	42a8      	cmp	r0, r5
 80a12ac:	d3f9      	bcc.n	80a12a2 <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a12ae:	b672      	cpsid	i
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a12b0:	79a1      	ldrb	r1, [r4, #6]
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a12b2:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a12b4:	2902      	cmp	r1, #2
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a12b6:	f8ad 300a 	strh.w	r3, [sp, #10]
  volatile uint8_t
    j,              // 8-bit inner loop counter
   *ptr = pixels,   // Pointer to next byte
 80a12ba:	f8d4 e00c 	ldr.w	lr, [r4, #12]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a12be:	f000 8272 	beq.w	80a17a6 <_ZN17Adafruit_NeoPixel4showEv+0x526>
 80a12c2:	2907      	cmp	r1, #7
 80a12c4:	f000 826f 	beq.w	80a17a6 <_ZN17Adafruit_NeoPixel4showEv+0x526>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a12c8:	2906      	cmp	r1, #6
 80a12ca:	f000 8432 	beq.w	80a1b32 <_ZN17Adafruit_NeoPixel4showEv+0x8b2>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a12ce:	2905      	cmp	r1, #5
 80a12d0:	f000 83ab 	beq.w	80a1a2a <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a12d4:	2908      	cmp	r1, #8
 80a12d6:	f000 83a8 	beq.w	80a1a2a <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a12da:	2900      	cmp	r1, #0
 80a12dc:	f040 8563 	bne.w	80a1da6 <_ZN17Adafruit_NeoPixel4showEv+0xb26>
 80a12e0:	4a18      	ldr	r2, [pc, #96]	; (80a1344 <_ZN17Adafruit_NeoPixel4showEv+0xc4>)
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a12e2:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a12e6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a12ea:	b29b      	uxth	r3, r3
 80a12ec:	2b00      	cmp	r3, #0
 80a12ee:	f000 8395 	beq.w	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a12f2:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a12f4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a12f8:	f10e 0503 	add.w	r5, lr, #3
 80a12fc:	3b03      	subs	r3, #3
 80a12fe:	b29b      	uxth	r3, r3
 80a1300:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a1304:	f89e 3000 	ldrb.w	r3, [lr]
 80a1308:	b2db      	uxtb	r3, r3
 80a130a:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a130e:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a1312:	b2db      	uxtb	r3, r3
 80a1314:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a1318:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a131c:	b2db      	uxtb	r3, r3
 80a131e:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a1322:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a1326:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a132a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a132e:	021b      	lsls	r3, r3, #8
 80a1330:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a1334:	4303      	orrs	r3, r0
 80a1336:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1338:	f88d 1005 	strb.w	r1, [sp, #5]
 80a133c:	e11b      	b.n	80a1576 <_ZN17Adafruit_NeoPixel4showEv+0x2f6>
 80a133e:	bf00      	nop
 80a1340:	080a58b8 	.word	0x080a58b8
 80a1344:	20000468 	.word	0x20000468
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1348:	4600      	mov	r0, r0
 80a134a:	bf00      	nop
 80a134c:	bf00      	nop
 80a134e:	bf00      	nop
 80a1350:	bf00      	nop
 80a1352:	bf00      	nop
 80a1354:	bf00      	nop
 80a1356:	bf00      	nop
 80a1358:	bf00      	nop
 80a135a:	bf00      	nop
 80a135c:	bf00      	nop
 80a135e:	bf00      	nop
 80a1360:	bf00      	nop
 80a1362:	bf00      	nop
 80a1364:	bf00      	nop
 80a1366:	bf00      	nop
 80a1368:	bf00      	nop
 80a136a:	bf00      	nop
 80a136c:	bf00      	nop
 80a136e:	bf00      	nop
 80a1370:	bf00      	nop
 80a1372:	bf00      	nop
 80a1374:	bf00      	nop
 80a1376:	bf00      	nop
 80a1378:	bf00      	nop
 80a137a:	bf00      	nop
 80a137c:	bf00      	nop
 80a137e:	bf00      	nop
 80a1380:	bf00      	nop
 80a1382:	bf00      	nop
 80a1384:	bf00      	nop
 80a1386:	bf00      	nop
 80a1388:	bf00      	nop
 80a138a:	bf00      	nop
 80a138c:	bf00      	nop
 80a138e:	bf00      	nop
 80a1390:	bf00      	nop
 80a1392:	bf00      	nop
 80a1394:	bf00      	nop
 80a1396:	bf00      	nop
 80a1398:	bf00      	nop
 80a139a:	bf00      	nop
 80a139c:	bf00      	nop
 80a139e:	bf00      	nop
 80a13a0:	bf00      	nop
 80a13a2:	bf00      	nop
 80a13a4:	bf00      	nop
 80a13a6:	bf00      	nop
 80a13a8:	bf00      	nop
 80a13aa:	bf00      	nop
 80a13ac:	bf00      	nop
 80a13ae:	bf00      	nop
 80a13b0:	bf00      	nop
 80a13b2:	bf00      	nop
 80a13b4:	bf00      	nop
 80a13b6:	bf00      	nop
 80a13b8:	bf00      	nop
 80a13ba:	bf00      	nop
 80a13bc:	bf00      	nop
 80a13be:	bf00      	nop
 80a13c0:	bf00      	nop
 80a13c2:	bf00      	nop
 80a13c4:	bf00      	nop
 80a13c6:	bf00      	nop
 80a13c8:	bf00      	nop
 80a13ca:	bf00      	nop
 80a13cc:	bf00      	nop
 80a13ce:	bf00      	nop
 80a13d0:	bf00      	nop
 80a13d2:	bf00      	nop
 80a13d4:	bf00      	nop
 80a13d6:	bf00      	nop
 80a13d8:	bf00      	nop
 80a13da:	bf00      	nop
 80a13dc:	bf00      	nop
 80a13de:	bf00      	nop
 80a13e0:	bf00      	nop
 80a13e2:	bf00      	nop
 80a13e4:	bf00      	nop
 80a13e6:	bf00      	nop
 80a13e8:	bf00      	nop
 80a13ea:	bf00      	nop
 80a13ec:	bf00      	nop
 80a13ee:	bf00      	nop
 80a13f0:	bf00      	nop
 80a13f2:	bf00      	nop
 80a13f4:	bf00      	nop
 80a13f6:	bf00      	nop
 80a13f8:	bf00      	nop
 80a13fa:	bf00      	nop
 80a13fc:	bf00      	nop
 80a13fe:	bf00      	nop
 80a1400:	bf00      	nop
 80a1402:	bf00      	nop
 80a1404:	bf00      	nop
 80a1406:	bf00      	nop
 80a1408:	bf00      	nop
 80a140a:	bf00      	nop
 80a140c:	bf00      	nop
 80a140e:	bf00      	nop
 80a1410:	bf00      	nop
 80a1412:	bf00      	nop
 80a1414:	bf00      	nop
 80a1416:	bf00      	nop
 80a1418:	bf00      	nop
 80a141a:	bf00      	nop
 80a141c:	bf00      	nop
 80a141e:	bf00      	nop
 80a1420:	bf00      	nop
 80a1422:	bf00      	nop
 80a1424:	bf00      	nop
 80a1426:	bf00      	nop
 80a1428:	bf00      	nop
 80a142a:	bf00      	nop
 80a142c:	bf00      	nop
 80a142e:	bf00      	nop
 80a1430:	bf00      	nop
 80a1432:	bf00      	nop
 80a1434:	bf00      	nop
 80a1436:	bf00      	nop
 80a1438:	bf00      	nop
 80a143a:	bf00      	nop
 80a143c:	bf00      	nop
 80a143e:	bf00      	nop
 80a1440:	bf00      	nop
 80a1442:	bf00      	nop
 80a1444:	bf00      	nop
 80a1446:	bf00      	nop
 80a1448:	bf00      	nop
 80a144a:	bf00      	nop
 80a144c:	bf00      	nop
 80a144e:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a1450:	79e3      	ldrb	r3, [r4, #7]
 80a1452:	6810      	ldr	r0, [r2, #0]
 80a1454:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1458:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a145c:	88bf      	ldrh	r7, [r7, #4]
 80a145e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1462:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1464:	4600      	mov	r0, r0
 80a1466:	bf00      	nop
 80a1468:	bf00      	nop
 80a146a:	bf00      	nop
 80a146c:	bf00      	nop
 80a146e:	bf00      	nop
 80a1470:	bf00      	nop
 80a1472:	bf00      	nop
 80a1474:	bf00      	nop
 80a1476:	bf00      	nop
 80a1478:	bf00      	nop
 80a147a:	bf00      	nop
 80a147c:	bf00      	nop
 80a147e:	bf00      	nop
 80a1480:	bf00      	nop
 80a1482:	bf00      	nop
 80a1484:	bf00      	nop
 80a1486:	bf00      	nop
 80a1488:	bf00      	nop
 80a148a:	bf00      	nop
 80a148c:	bf00      	nop
 80a148e:	bf00      	nop
 80a1490:	bf00      	nop
 80a1492:	bf00      	nop
 80a1494:	bf00      	nop
 80a1496:	bf00      	nop
 80a1498:	bf00      	nop
 80a149a:	bf00      	nop
 80a149c:	bf00      	nop
 80a149e:	bf00      	nop
 80a14a0:	bf00      	nop
 80a14a2:	bf00      	nop
 80a14a4:	bf00      	nop
 80a14a6:	bf00      	nop
 80a14a8:	bf00      	nop
 80a14aa:	bf00      	nop
 80a14ac:	bf00      	nop
 80a14ae:	bf00      	nop
 80a14b0:	bf00      	nop
 80a14b2:	bf00      	nop
 80a14b4:	bf00      	nop
 80a14b6:	bf00      	nop
 80a14b8:	bf00      	nop
 80a14ba:	bf00      	nop
 80a14bc:	bf00      	nop
 80a14be:	bf00      	nop
 80a14c0:	bf00      	nop
 80a14c2:	bf00      	nop
 80a14c4:	bf00      	nop
 80a14c6:	bf00      	nop
 80a14c8:	bf00      	nop
 80a14ca:	bf00      	nop
 80a14cc:	bf00      	nop
 80a14ce:	bf00      	nop
 80a14d0:	bf00      	nop
 80a14d2:	bf00      	nop
 80a14d4:	bf00      	nop
 80a14d6:	bf00      	nop
 80a14d8:	bf00      	nop
 80a14da:	bf00      	nop
 80a14dc:	bf00      	nop
 80a14de:	bf00      	nop
 80a14e0:	bf00      	nop
 80a14e2:	bf00      	nop
 80a14e4:	bf00      	nop
 80a14e6:	bf00      	nop
 80a14e8:	bf00      	nop
 80a14ea:	bf00      	nop
 80a14ec:	bf00      	nop
 80a14ee:	bf00      	nop
 80a14f0:	bf00      	nop
 80a14f2:	bf00      	nop
 80a14f4:	bf00      	nop
 80a14f6:	bf00      	nop
 80a14f8:	bf00      	nop
 80a14fa:	bf00      	nop
 80a14fc:	bf00      	nop
 80a14fe:	bf00      	nop
 80a1500:	bf00      	nop
 80a1502:	bf00      	nop
 80a1504:	bf00      	nop
 80a1506:	bf00      	nop
 80a1508:	bf00      	nop
 80a150a:	bf00      	nop
 80a150c:	bf00      	nop
 80a150e:	bf00      	nop
 80a1510:	bf00      	nop
 80a1512:	bf00      	nop
 80a1514:	bf00      	nop
 80a1516:	bf00      	nop
 80a1518:	bf00      	nop
 80a151a:	bf00      	nop
 80a151c:	bf00      	nop
 80a151e:	bf00      	nop
 80a1520:	bf00      	nop
 80a1522:	bf00      	nop
 80a1524:	bf00      	nop
 80a1526:	bf00      	nop
 80a1528:	bf00      	nop
 80a152a:	bf00      	nop
 80a152c:	bf00      	nop
 80a152e:	bf00      	nop
 80a1530:	bf00      	nop
 80a1532:	bf00      	nop
 80a1534:	bf00      	nop
 80a1536:	bf00      	nop
 80a1538:	bf00      	nop
 80a153a:	bf00      	nop
 80a153c:	bf00      	nop
 80a153e:	bf00      	nop
 80a1540:	bf00      	nop
 80a1542:	bf00      	nop
 80a1544:	bf00      	nop
 80a1546:	bf00      	nop
 80a1548:	bf00      	nop
 80a154a:	bf00      	nop
 80a154c:	bf00      	nop
 80a154e:	bf00      	nop
 80a1550:	bf00      	nop
 80a1552:	bf00      	nop
 80a1554:	bf00      	nop
 80a1556:	bf00      	nop
 80a1558:	bf00      	nop
 80a155a:	bf00      	nop
 80a155c:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a155e:	9b04      	ldr	r3, [sp, #16]
 80a1560:	085b      	lsrs	r3, r3, #1
 80a1562:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1564:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1568:	3301      	adds	r3, #1
 80a156a:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a156c:	2b17      	cmp	r3, #23
 80a156e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1572:	f200 82db 	bhi.w	80a1b2c <_ZN17Adafruit_NeoPixel4showEv+0x8ac>
        pinSet(pin, HIGH); // HIGH
 80a1576:	79e3      	ldrb	r3, [r4, #7]
 80a1578:	6810      	ldr	r0, [r2, #0]
 80a157a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a157e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1582:	88bf      	ldrh	r7, [r7, #4]
 80a1584:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1588:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a158a:	9803      	ldr	r0, [sp, #12]
 80a158c:	9b04      	ldr	r3, [sp, #16]
 80a158e:	4218      	tst	r0, r3
 80a1590:	f47f aeda 	bne.w	80a1348 <_ZN17Adafruit_NeoPixel4showEv+0xc8>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            "nop" "\n\t" "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a1594:	4600      	mov	r0, r0
 80a1596:	bf00      	nop
 80a1598:	bf00      	nop
 80a159a:	bf00      	nop
 80a159c:	bf00      	nop
 80a159e:	bf00      	nop
 80a15a0:	bf00      	nop
 80a15a2:	bf00      	nop
 80a15a4:	bf00      	nop
 80a15a6:	bf00      	nop
 80a15a8:	bf00      	nop
 80a15aa:	bf00      	nop
 80a15ac:	bf00      	nop
 80a15ae:	bf00      	nop
 80a15b0:	bf00      	nop
 80a15b2:	bf00      	nop
 80a15b4:	bf00      	nop
 80a15b6:	bf00      	nop
 80a15b8:	bf00      	nop
 80a15ba:	bf00      	nop
 80a15bc:	bf00      	nop
 80a15be:	bf00      	nop
 80a15c0:	bf00      	nop
 80a15c2:	bf00      	nop
 80a15c4:	bf00      	nop
 80a15c6:	bf00      	nop
 80a15c8:	bf00      	nop
 80a15ca:	bf00      	nop
 80a15cc:	bf00      	nop
 80a15ce:	bf00      	nop
 80a15d0:	bf00      	nop
 80a15d2:	bf00      	nop
 80a15d4:	bf00      	nop
 80a15d6:	bf00      	nop
 80a15d8:	bf00      	nop
 80a15da:	bf00      	nop
 80a15dc:	bf00      	nop
 80a15de:	bf00      	nop
 80a15e0:	bf00      	nop
 80a15e2:	bf00      	nop
 80a15e4:	bf00      	nop
          // WS2811 spec             2.000us LOW
          // Adafruit on Arduino    (meas. 2.000us)
          // This lib on Spark Core (meas. 2.000us)
          // This lib on Photon     (meas. 2.000us)
          pinSet(pin, LOW); // LOW
 80a15e6:	79e3      	ldrb	r3, [r4, #7]
 80a15e8:	6810      	ldr	r0, [r2, #0]
 80a15ea:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a15ee:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a15f2:	88bf      	ldrh	r7, [r7, #4]
 80a15f4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a15f8:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a15fa:	4600      	mov	r0, r0
 80a15fc:	bf00      	nop
 80a15fe:	bf00      	nop
 80a1600:	bf00      	nop
 80a1602:	bf00      	nop
 80a1604:	bf00      	nop
 80a1606:	bf00      	nop
 80a1608:	bf00      	nop
 80a160a:	bf00      	nop
 80a160c:	bf00      	nop
 80a160e:	bf00      	nop
 80a1610:	bf00      	nop
 80a1612:	bf00      	nop
 80a1614:	bf00      	nop
 80a1616:	bf00      	nop
 80a1618:	bf00      	nop
 80a161a:	bf00      	nop
 80a161c:	bf00      	nop
 80a161e:	bf00      	nop
 80a1620:	bf00      	nop
 80a1622:	bf00      	nop
 80a1624:	bf00      	nop
 80a1626:	bf00      	nop
 80a1628:	bf00      	nop
 80a162a:	bf00      	nop
 80a162c:	bf00      	nop
 80a162e:	bf00      	nop
 80a1630:	bf00      	nop
 80a1632:	bf00      	nop
 80a1634:	bf00      	nop
 80a1636:	bf00      	nop
 80a1638:	bf00      	nop
 80a163a:	bf00      	nop
 80a163c:	bf00      	nop
 80a163e:	bf00      	nop
 80a1640:	bf00      	nop
 80a1642:	bf00      	nop
 80a1644:	bf00      	nop
 80a1646:	bf00      	nop
 80a1648:	bf00      	nop
 80a164a:	bf00      	nop
 80a164c:	bf00      	nop
 80a164e:	bf00      	nop
 80a1650:	bf00      	nop
 80a1652:	bf00      	nop
 80a1654:	bf00      	nop
 80a1656:	bf00      	nop
 80a1658:	bf00      	nop
 80a165a:	bf00      	nop
 80a165c:	bf00      	nop
 80a165e:	bf00      	nop
 80a1660:	bf00      	nop
 80a1662:	bf00      	nop
 80a1664:	bf00      	nop
 80a1666:	bf00      	nop
 80a1668:	bf00      	nop
 80a166a:	bf00      	nop
 80a166c:	bf00      	nop
 80a166e:	bf00      	nop
 80a1670:	bf00      	nop
 80a1672:	bf00      	nop
 80a1674:	bf00      	nop
 80a1676:	bf00      	nop
 80a1678:	bf00      	nop
 80a167a:	bf00      	nop
 80a167c:	bf00      	nop
 80a167e:	bf00      	nop
 80a1680:	bf00      	nop
 80a1682:	bf00      	nop
 80a1684:	bf00      	nop
 80a1686:	bf00      	nop
 80a1688:	bf00      	nop
 80a168a:	bf00      	nop
 80a168c:	bf00      	nop
 80a168e:	bf00      	nop
 80a1690:	bf00      	nop
 80a1692:	bf00      	nop
 80a1694:	bf00      	nop
 80a1696:	bf00      	nop
 80a1698:	bf00      	nop
 80a169a:	bf00      	nop
 80a169c:	bf00      	nop
 80a169e:	bf00      	nop
 80a16a0:	bf00      	nop
 80a16a2:	bf00      	nop
 80a16a4:	bf00      	nop
 80a16a6:	bf00      	nop
 80a16a8:	bf00      	nop
 80a16aa:	bf00      	nop
 80a16ac:	bf00      	nop
 80a16ae:	bf00      	nop
 80a16b0:	bf00      	nop
 80a16b2:	bf00      	nop
 80a16b4:	bf00      	nop
 80a16b6:	bf00      	nop
 80a16b8:	bf00      	nop
 80a16ba:	bf00      	nop
 80a16bc:	bf00      	nop
 80a16be:	bf00      	nop
 80a16c0:	bf00      	nop
 80a16c2:	bf00      	nop
 80a16c4:	bf00      	nop
 80a16c6:	bf00      	nop
 80a16c8:	bf00      	nop
 80a16ca:	bf00      	nop
 80a16cc:	bf00      	nop
 80a16ce:	bf00      	nop
 80a16d0:	bf00      	nop
 80a16d2:	bf00      	nop
 80a16d4:	bf00      	nop
 80a16d6:	bf00      	nop
 80a16d8:	bf00      	nop
 80a16da:	bf00      	nop
 80a16dc:	bf00      	nop
 80a16de:	bf00      	nop
 80a16e0:	bf00      	nop
 80a16e2:	bf00      	nop
 80a16e4:	bf00      	nop
 80a16e6:	bf00      	nop
 80a16e8:	bf00      	nop
 80a16ea:	bf00      	nop
 80a16ec:	bf00      	nop
 80a16ee:	bf00      	nop
 80a16f0:	bf00      	nop
 80a16f2:	bf00      	nop
 80a16f4:	bf00      	nop
 80a16f6:	bf00      	nop
 80a16f8:	bf00      	nop
 80a16fa:	bf00      	nop
 80a16fc:	bf00      	nop
 80a16fe:	bf00      	nop
 80a1700:	bf00      	nop
 80a1702:	bf00      	nop
 80a1704:	bf00      	nop
 80a1706:	bf00      	nop
 80a1708:	bf00      	nop
 80a170a:	bf00      	nop
 80a170c:	bf00      	nop
 80a170e:	bf00      	nop
 80a1710:	bf00      	nop
 80a1712:	bf00      	nop
 80a1714:	bf00      	nop
 80a1716:	bf00      	nop
 80a1718:	bf00      	nop
 80a171a:	bf00      	nop
 80a171c:	bf00      	nop
 80a171e:	bf00      	nop
 80a1720:	bf00      	nop
 80a1722:	bf00      	nop
 80a1724:	bf00      	nop
 80a1726:	bf00      	nop
 80a1728:	bf00      	nop
 80a172a:	bf00      	nop
 80a172c:	bf00      	nop
 80a172e:	bf00      	nop
 80a1730:	bf00      	nop
 80a1732:	bf00      	nop
 80a1734:	bf00      	nop
 80a1736:	bf00      	nop
 80a1738:	bf00      	nop
 80a173a:	bf00      	nop
 80a173c:	bf00      	nop
 80a173e:	bf00      	nop
 80a1740:	bf00      	nop
 80a1742:	bf00      	nop
 80a1744:	bf00      	nop
 80a1746:	bf00      	nop
 80a1748:	bf00      	nop
 80a174a:	bf00      	nop
 80a174c:	bf00      	nop
 80a174e:	bf00      	nop
 80a1750:	bf00      	nop
 80a1752:	bf00      	nop
 80a1754:	bf00      	nop
 80a1756:	bf00      	nop
 80a1758:	bf00      	nop
 80a175a:	bf00      	nop
 80a175c:	bf00      	nop
 80a175e:	bf00      	nop
 80a1760:	bf00      	nop
 80a1762:	bf00      	nop
 80a1764:	bf00      	nop
 80a1766:	bf00      	nop
 80a1768:	bf00      	nop
 80a176a:	bf00      	nop
 80a176c:	bf00      	nop
 80a176e:	bf00      	nop
 80a1770:	bf00      	nop
 80a1772:	bf00      	nop
 80a1774:	bf00      	nop
 80a1776:	bf00      	nop
 80a1778:	bf00      	nop
 80a177a:	bf00      	nop
 80a177c:	bf00      	nop
 80a177e:	bf00      	nop
 80a1780:	bf00      	nop
 80a1782:	bf00      	nop
 80a1784:	bf00      	nop
 80a1786:	bf00      	nop
 80a1788:	bf00      	nop
 80a178a:	bf00      	nop
 80a178c:	bf00      	nop
 80a178e:	bf00      	nop
 80a1790:	bf00      	nop
 80a1792:	bf00      	nop
 80a1794:	bf00      	nop
 80a1796:	bf00      	nop
 80a1798:	bf00      	nop
 80a179a:	bf00      	nop
 80a179c:	bf00      	nop
 80a179e:	bf00      	nop
 80a17a0:	bf00      	nop
 80a17a2:	bf00      	nop
 80a17a4:	e6db      	b.n	80a155e <_ZN17Adafruit_NeoPixel4showEv+0x2de>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a17a6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a17aa:	4a17      	ldr	r2, [pc, #92]	; (80a1808 <_ZN17Adafruit_NeoPixel4showEv+0x588>)
 80a17ac:	b29b      	uxth	r3, r3
      mask = 0x800000; // reset the mask
 80a17ae:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a17b2:	2600      	movs	r6, #0
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a17b4:	2b00      	cmp	r3, #0
 80a17b6:	f000 8131 	beq.w	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a17ba:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a17bc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a17c0:	f10e 0103 	add.w	r1, lr, #3
 80a17c4:	3b03      	subs	r3, #3
 80a17c6:	b29b      	uxth	r3, r3
 80a17c8:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a17cc:	f89e 3000 	ldrb.w	r3, [lr]
 80a17d0:	b2db      	uxtb	r3, r3
 80a17d2:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a17d6:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a17da:	b2db      	uxtb	r3, r3
 80a17dc:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a17e0:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a17e4:	b2db      	uxtb	r3, r3
 80a17e6:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a17ea:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a17ee:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a17f2:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a17f6:	0200      	lsls	r0, r0, #8
 80a17f8:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80a17fc:	433b      	orrs	r3, r7
 80a17fe:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1800:	f88d 6005 	strb.w	r6, [sp, #5]
 80a1804:	e080      	b.n	80a1908 <_ZN17Adafruit_NeoPixel4showEv+0x688>
 80a1806:	bf00      	nop
 80a1808:	20000468 	.word	0x20000468
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a180c:	4600      	mov	r0, r0
 80a180e:	bf00      	nop
 80a1810:	bf00      	nop
 80a1812:	bf00      	nop
 80a1814:	bf00      	nop
 80a1816:	bf00      	nop
 80a1818:	bf00      	nop
 80a181a:	bf00      	nop
 80a181c:	bf00      	nop
 80a181e:	bf00      	nop
 80a1820:	bf00      	nop
 80a1822:	bf00      	nop
 80a1824:	bf00      	nop
 80a1826:	bf00      	nop
 80a1828:	bf00      	nop
 80a182a:	bf00      	nop
 80a182c:	bf00      	nop
 80a182e:	bf00      	nop
 80a1830:	bf00      	nop
 80a1832:	bf00      	nop
 80a1834:	bf00      	nop
 80a1836:	bf00      	nop
 80a1838:	bf00      	nop
 80a183a:	bf00      	nop
 80a183c:	bf00      	nop
 80a183e:	bf00      	nop
 80a1840:	bf00      	nop
 80a1842:	bf00      	nop
 80a1844:	bf00      	nop
 80a1846:	bf00      	nop
 80a1848:	bf00      	nop
 80a184a:	bf00      	nop
 80a184c:	bf00      	nop
 80a184e:	bf00      	nop
 80a1850:	bf00      	nop
 80a1852:	bf00      	nop
 80a1854:	bf00      	nop
 80a1856:	bf00      	nop
 80a1858:	bf00      	nop
 80a185a:	bf00      	nop
 80a185c:	bf00      	nop
 80a185e:	bf00      	nop
 80a1860:	bf00      	nop
 80a1862:	bf00      	nop
 80a1864:	bf00      	nop
 80a1866:	bf00      	nop
 80a1868:	bf00      	nop
 80a186a:	bf00      	nop
 80a186c:	bf00      	nop
 80a186e:	bf00      	nop
 80a1870:	bf00      	nop
 80a1872:	bf00      	nop
 80a1874:	bf00      	nop
 80a1876:	bf00      	nop
 80a1878:	bf00      	nop
 80a187a:	bf00      	nop
 80a187c:	bf00      	nop
 80a187e:	bf00      	nop
 80a1880:	bf00      	nop
 80a1882:	bf00      	nop
 80a1884:	bf00      	nop
 80a1886:	bf00      	nop
 80a1888:	bf00      	nop
 80a188a:	bf00      	nop
 80a188c:	bf00      	nop
 80a188e:	bf00      	nop
 80a1890:	bf00      	nop
 80a1892:	bf00      	nop
 80a1894:	bf00      	nop
 80a1896:	bf00      	nop
 80a1898:	bf00      	nop
 80a189a:	bf00      	nop
 80a189c:	bf00      	nop
 80a189e:	bf00      	nop
 80a18a0:	bf00      	nop
 80a18a2:	bf00      	nop
 80a18a4:	bf00      	nop
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 446ns)
          // This lib on Photon     (meas. 434ns)
          pinSet(pin, LOW); // LOW
 80a18a6:	79e3      	ldrb	r3, [r4, #7]
 80a18a8:	6810      	ldr	r0, [r2, #0]
 80a18aa:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a18ae:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a18b2:	88bf      	ldrh	r7, [r7, #4]
 80a18b4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a18b8:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a18ba:	4600      	mov	r0, r0
 80a18bc:	bf00      	nop
 80a18be:	bf00      	nop
 80a18c0:	bf00      	nop
 80a18c2:	bf00      	nop
 80a18c4:	bf00      	nop
 80a18c6:	bf00      	nop
 80a18c8:	bf00      	nop
 80a18ca:	bf00      	nop
 80a18cc:	bf00      	nop
 80a18ce:	bf00      	nop
 80a18d0:	bf00      	nop
 80a18d2:	bf00      	nop
 80a18d4:	bf00      	nop
 80a18d6:	bf00      	nop
 80a18d8:	bf00      	nop
 80a18da:	bf00      	nop
 80a18dc:	bf00      	nop
 80a18de:	bf00      	nop
 80a18e0:	bf00      	nop
 80a18e2:	bf00      	nop
 80a18e4:	bf00      	nop
 80a18e6:	bf00      	nop
 80a18e8:	bf00      	nop
 80a18ea:	bf00      	nop
 80a18ec:	bf00      	nop
 80a18ee:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a18f0:	9b04      	ldr	r3, [sp, #16]
 80a18f2:	085b      	lsrs	r3, r3, #1
 80a18f4:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a18f6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a18fa:	3301      	adds	r3, #1
 80a18fc:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a18fe:	2b17      	cmp	r3, #23
 80a1900:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1904:	f200 8083 	bhi.w	80a1a0e <_ZN17Adafruit_NeoPixel4showEv+0x78e>
        pinSet(pin, HIGH); // HIGH
 80a1908:	79e3      	ldrb	r3, [r4, #7]
 80a190a:	6810      	ldr	r0, [r2, #0]
 80a190c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1910:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1914:	88bf      	ldrh	r7, [r7, #4]
 80a1916:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a191a:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a191c:	9803      	ldr	r0, [sp, #12]
 80a191e:	9b04      	ldr	r3, [sp, #16]
 80a1920:	4218      	tst	r0, r3
 80a1922:	f47f af73 	bne.w	80a180c <_ZN17Adafruit_NeoPixel4showEv+0x58c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1926:	4600      	mov	r0, r0
 80a1928:	bf00      	nop
 80a192a:	bf00      	nop
 80a192c:	bf00      	nop
 80a192e:	bf00      	nop
 80a1930:	bf00      	nop
 80a1932:	bf00      	nop
 80a1934:	bf00      	nop
 80a1936:	bf00      	nop
 80a1938:	bf00      	nop
 80a193a:	bf00      	nop
 80a193c:	bf00      	nop
 80a193e:	bf00      	nop
 80a1940:	bf00      	nop
 80a1942:	bf00      	nop
 80a1944:	bf00      	nop
 80a1946:	bf00      	nop
 80a1948:	bf00      	nop
 80a194a:	bf00      	nop
 80a194c:	bf00      	nop
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 944ns)
          // This lib on Photon     (meas. 936ns)
          pinSet(pin, LOW); // LOW
 80a194e:	79e3      	ldrb	r3, [r4, #7]
 80a1950:	6810      	ldr	r0, [r2, #0]
 80a1952:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1956:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a195a:	88bf      	ldrh	r7, [r7, #4]
 80a195c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1960:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1962:	4600      	mov	r0, r0
 80a1964:	bf00      	nop
 80a1966:	bf00      	nop
 80a1968:	bf00      	nop
 80a196a:	bf00      	nop
 80a196c:	bf00      	nop
 80a196e:	bf00      	nop
 80a1970:	bf00      	nop
 80a1972:	bf00      	nop
 80a1974:	bf00      	nop
 80a1976:	bf00      	nop
 80a1978:	bf00      	nop
 80a197a:	bf00      	nop
 80a197c:	bf00      	nop
 80a197e:	bf00      	nop
 80a1980:	bf00      	nop
 80a1982:	bf00      	nop
 80a1984:	bf00      	nop
 80a1986:	bf00      	nop
 80a1988:	bf00      	nop
 80a198a:	bf00      	nop
 80a198c:	bf00      	nop
 80a198e:	bf00      	nop
 80a1990:	bf00      	nop
 80a1992:	bf00      	nop
 80a1994:	bf00      	nop
 80a1996:	bf00      	nop
 80a1998:	bf00      	nop
 80a199a:	bf00      	nop
 80a199c:	bf00      	nop
 80a199e:	bf00      	nop
 80a19a0:	bf00      	nop
 80a19a2:	bf00      	nop
 80a19a4:	bf00      	nop
 80a19a6:	bf00      	nop
 80a19a8:	bf00      	nop
 80a19aa:	bf00      	nop
 80a19ac:	bf00      	nop
 80a19ae:	bf00      	nop
 80a19b0:	bf00      	nop
 80a19b2:	bf00      	nop
 80a19b4:	bf00      	nop
 80a19b6:	bf00      	nop
 80a19b8:	bf00      	nop
 80a19ba:	bf00      	nop
 80a19bc:	bf00      	nop
 80a19be:	bf00      	nop
 80a19c0:	bf00      	nop
 80a19c2:	bf00      	nop
 80a19c4:	bf00      	nop
 80a19c6:	bf00      	nop
 80a19c8:	bf00      	nop
 80a19ca:	bf00      	nop
 80a19cc:	bf00      	nop
 80a19ce:	bf00      	nop
 80a19d0:	bf00      	nop
 80a19d2:	bf00      	nop
 80a19d4:	bf00      	nop
 80a19d6:	bf00      	nop
 80a19d8:	bf00      	nop
 80a19da:	bf00      	nop
 80a19dc:	bf00      	nop
 80a19de:	bf00      	nop
 80a19e0:	bf00      	nop
 80a19e2:	bf00      	nop
 80a19e4:	bf00      	nop
 80a19e6:	bf00      	nop
 80a19e8:	bf00      	nop
 80a19ea:	bf00      	nop
 80a19ec:	bf00      	nop
 80a19ee:	bf00      	nop
 80a19f0:	bf00      	nop
 80a19f2:	bf00      	nop
 80a19f4:	bf00      	nop
 80a19f6:	bf00      	nop
 80a19f8:	bf00      	nop
 80a19fa:	bf00      	nop
 80a19fc:	bf00      	nop
 80a19fe:	bf00      	nop
 80a1a00:	bf00      	nop
 80a1a02:	bf00      	nop
 80a1a04:	bf00      	nop
 80a1a06:	bf00      	nop
 80a1a08:	bf00      	nop
 80a1a0a:	bf00      	nop
 80a1a0c:	e770      	b.n	80a18f0 <_ZN17Adafruit_NeoPixel4showEv+0x670>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1a0e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a1a12:	468e      	mov	lr, r1
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1a14:	b29b      	uxth	r3, r3
 80a1a16:	2b00      	cmp	r3, #0
 80a1a18:	f47f aecf 	bne.w	80a17ba <_ZN17Adafruit_NeoPixel4showEv+0x53a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a1a1c:	b662      	cpsie	i
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a1a1e:	f7ff fbcd 	bl	80a11bc <micros>
 80a1a22:	6120      	str	r0, [r4, #16]
}
 80a1a24:	b006      	add	sp, #24
 80a1a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1a2a:	4b5e      	ldr	r3, [pc, #376]	; (80a1ba4 <_ZN17Adafruit_NeoPixel4showEv+0x924>)
 80a1a2c:	4a5e      	ldr	r2, [pc, #376]	; (80a1ba8 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
        pinSet(pin, HIGH); // HIGH
        if (c & mask) { // if masked bit is high
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a1a2e:	4618      	mov	r0, r3
 80a1a30:	6811      	ldr	r1, [r2, #0]
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a1a32:	f44f 0800 	mov.w	r8, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a1a36:	2700      	movs	r7, #0
    #define CYCLES_800_T1H  80 // 812ns (meas. 792ns)
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1a38:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a1a3c:	b292      	uxth	r2, r2
 80a1a3e:	2a00      	cmp	r2, #0
 80a1a40:	d0ec      	beq.n	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a1a42:	f8cd 8010 	str.w	r8, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1a46:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a1a4a:	f10e 0503 	add.w	r5, lr, #3
 80a1a4e:	3a03      	subs	r2, #3
 80a1a50:	b292      	uxth	r2, r2
 80a1a52:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a1a56:	f89e 2000 	ldrb.w	r2, [lr]
 80a1a5a:	b2d2      	uxtb	r2, r2
 80a1a5c:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a1a60:	f89e 2001 	ldrb.w	r2, [lr, #1]
 80a1a64:	b2d2      	uxtb	r2, r2
 80a1a66:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a1a6a:	f89e 2002 	ldrb.w	r2, [lr, #2]
 80a1a6e:	b2d2      	uxtb	r2, r2
 80a1a70:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a1a74:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a1a78:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a1a7c:	f89d c008 	ldrb.w	ip, [sp, #8]
 80a1a80:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 80a1a84:	ea4e 4202 	orr.w	r2, lr, r2, lsl #16
 80a1a88:	ea42 020c 	orr.w	r2, r2, ip
 80a1a8c:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1a8e:	f88d 7005 	strb.w	r7, [sp, #5]
      do {
        cyc = DWT->CYCCNT;
        pinSet(pin, HIGH); // HIGH
 80a1a92:	79e2      	ldrb	r2, [r4, #7]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1a94:	685e      	ldr	r6, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a1a96:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a1a9a:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a1a9e:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1aa2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1aa6:	9605      	str	r6, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a1aa8:	f8a2 e018 	strh.w	lr, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a1aac:	9e03      	ldr	r6, [sp, #12]
 80a1aae:	9a04      	ldr	r2, [sp, #16]
 80a1ab0:	4216      	tst	r6, r2
 80a1ab2:	d023      	beq.n	80a1afc <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a1ab4:	685a      	ldr	r2, [r3, #4]
 80a1ab6:	9e05      	ldr	r6, [sp, #20]
 80a1ab8:	1b92      	subs	r2, r2, r6
 80a1aba:	2a4f      	cmp	r2, #79	; 0x4f
 80a1abc:	d9fa      	bls.n	80a1ab4 <_ZN17Adafruit_NeoPixel4showEv+0x834>
          pinSet(pin, LOW);
 80a1abe:	79e2      	ldrb	r2, [r4, #7]
 80a1ac0:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a1ac4:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a1ac8:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1acc:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a1ad0:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a1ad4:	6842      	ldr	r2, [r0, #4]
 80a1ad6:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a1ad8:	685a      	ldr	r2, [r3, #4]
 80a1ada:	9e05      	ldr	r6, [sp, #20]
 80a1adc:	1b92      	subs	r2, r2, r6
 80a1ade:	2a07      	cmp	r2, #7
 80a1ae0:	d9fa      	bls.n	80a1ad8 <_ZN17Adafruit_NeoPixel4showEv+0x858>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
        }
        mask >>= 1;
 80a1ae2:	9a04      	ldr	r2, [sp, #16]
 80a1ae4:	0852      	lsrs	r2, r2, #1
 80a1ae6:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1ae8:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a1aec:	3201      	adds	r2, #1
 80a1aee:	b2d2      	uxtb	r2, r2
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a1af0:	2a17      	cmp	r2, #23
 80a1af2:	f88d 2005 	strb.w	r2, [sp, #5]
 80a1af6:	d9cc      	bls.n	80a1a92 <_ZN17Adafruit_NeoPixel4showEv+0x812>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a1af8:	46ae      	mov	lr, r5
 80a1afa:	e79d      	b.n	80a1a38 <_ZN17Adafruit_NeoPixel4showEv+0x7b8>
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
        }
        else { // else masked bit is low
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a1afc:	685a      	ldr	r2, [r3, #4]
 80a1afe:	9e05      	ldr	r6, [sp, #20]
 80a1b00:	1b92      	subs	r2, r2, r6
 80a1b02:	2a18      	cmp	r2, #24
 80a1b04:	d9fa      	bls.n	80a1afc <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          pinSet(pin, LOW);
 80a1b06:	79e2      	ldrb	r2, [r4, #7]
 80a1b08:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a1b0c:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a1b10:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1b14:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a1b18:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a1b1c:	6842      	ldr	r2, [r0, #4]
 80a1b1e:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a1b20:	685a      	ldr	r2, [r3, #4]
 80a1b22:	9e05      	ldr	r6, [sp, #20]
 80a1b24:	1b92      	subs	r2, r2, r6
 80a1b26:	2a45      	cmp	r2, #69	; 0x45
 80a1b28:	d9fa      	bls.n	80a1b20 <_ZN17Adafruit_NeoPixel4showEv+0x8a0>
 80a1b2a:	e7da      	b.n	80a1ae2 <_ZN17Adafruit_NeoPixel4showEv+0x862>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a1b2c:	46ae      	mov	lr, r5
 80a1b2e:	f7ff bbda 	b.w	80a12e6 <_ZN17Adafruit_NeoPixel4showEv+0x66>
 80a1b32:	4a1d      	ldr	r2, [pc, #116]	; (80a1ba8 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
      mask = 0x80000000; // reset the mask
 80a1b34:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
 80a1b38:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a1b3a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1b3e:	b29b      	uxth	r3, r3
 80a1b40:	2b00      	cmp	r3, #0
 80a1b42:	f43f af6b 	beq.w	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x80000000; // reset the mask
 80a1b46:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a1b48:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1b4c:	f10e 0104 	add.w	r1, lr, #4
 80a1b50:	3b04      	subs	r3, #4
 80a1b52:	b29b      	uxth	r3, r3
 80a1b54:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a1b58:	f89e 3000 	ldrb.w	r3, [lr]
 80a1b5c:	b2db      	uxtb	r3, r3
 80a1b5e:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a1b62:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a1b66:	b2db      	uxtb	r3, r3
 80a1b68:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a1b6c:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a1b70:	b2db      	uxtb	r3, r3
 80a1b72:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a1b76:	f89e 3003 	ldrb.w	r3, [lr, #3]
 80a1b7a:	b2db      	uxtb	r3, r3
 80a1b7c:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a1b80:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a1b84:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a1b88:	f89d e008 	ldrb.w	lr, [sp, #8]
 80a1b8c:	043f      	lsls	r7, r7, #16
 80a1b8e:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80a1b92:	ea47 6303 	orr.w	r3, r7, r3, lsl #24
 80a1b96:	4303      	orrs	r3, r0
 80a1b98:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
 80a1b9c:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a1b9e:	f88d 6005 	strb.w	r6, [sp, #5]
 80a1ba2:	e07e      	b.n	80a1ca2 <_ZN17Adafruit_NeoPixel4showEv+0xa22>
 80a1ba4:	e0001000 	.word	0xe0001000
 80a1ba8:	20000468 	.word	0x20000468
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1bac:	4600      	mov	r0, r0
 80a1bae:	bf00      	nop
 80a1bb0:	bf00      	nop
 80a1bb2:	bf00      	nop
 80a1bb4:	bf00      	nop
 80a1bb6:	bf00      	nop
 80a1bb8:	bf00      	nop
 80a1bba:	bf00      	nop
 80a1bbc:	bf00      	nop
 80a1bbe:	bf00      	nop
 80a1bc0:	bf00      	nop
 80a1bc2:	bf00      	nop
 80a1bc4:	bf00      	nop
 80a1bc6:	bf00      	nop
 80a1bc8:	bf00      	nop
 80a1bca:	bf00      	nop
 80a1bcc:	bf00      	nop
 80a1bce:	bf00      	nop
 80a1bd0:	bf00      	nop
 80a1bd2:	bf00      	nop
 80a1bd4:	bf00      	nop
 80a1bd6:	bf00      	nop
 80a1bd8:	bf00      	nop
 80a1bda:	bf00      	nop
 80a1bdc:	bf00      	nop
 80a1bde:	bf00      	nop
 80a1be0:	bf00      	nop
 80a1be2:	bf00      	nop
 80a1be4:	bf00      	nop
 80a1be6:	bf00      	nop
 80a1be8:	bf00      	nop
 80a1bea:	bf00      	nop
 80a1bec:	bf00      	nop
 80a1bee:	bf00      	nop
 80a1bf0:	bf00      	nop
 80a1bf2:	bf00      	nop
 80a1bf4:	bf00      	nop
 80a1bf6:	bf00      	nop
 80a1bf8:	bf00      	nop
 80a1bfa:	bf00      	nop
 80a1bfc:	bf00      	nop
 80a1bfe:	bf00      	nop
 80a1c00:	bf00      	nop
 80a1c02:	bf00      	nop
 80a1c04:	bf00      	nop
 80a1c06:	bf00      	nop
 80a1c08:	bf00      	nop
 80a1c0a:	bf00      	nop
 80a1c0c:	bf00      	nop
 80a1c0e:	bf00      	nop
 80a1c10:	bf00      	nop
 80a1c12:	bf00      	nop
 80a1c14:	bf00      	nop
 80a1c16:	bf00      	nop
 80a1c18:	bf00      	nop
          // SK6812RGBW spec         600ns LOW
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 598ns)
          // This lib on Photon     (meas. 600ns)
          pinSet(pin, LOW); // LOW
 80a1c1a:	79e3      	ldrb	r3, [r4, #7]
 80a1c1c:	6810      	ldr	r0, [r2, #0]
 80a1c1e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1c22:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1c26:	88bf      	ldrh	r7, [r7, #4]
 80a1c28:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1c2c:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1c2e:	4600      	mov	r0, r0
 80a1c30:	bf00      	nop
 80a1c32:	bf00      	nop
 80a1c34:	bf00      	nop
 80a1c36:	bf00      	nop
 80a1c38:	bf00      	nop
 80a1c3a:	bf00      	nop
 80a1c3c:	bf00      	nop
 80a1c3e:	bf00      	nop
 80a1c40:	bf00      	nop
 80a1c42:	bf00      	nop
 80a1c44:	bf00      	nop
 80a1c46:	bf00      	nop
 80a1c48:	bf00      	nop
 80a1c4a:	bf00      	nop
 80a1c4c:	bf00      	nop
 80a1c4e:	bf00      	nop
 80a1c50:	bf00      	nop
 80a1c52:	bf00      	nop
 80a1c54:	bf00      	nop
 80a1c56:	bf00      	nop
 80a1c58:	bf00      	nop
 80a1c5a:	bf00      	nop
 80a1c5c:	bf00      	nop
 80a1c5e:	bf00      	nop
 80a1c60:	bf00      	nop
 80a1c62:	bf00      	nop
 80a1c64:	bf00      	nop
 80a1c66:	bf00      	nop
 80a1c68:	bf00      	nop
 80a1c6a:	bf00      	nop
 80a1c6c:	bf00      	nop
 80a1c6e:	bf00      	nop
 80a1c70:	bf00      	nop
 80a1c72:	bf00      	nop
 80a1c74:	bf00      	nop
 80a1c76:	bf00      	nop
 80a1c78:	bf00      	nop
 80a1c7a:	bf00      	nop
 80a1c7c:	bf00      	nop
 80a1c7e:	bf00      	nop
 80a1c80:	bf00      	nop
 80a1c82:	bf00      	nop
 80a1c84:	bf00      	nop
 80a1c86:	bf00      	nop
 80a1c88:	bf00      	nop
 80a1c8a:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a1c8c:	9b04      	ldr	r3, [sp, #16]
 80a1c8e:	085b      	lsrs	r3, r3, #1
 80a1c90:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a1c92:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1c96:	3301      	adds	r3, #1
 80a1c98:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
      do {
 80a1c9a:	2b1f      	cmp	r3, #31
 80a1c9c:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1ca0:	d87e      	bhi.n	80a1da0 <_ZN17Adafruit_NeoPixel4showEv+0xb20>
        pinSet(pin, HIGH); // HIGH
 80a1ca2:	79e3      	ldrb	r3, [r4, #7]
 80a1ca4:	6810      	ldr	r0, [r2, #0]
 80a1ca6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1caa:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1cae:	88bf      	ldrh	r7, [r7, #4]
 80a1cb0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1cb4:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a1cb6:	9803      	ldr	r0, [sp, #12]
 80a1cb8:	9b04      	ldr	r3, [sp, #16]
 80a1cba:	4218      	tst	r0, r3
 80a1cbc:	f47f af76 	bne.w	80a1bac <_ZN17Adafruit_NeoPixel4showEv+0x92c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1cc0:	4600      	mov	r0, r0
 80a1cc2:	bf00      	nop
 80a1cc4:	bf00      	nop
 80a1cc6:	bf00      	nop
 80a1cc8:	bf00      	nop
 80a1cca:	bf00      	nop
 80a1ccc:	bf00      	nop
 80a1cce:	bf00      	nop
 80a1cd0:	bf00      	nop
 80a1cd2:	bf00      	nop
 80a1cd4:	bf00      	nop
 80a1cd6:	bf00      	nop
 80a1cd8:	bf00      	nop
 80a1cda:	bf00      	nop
 80a1cdc:	bf00      	nop
 80a1cde:	bf00      	nop
 80a1ce0:	bf00      	nop
 80a1ce2:	bf00      	nop
 80a1ce4:	bf00      	nop
 80a1ce6:	bf00      	nop
          // SK6812RGBW spec         900ns LOW
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 904ns)
          // This lib on Photon     (meas. 900ns)
          pinSet(pin, LOW); // LOW
 80a1ce8:	79e3      	ldrb	r3, [r4, #7]
 80a1cea:	6810      	ldr	r0, [r2, #0]
 80a1cec:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1cf0:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1cf4:	88bf      	ldrh	r7, [r7, #4]
 80a1cf6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1cfa:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1cfc:	4600      	mov	r0, r0
 80a1cfe:	bf00      	nop
 80a1d00:	bf00      	nop
 80a1d02:	bf00      	nop
 80a1d04:	bf00      	nop
 80a1d06:	bf00      	nop
 80a1d08:	bf00      	nop
 80a1d0a:	bf00      	nop
 80a1d0c:	bf00      	nop
 80a1d0e:	bf00      	nop
 80a1d10:	bf00      	nop
 80a1d12:	bf00      	nop
 80a1d14:	bf00      	nop
 80a1d16:	bf00      	nop
 80a1d18:	bf00      	nop
 80a1d1a:	bf00      	nop
 80a1d1c:	bf00      	nop
 80a1d1e:	bf00      	nop
 80a1d20:	bf00      	nop
 80a1d22:	bf00      	nop
 80a1d24:	bf00      	nop
 80a1d26:	bf00      	nop
 80a1d28:	bf00      	nop
 80a1d2a:	bf00      	nop
 80a1d2c:	bf00      	nop
 80a1d2e:	bf00      	nop
 80a1d30:	bf00      	nop
 80a1d32:	bf00      	nop
 80a1d34:	bf00      	nop
 80a1d36:	bf00      	nop
 80a1d38:	bf00      	nop
 80a1d3a:	bf00      	nop
 80a1d3c:	bf00      	nop
 80a1d3e:	bf00      	nop
 80a1d40:	bf00      	nop
 80a1d42:	bf00      	nop
 80a1d44:	bf00      	nop
 80a1d46:	bf00      	nop
 80a1d48:	bf00      	nop
 80a1d4a:	bf00      	nop
 80a1d4c:	bf00      	nop
 80a1d4e:	bf00      	nop
 80a1d50:	bf00      	nop
 80a1d52:	bf00      	nop
 80a1d54:	bf00      	nop
 80a1d56:	bf00      	nop
 80a1d58:	bf00      	nop
 80a1d5a:	bf00      	nop
 80a1d5c:	bf00      	nop
 80a1d5e:	bf00      	nop
 80a1d60:	bf00      	nop
 80a1d62:	bf00      	nop
 80a1d64:	bf00      	nop
 80a1d66:	bf00      	nop
 80a1d68:	bf00      	nop
 80a1d6a:	bf00      	nop
 80a1d6c:	bf00      	nop
 80a1d6e:	bf00      	nop
 80a1d70:	bf00      	nop
 80a1d72:	bf00      	nop
 80a1d74:	bf00      	nop
 80a1d76:	bf00      	nop
 80a1d78:	bf00      	nop
 80a1d7a:	bf00      	nop
 80a1d7c:	bf00      	nop
 80a1d7e:	bf00      	nop
 80a1d80:	bf00      	nop
 80a1d82:	bf00      	nop
 80a1d84:	bf00      	nop
 80a1d86:	bf00      	nop
 80a1d88:	bf00      	nop
 80a1d8a:	bf00      	nop
 80a1d8c:	bf00      	nop
 80a1d8e:	bf00      	nop
 80a1d90:	bf00      	nop
 80a1d92:	bf00      	nop
 80a1d94:	bf00      	nop
 80a1d96:	bf00      	nop
 80a1d98:	bf00      	nop
 80a1d9a:	bf00      	nop
 80a1d9c:	bf00      	nop
 80a1d9e:	e775      	b.n	80a1c8c <_ZN17Adafruit_NeoPixel4showEv+0xa0c>
      mask = 0x80000000; // reset the mask
      i = i-4;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
 80a1da0:	468e      	mov	lr, r1
 80a1da2:	e6ca      	b.n	80a1b3a <_ZN17Adafruit_NeoPixel4showEv+0x8ba>
 80a1da4:	4770      	bx	lr
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a1da6:	2903      	cmp	r1, #3
 80a1da8:	f000 812e 	beq.w	80a2008 <_ZN17Adafruit_NeoPixel4showEv+0xd88>
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1dac:	4a1e      	ldr	r2, [pc, #120]	; (80a1e28 <_ZN17Adafruit_NeoPixel4showEv+0xba8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a1dae:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a1db2:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1db4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1db8:	b29b      	uxth	r3, r3
 80a1dba:	2b00      	cmp	r3, #0
 80a1dbc:	f43f ae2e 	beq.w	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a1dc0:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1dc2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1dc6:	79e0      	ldrb	r0, [r4, #7]
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
 80a1dc8:	3b03      	subs	r3, #3
 80a1dca:	b29b      	uxth	r3, r3
 80a1dcc:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a1dd0:	f89e 3000 	ldrb.w	r3, [lr]
 80a1dd4:	f10e 0103 	add.w	r1, lr, #3
 80a1dd8:	b2db      	uxtb	r3, r3
 80a1dda:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a1dde:	f89e 3001 	ldrb.w	r3, [lr, #1]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1de2:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a1de6:	b2db      	uxtb	r3, r3
 80a1de8:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a1dec:	f89e 3002 	ldrb.w	r3, [lr, #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1df0:	f8d2 e000 	ldr.w	lr, [r2]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
 80a1df4:	b2db      	uxtb	r3, r3
 80a1df6:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a1dfa:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a1dfe:	f89d 3008 	ldrb.w	r3, [sp, #8]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1e02:	eb0e 0c80 	add.w	ip, lr, r0, lsl #2
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a1e06:	021b      	lsls	r3, r3, #8
 80a1e08:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a1e0c:	f89d 7006 	ldrb.w	r7, [sp, #6]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a1e10:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a1e14:	f85e 0020 	ldr.w	r0, [lr, r0, lsl #2]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a1e18:	433b      	orrs	r3, r7
 80a1e1a:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1e1c:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a1e20:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a1e24:	e07d      	b.n	80a1f22 <_ZN17Adafruit_NeoPixel4showEv+0xca2>
 80a1e26:	bf00      	nop
 80a1e28:	20000468 	.word	0x20000468
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
          // TM1829 spec             800ns LOW
          // This lib on Spark Core (meas. 806ns)
          // This lib on Photon     (meas. 792ns)
          mask >>= 1; // Do this task during the long delay of this bit
 80a1e2c:	9b04      	ldr	r3, [sp, #16]
 80a1e2e:	085b      	lsrs	r3, r3, #1
 80a1e30:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1e32:	4600      	mov	r0, r0
 80a1e34:	bf00      	nop
 80a1e36:	bf00      	nop
 80a1e38:	bf00      	nop
 80a1e3a:	bf00      	nop
 80a1e3c:	bf00      	nop
 80a1e3e:	bf00      	nop
 80a1e40:	bf00      	nop
 80a1e42:	bf00      	nop
 80a1e44:	bf00      	nop
 80a1e46:	bf00      	nop
 80a1e48:	bf00      	nop
 80a1e4a:	bf00      	nop
 80a1e4c:	bf00      	nop
 80a1e4e:	bf00      	nop
 80a1e50:	bf00      	nop
 80a1e52:	bf00      	nop
 80a1e54:	bf00      	nop
 80a1e56:	bf00      	nop
 80a1e58:	bf00      	nop
 80a1e5a:	bf00      	nop
 80a1e5c:	bf00      	nop
 80a1e5e:	bf00      	nop
 80a1e60:	bf00      	nop
 80a1e62:	bf00      	nop
 80a1e64:	bf00      	nop
 80a1e66:	bf00      	nop
 80a1e68:	bf00      	nop
 80a1e6a:	bf00      	nop
 80a1e6c:	bf00      	nop
 80a1e6e:	bf00      	nop
 80a1e70:	bf00      	nop
 80a1e72:	bf00      	nop
 80a1e74:	bf00      	nop
 80a1e76:	bf00      	nop
 80a1e78:	bf00      	nop
 80a1e7a:	bf00      	nop
 80a1e7c:	bf00      	nop
 80a1e7e:	bf00      	nop
 80a1e80:	bf00      	nop
 80a1e82:	bf00      	nop
 80a1e84:	bf00      	nop
 80a1e86:	bf00      	nop
 80a1e88:	bf00      	nop
 80a1e8a:	bf00      	nop
 80a1e8c:	bf00      	nop
 80a1e8e:	bf00      	nop
 80a1e90:	bf00      	nop
 80a1e92:	bf00      	nop
 80a1e94:	bf00      	nop
 80a1e96:	bf00      	nop
 80a1e98:	bf00      	nop
 80a1e9a:	bf00      	nop
 80a1e9c:	bf00      	nop
 80a1e9e:	bf00      	nop
 80a1ea0:	bf00      	nop
 80a1ea2:	bf00      	nop
 80a1ea4:	bf00      	nop
 80a1ea6:	bf00      	nop
 80a1ea8:	bf00      	nop
 80a1eaa:	bf00      	nop
 80a1eac:	bf00      	nop
 80a1eae:	bf00      	nop
 80a1eb0:	bf00      	nop
 80a1eb2:	bf00      	nop
 80a1eb4:	bf00      	nop
 80a1eb6:	bf00      	nop
          j++;
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a1eb8:	79e0      	ldrb	r0, [r4, #7]
 80a1eba:	6817      	ldr	r7, [r2, #0]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a1ebc:	f89d 3005 	ldrb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a1ec0:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a1ec4:	eb07 0e80 	add.w	lr, r7, r0, lsl #2
 80a1ec8:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1ecc:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a1ed0:	3301      	adds	r3, #1
 80a1ed2:	b2db      	uxtb	r3, r3
 80a1ed4:	f88d 3005 	strb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a1ed8:	f8a0 e018 	strh.w	lr, [r0, #24]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1edc:	4600      	mov	r0, r0
 80a1ede:	bf00      	nop
 80a1ee0:	bf00      	nop
 80a1ee2:	bf00      	nop
 80a1ee4:	bf00      	nop
 80a1ee6:	bf00      	nop
 80a1ee8:	bf00      	nop
 80a1eea:	bf00      	nop
 80a1eec:	bf00      	nop
 80a1eee:	bf00      	nop
 80a1ef0:	bf00      	nop
 80a1ef2:	bf00      	nop
 80a1ef4:	bf00      	nop
 80a1ef6:	bf00      	nop
 80a1ef8:	bf00      	nop
 80a1efa:	bf00      	nop
 80a1efc:	bf00      	nop
 80a1efe:	bf00      	nop
 80a1f00:	bf00      	nop
 80a1f02:	bf00      	nop
 80a1f04:	bf00      	nop
          if(j==24) break;
 80a1f06:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1f0a:	2b18      	cmp	r3, #24
 80a1f0c:	d07a      	beq.n	80a2004 <_ZN17Adafruit_NeoPixel4showEv+0xd84>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          if(j==24) break;
          pinSet(pin, LOW); // LOW
 80a1f0e:	79e3      	ldrb	r3, [r4, #7]
 80a1f10:	6810      	ldr	r0, [r2, #0]
 80a1f12:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1f16:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1f1a:	88bf      	ldrh	r7, [r7, #4]
 80a1f1c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1f20:	835f      	strh	r7, [r3, #26]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
 80a1f22:	9803      	ldr	r0, [sp, #12]
 80a1f24:	9b04      	ldr	r3, [sp, #16]
 80a1f26:	4218      	tst	r0, r3
 80a1f28:	d180      	bne.n	80a1e2c <_ZN17Adafruit_NeoPixel4showEv+0xbac>
            "mov r0, r0" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a1f2a:	4600      	mov	r0, r0
 80a1f2c:	bf00      	nop
 80a1f2e:	bf00      	nop
 80a1f30:	bf00      	nop
 80a1f32:	bf00      	nop
 80a1f34:	bf00      	nop
 80a1f36:	bf00      	nop
 80a1f38:	bf00      	nop
 80a1f3a:	bf00      	nop
 80a1f3c:	bf00      	nop
 80a1f3e:	bf00      	nop
 80a1f40:	bf00      	nop
 80a1f42:	bf00      	nop
 80a1f44:	bf00      	nop
 80a1f46:	bf00      	nop
 80a1f48:	bf00      	nop
 80a1f4a:	bf00      	nop
#endif
          // TM1829 spec             800ns HIGH
          // This lib on Spark Core (meas. 792ns)
          // This lib on Photon     (meas. 800ns)
          pinSet(pin, HIGH); // HIGH
 80a1f4c:	79e3      	ldrb	r3, [r4, #7]
 80a1f4e:	6810      	ldr	r0, [r2, #0]
 80a1f50:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1f54:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1f58:	88bf      	ldrh	r7, [r7, #4]
 80a1f5a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1f5e:	831f      	strh	r7, [r3, #24]
          j++;
 80a1f60:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1f64:	3301      	adds	r3, #1
 80a1f66:	b2db      	uxtb	r3, r3
 80a1f68:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a1f6c:	9b04      	ldr	r3, [sp, #16]
 80a1f6e:	085b      	lsrs	r3, r3, #1
 80a1f70:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1f72:	4600      	mov	r0, r0
 80a1f74:	bf00      	nop
 80a1f76:	bf00      	nop
 80a1f78:	bf00      	nop
 80a1f7a:	bf00      	nop
 80a1f7c:	bf00      	nop
 80a1f7e:	bf00      	nop
 80a1f80:	bf00      	nop
 80a1f82:	bf00      	nop
 80a1f84:	bf00      	nop
 80a1f86:	bf00      	nop
 80a1f88:	bf00      	nop
 80a1f8a:	bf00      	nop
 80a1f8c:	bf00      	nop
 80a1f8e:	bf00      	nop
 80a1f90:	bf00      	nop
 80a1f92:	bf00      	nop
 80a1f94:	bf00      	nop
 80a1f96:	bf00      	nop
 80a1f98:	bf00      	nop
 80a1f9a:	bf00      	nop
 80a1f9c:	bf00      	nop
 80a1f9e:	bf00      	nop
 80a1fa0:	bf00      	nop
 80a1fa2:	bf00      	nop
 80a1fa4:	bf00      	nop
 80a1fa6:	bf00      	nop
 80a1fa8:	bf00      	nop
 80a1faa:	bf00      	nop
 80a1fac:	bf00      	nop
 80a1fae:	bf00      	nop
 80a1fb0:	bf00      	nop
 80a1fb2:	bf00      	nop
 80a1fb4:	bf00      	nop
 80a1fb6:	bf00      	nop
 80a1fb8:	bf00      	nop
 80a1fba:	bf00      	nop
 80a1fbc:	bf00      	nop
 80a1fbe:	bf00      	nop
 80a1fc0:	bf00      	nop
 80a1fc2:	bf00      	nop
 80a1fc4:	bf00      	nop
 80a1fc6:	bf00      	nop
 80a1fc8:	bf00      	nop
 80a1fca:	bf00      	nop
 80a1fcc:	bf00      	nop
 80a1fce:	bf00      	nop
 80a1fd0:	bf00      	nop
 80a1fd2:	bf00      	nop
 80a1fd4:	bf00      	nop
 80a1fd6:	bf00      	nop
 80a1fd8:	bf00      	nop
 80a1fda:	bf00      	nop
 80a1fdc:	bf00      	nop
 80a1fde:	bf00      	nop
 80a1fe0:	bf00      	nop
 80a1fe2:	bf00      	nop
 80a1fe4:	bf00      	nop
 80a1fe6:	bf00      	nop
 80a1fe8:	bf00      	nop
 80a1fea:	bf00      	nop
 80a1fec:	bf00      	nop
 80a1fee:	bf00      	nop
 80a1ff0:	bf00      	nop
 80a1ff2:	bf00      	nop
 80a1ff4:	bf00      	nop
 80a1ff6:	bf00      	nop
 80a1ff8:	bf00      	nop
 80a1ffa:	bf00      	nop
          if(j==24) break;
 80a1ffc:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2000:	2b18      	cmp	r3, #24
 80a2002:	d184      	bne.n	80a1f0e <_ZN17Adafruit_NeoPixel4showEv+0xc8e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a2004:	468e      	mov	lr, r1
 80a2006:	e6d5      	b.n	80a1db4 <_ZN17Adafruit_NeoPixel4showEv+0xb34>
 80a2008:	4a17      	ldr	r2, [pc, #92]	; (80a2068 <_ZN17Adafruit_NeoPixel4showEv+0xde8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a200a:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a200e:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2010:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2014:	b29b      	uxth	r3, r3
 80a2016:	2b00      	cmp	r3, #0
 80a2018:	f43f ad00 	beq.w	80a1a1c <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a201c:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a201e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2022:	f10e 0103 	add.w	r1, lr, #3
 80a2026:	3b03      	subs	r3, #3
 80a2028:	b29b      	uxth	r3, r3
 80a202a:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a202e:	f89e 3000 	ldrb.w	r3, [lr]
 80a2032:	b2db      	uxtb	r3, r3
 80a2034:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a2038:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a203c:	b2db      	uxtb	r3, r3
 80a203e:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a2042:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a2046:	b2db      	uxtb	r3, r3
 80a2048:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a204c:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a2050:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a2054:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2058:	021b      	lsls	r3, r3, #8
 80a205a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a205e:	4303      	orrs	r3, r0
 80a2060:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a2062:	f88d 6005 	strb.w	r6, [sp, #5]
 80a2066:	e0e0      	b.n	80a222a <_ZN17Adafruit_NeoPixel4showEv+0xfaa>
 80a2068:	20000468 	.word	0x20000468
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a206c:	4600      	mov	r0, r0
 80a206e:	bf00      	nop
 80a2070:	bf00      	nop
 80a2072:	bf00      	nop
 80a2074:	bf00      	nop
 80a2076:	bf00      	nop
 80a2078:	bf00      	nop
 80a207a:	bf00      	nop
 80a207c:	bf00      	nop
 80a207e:	bf00      	nop
 80a2080:	bf00      	nop
 80a2082:	bf00      	nop
 80a2084:	bf00      	nop
 80a2086:	bf00      	nop
 80a2088:	bf00      	nop
 80a208a:	bf00      	nop
 80a208c:	bf00      	nop
 80a208e:	bf00      	nop
 80a2090:	bf00      	nop
 80a2092:	bf00      	nop
 80a2094:	bf00      	nop
 80a2096:	bf00      	nop
 80a2098:	bf00      	nop
 80a209a:	bf00      	nop
 80a209c:	bf00      	nop
 80a209e:	bf00      	nop
 80a20a0:	bf00      	nop
 80a20a2:	bf00      	nop
 80a20a4:	bf00      	nop
 80a20a6:	bf00      	nop
 80a20a8:	bf00      	nop
 80a20aa:	bf00      	nop
 80a20ac:	bf00      	nop
 80a20ae:	bf00      	nop
 80a20b0:	bf00      	nop
 80a20b2:	bf00      	nop
 80a20b4:	bf00      	nop
 80a20b6:	bf00      	nop
 80a20b8:	bf00      	nop
 80a20ba:	bf00      	nop
 80a20bc:	bf00      	nop
 80a20be:	bf00      	nop
 80a20c0:	bf00      	nop
 80a20c2:	bf00      	nop
 80a20c4:	bf00      	nop
 80a20c6:	bf00      	nop
 80a20c8:	bf00      	nop
 80a20ca:	bf00      	nop
 80a20cc:	bf00      	nop
 80a20ce:	bf00      	nop
 80a20d0:	bf00      	nop
 80a20d2:	bf00      	nop
 80a20d4:	bf00      	nop
 80a20d6:	bf00      	nop
 80a20d8:	bf00      	nop
 80a20da:	bf00      	nop
 80a20dc:	bf00      	nop
 80a20de:	bf00      	nop
 80a20e0:	bf00      	nop
 80a20e2:	bf00      	nop
 80a20e4:	bf00      	nop
 80a20e6:	bf00      	nop
 80a20e8:	bf00      	nop
 80a20ea:	bf00      	nop
 80a20ec:	bf00      	nop
 80a20ee:	bf00      	nop
 80a20f0:	bf00      	nop
 80a20f2:	bf00      	nop
 80a20f4:	bf00      	nop
 80a20f6:	bf00      	nop
 80a20f8:	bf00      	nop
 80a20fa:	bf00      	nop
 80a20fc:	bf00      	nop
 80a20fe:	bf00      	nop
 80a2100:	bf00      	nop
 80a2102:	bf00      	nop
 80a2104:	bf00      	nop
 80a2106:	bf00      	nop
 80a2108:	bf00      	nop
 80a210a:	bf00      	nop
 80a210c:	bf00      	nop
 80a210e:	bf00      	nop
 80a2110:	bf00      	nop
 80a2112:	bf00      	nop
 80a2114:	bf00      	nop
 80a2116:	bf00      	nop
 80a2118:	bf00      	nop
 80a211a:	bf00      	nop
 80a211c:	bf00      	nop
 80a211e:	bf00      	nop
 80a2120:	bf00      	nop
 80a2122:	bf00      	nop
 80a2124:	bf00      	nop
 80a2126:	bf00      	nop
 80a2128:	bf00      	nop
 80a212a:	bf00      	nop
 80a212c:	bf00      	nop
 80a212e:	bf00      	nop
 80a2130:	bf00      	nop
 80a2132:	bf00      	nop
 80a2134:	bf00      	nop
 80a2136:	bf00      	nop
 80a2138:	bf00      	nop
 80a213a:	bf00      	nop
 80a213c:	bf00      	nop
 80a213e:	bf00      	nop
 80a2140:	bf00      	nop
 80a2142:	bf00      	nop
 80a2144:	bf00      	nop
 80a2146:	bf00      	nop
 80a2148:	bf00      	nop
 80a214a:	bf00      	nop
 80a214c:	bf00      	nop
 80a214e:	bf00      	nop
 80a2150:	bf00      	nop
 80a2152:	bf00      	nop
 80a2154:	bf00      	nop
 80a2156:	bf00      	nop
 80a2158:	bf00      	nop
 80a215a:	bf00      	nop
 80a215c:	bf00      	nop
 80a215e:	bf00      	nop
 80a2160:	bf00      	nop
 80a2162:	bf00      	nop
 80a2164:	bf00      	nop
 80a2166:	bf00      	nop
 80a2168:	bf00      	nop
 80a216a:	bf00      	nop
 80a216c:	bf00      	nop
 80a216e:	bf00      	nop
 80a2170:	bf00      	nop
 80a2172:	bf00      	nop
 80a2174:	bf00      	nop
 80a2176:	bf00      	nop
 80a2178:	bf00      	nop
 80a217a:	bf00      	nop
 80a217c:	bf00      	nop
 80a217e:	bf00      	nop
 80a2180:	bf00      	nop
 80a2182:	bf00      	nop
 80a2184:	bf00      	nop
 80a2186:	bf00      	nop
 80a2188:	bf00      	nop
 80a218a:	bf00      	nop
 80a218c:	bf00      	nop
          // TM1803 spec             680ns LOW
          // Pololu on Arduino      (meas. 1.024us)
          // This lib on Spark Core (meas. 680ns)
          // This lib on Photon     (meas. 684ns)
          pinSet(pin, LOW); // LOW
 80a218e:	79e3      	ldrb	r3, [r4, #7]
 80a2190:	6810      	ldr	r0, [r2, #0]
 80a2192:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2196:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a219a:	88bf      	ldrh	r7, [r7, #4]
 80a219c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a21a0:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a21a2:	4600      	mov	r0, r0
 80a21a4:	bf00      	nop
 80a21a6:	bf00      	nop
 80a21a8:	bf00      	nop
 80a21aa:	bf00      	nop
 80a21ac:	bf00      	nop
 80a21ae:	bf00      	nop
 80a21b0:	bf00      	nop
 80a21b2:	bf00      	nop
 80a21b4:	bf00      	nop
 80a21b6:	bf00      	nop
 80a21b8:	bf00      	nop
 80a21ba:	bf00      	nop
 80a21bc:	bf00      	nop
 80a21be:	bf00      	nop
 80a21c0:	bf00      	nop
 80a21c2:	bf00      	nop
 80a21c4:	bf00      	nop
 80a21c6:	bf00      	nop
 80a21c8:	bf00      	nop
 80a21ca:	bf00      	nop
 80a21cc:	bf00      	nop
 80a21ce:	bf00      	nop
 80a21d0:	bf00      	nop
 80a21d2:	bf00      	nop
 80a21d4:	bf00      	nop
 80a21d6:	bf00      	nop
 80a21d8:	bf00      	nop
 80a21da:	bf00      	nop
 80a21dc:	bf00      	nop
 80a21de:	bf00      	nop
 80a21e0:	bf00      	nop
 80a21e2:	bf00      	nop
 80a21e4:	bf00      	nop
 80a21e6:	bf00      	nop
 80a21e8:	bf00      	nop
 80a21ea:	bf00      	nop
 80a21ec:	bf00      	nop
 80a21ee:	bf00      	nop
 80a21f0:	bf00      	nop
 80a21f2:	bf00      	nop
 80a21f4:	bf00      	nop
 80a21f6:	bf00      	nop
 80a21f8:	bf00      	nop
 80a21fa:	bf00      	nop
 80a21fc:	bf00      	nop
 80a21fe:	bf00      	nop
 80a2200:	bf00      	nop
 80a2202:	bf00      	nop
 80a2204:	bf00      	nop
 80a2206:	bf00      	nop
 80a2208:	bf00      	nop
 80a220a:	bf00      	nop
 80a220c:	bf00      	nop
 80a220e:	bf00      	nop
 80a2210:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a2212:	9b04      	ldr	r3, [sp, #16]
 80a2214:	085b      	lsrs	r3, r3, #1
 80a2216:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a2218:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a221c:	3301      	adds	r3, #1
 80a221e:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a2220:	2b17      	cmp	r3, #23
 80a2222:	f88d 3005 	strb.w	r3, [sp, #5]
 80a2226:	f200 80e3 	bhi.w	80a23f0 <_ZN17Adafruit_NeoPixel4showEv+0x1170>
        pinSet(pin, HIGH); // HIGH
 80a222a:	79e3      	ldrb	r3, [r4, #7]
 80a222c:	6810      	ldr	r0, [r2, #0]
 80a222e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2232:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2236:	88bf      	ldrh	r7, [r7, #4]
 80a2238:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a223c:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a223e:	9803      	ldr	r0, [sp, #12]
 80a2240:	9b04      	ldr	r3, [sp, #16]
 80a2242:	4218      	tst	r0, r3
 80a2244:	f47f af12 	bne.w	80a206c <_ZN17Adafruit_NeoPixel4showEv+0xdec>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2248:	4600      	mov	r0, r0
 80a224a:	bf00      	nop
 80a224c:	bf00      	nop
 80a224e:	bf00      	nop
 80a2250:	bf00      	nop
 80a2252:	bf00      	nop
 80a2254:	bf00      	nop
 80a2256:	bf00      	nop
 80a2258:	bf00      	nop
 80a225a:	bf00      	nop
 80a225c:	bf00      	nop
 80a225e:	bf00      	nop
 80a2260:	bf00      	nop
 80a2262:	bf00      	nop
 80a2264:	bf00      	nop
 80a2266:	bf00      	nop
 80a2268:	bf00      	nop
 80a226a:	bf00      	nop
 80a226c:	bf00      	nop
 80a226e:	bf00      	nop
 80a2270:	bf00      	nop
 80a2272:	bf00      	nop
 80a2274:	bf00      	nop
 80a2276:	bf00      	nop
 80a2278:	bf00      	nop
 80a227a:	bf00      	nop
 80a227c:	bf00      	nop
 80a227e:	bf00      	nop
 80a2280:	bf00      	nop
 80a2282:	bf00      	nop
 80a2284:	bf00      	nop
 80a2286:	bf00      	nop
 80a2288:	bf00      	nop
 80a228a:	bf00      	nop
 80a228c:	bf00      	nop
 80a228e:	bf00      	nop
 80a2290:	bf00      	nop
 80a2292:	bf00      	nop
 80a2294:	bf00      	nop
 80a2296:	bf00      	nop
 80a2298:	bf00      	nop
 80a229a:	bf00      	nop
 80a229c:	bf00      	nop
 80a229e:	bf00      	nop
 80a22a0:	bf00      	nop
 80a22a2:	bf00      	nop
 80a22a4:	bf00      	nop
 80a22a6:	bf00      	nop
 80a22a8:	bf00      	nop
 80a22aa:	bf00      	nop
 80a22ac:	bf00      	nop
 80a22ae:	bf00      	nop
 80a22b0:	bf00      	nop
 80a22b2:	bf00      	nop
 80a22b4:	bf00      	nop
 80a22b6:	bf00      	nop
 80a22b8:	bf00      	nop
 80a22ba:	bf00      	nop
 80a22bc:	bf00      	nop
 80a22be:	bf00      	nop
 80a22c0:	bf00      	nop
 80a22c2:	bf00      	nop
 80a22c4:	bf00      	nop
 80a22c6:	bf00      	nop
 80a22c8:	bf00      	nop
          // TM1803 spec             1.36us LOW
          // Pololu on Arduino      (meas. 2.00us)
          // This lib on Spark Core (meas. 1.36us)
          // This lib on Photon     (meas. 1.36us)
          pinSet(pin, LOW); // LOW
 80a22ca:	79e3      	ldrb	r3, [r4, #7]
 80a22cc:	6810      	ldr	r0, [r2, #0]
 80a22ce:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a22d2:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a22d6:	88bf      	ldrh	r7, [r7, #4]
 80a22d8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a22dc:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a22de:	4600      	mov	r0, r0
 80a22e0:	bf00      	nop
 80a22e2:	bf00      	nop
 80a22e4:	bf00      	nop
 80a22e6:	bf00      	nop
 80a22e8:	bf00      	nop
 80a22ea:	bf00      	nop
 80a22ec:	bf00      	nop
 80a22ee:	bf00      	nop
 80a22f0:	bf00      	nop
 80a22f2:	bf00      	nop
 80a22f4:	bf00      	nop
 80a22f6:	bf00      	nop
 80a22f8:	bf00      	nop
 80a22fa:	bf00      	nop
 80a22fc:	bf00      	nop
 80a22fe:	bf00      	nop
 80a2300:	bf00      	nop
 80a2302:	bf00      	nop
 80a2304:	bf00      	nop
 80a2306:	bf00      	nop
 80a2308:	bf00      	nop
 80a230a:	bf00      	nop
 80a230c:	bf00      	nop
 80a230e:	bf00      	nop
 80a2310:	bf00      	nop
 80a2312:	bf00      	nop
 80a2314:	bf00      	nop
 80a2316:	bf00      	nop
 80a2318:	bf00      	nop
 80a231a:	bf00      	nop
 80a231c:	bf00      	nop
 80a231e:	bf00      	nop
 80a2320:	bf00      	nop
 80a2322:	bf00      	nop
 80a2324:	bf00      	nop
 80a2326:	bf00      	nop
 80a2328:	bf00      	nop
 80a232a:	bf00      	nop
 80a232c:	bf00      	nop
 80a232e:	bf00      	nop
 80a2330:	bf00      	nop
 80a2332:	bf00      	nop
 80a2334:	bf00      	nop
 80a2336:	bf00      	nop
 80a2338:	bf00      	nop
 80a233a:	bf00      	nop
 80a233c:	bf00      	nop
 80a233e:	bf00      	nop
 80a2340:	bf00      	nop
 80a2342:	bf00      	nop
 80a2344:	bf00      	nop
 80a2346:	bf00      	nop
 80a2348:	bf00      	nop
 80a234a:	bf00      	nop
 80a234c:	bf00      	nop
 80a234e:	bf00      	nop
 80a2350:	bf00      	nop
 80a2352:	bf00      	nop
 80a2354:	bf00      	nop
 80a2356:	bf00      	nop
 80a2358:	bf00      	nop
 80a235a:	bf00      	nop
 80a235c:	bf00      	nop
 80a235e:	bf00      	nop
 80a2360:	bf00      	nop
 80a2362:	bf00      	nop
 80a2364:	bf00      	nop
 80a2366:	bf00      	nop
 80a2368:	bf00      	nop
 80a236a:	bf00      	nop
 80a236c:	bf00      	nop
 80a236e:	bf00      	nop
 80a2370:	bf00      	nop
 80a2372:	bf00      	nop
 80a2374:	bf00      	nop
 80a2376:	bf00      	nop
 80a2378:	bf00      	nop
 80a237a:	bf00      	nop
 80a237c:	bf00      	nop
 80a237e:	bf00      	nop
 80a2380:	bf00      	nop
 80a2382:	bf00      	nop
 80a2384:	bf00      	nop
 80a2386:	bf00      	nop
 80a2388:	bf00      	nop
 80a238a:	bf00      	nop
 80a238c:	bf00      	nop
 80a238e:	bf00      	nop
 80a2390:	bf00      	nop
 80a2392:	bf00      	nop
 80a2394:	bf00      	nop
 80a2396:	bf00      	nop
 80a2398:	bf00      	nop
 80a239a:	bf00      	nop
 80a239c:	bf00      	nop
 80a239e:	bf00      	nop
 80a23a0:	bf00      	nop
 80a23a2:	bf00      	nop
 80a23a4:	bf00      	nop
 80a23a6:	bf00      	nop
 80a23a8:	bf00      	nop
 80a23aa:	bf00      	nop
 80a23ac:	bf00      	nop
 80a23ae:	bf00      	nop
 80a23b0:	bf00      	nop
 80a23b2:	bf00      	nop
 80a23b4:	bf00      	nop
 80a23b6:	bf00      	nop
 80a23b8:	bf00      	nop
 80a23ba:	bf00      	nop
 80a23bc:	bf00      	nop
 80a23be:	bf00      	nop
 80a23c0:	bf00      	nop
 80a23c2:	bf00      	nop
 80a23c4:	bf00      	nop
 80a23c6:	bf00      	nop
 80a23c8:	bf00      	nop
 80a23ca:	bf00      	nop
 80a23cc:	bf00      	nop
 80a23ce:	bf00      	nop
 80a23d0:	bf00      	nop
 80a23d2:	bf00      	nop
 80a23d4:	bf00      	nop
 80a23d6:	bf00      	nop
 80a23d8:	bf00      	nop
 80a23da:	bf00      	nop
 80a23dc:	bf00      	nop
 80a23de:	bf00      	nop
 80a23e0:	bf00      	nop
 80a23e2:	bf00      	nop
 80a23e4:	bf00      	nop
 80a23e6:	bf00      	nop
 80a23e8:	bf00      	nop
 80a23ea:	bf00      	nop
 80a23ec:	bf00      	nop
 80a23ee:	e710      	b.n	80a2212 <_ZN17Adafruit_NeoPixel4showEv+0xf92>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a23f0:	468e      	mov	lr, r1
 80a23f2:	e60d      	b.n	80a2010 <_ZN17Adafruit_NeoPixel4showEv+0xd90>

080a23f4 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>:
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a23f4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a23f6:	8844      	ldrh	r4, [r0, #2]
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a23f8:	f89d 5014 	ldrb.w	r5, [sp, #20]
  if(n < numLEDs) {
 80a23fc:	428c      	cmp	r4, r1
 80a23fe:	d927      	bls.n	80a2450 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x5c>
    if(brightness) { // See notes in setBrightness()
 80a2400:	7a04      	ldrb	r4, [r0, #8]
 80a2402:	b144      	cbz	r4, 80a2416 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x22>
      r = (r * brightness) >> 8;
 80a2404:	4362      	muls	r2, r4
      g = (g * brightness) >> 8;
 80a2406:	4363      	muls	r3, r4
      b = (b * brightness) >> 8;
 80a2408:	436c      	muls	r4, r5
// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
  if(n < numLEDs) {
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
 80a240a:	f3c2 2207 	ubfx	r2, r2, #8, #8
      g = (g * brightness) >> 8;
 80a240e:	f3c3 2307 	ubfx	r3, r3, #8, #8
      b = (b * brightness) >> 8;
 80a2412:	f3c4 2507 	ubfx	r5, r4, #8, #8
    }
    uint8_t *p = &pixels[n * 3];
    switch(type) {
 80a2416:	7987      	ldrb	r7, [r0, #6]
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
      g = (g * brightness) >> 8;
      b = (b * brightness) >> 8;
    }
    uint8_t *p = &pixels[n * 3];
 80a2418:	68c6      	ldr	r6, [r0, #12]
 80a241a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a241e:	2f08      	cmp	r7, #8
 80a2420:	eb06 0401 	add.w	r4, r6, r1
 80a2424:	d811      	bhi.n	80a244a <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
 80a2426:	2001      	movs	r0, #1
 80a2428:	40b8      	lsls	r0, r7
 80a242a:	f410 7fd2 	tst.w	r0, #420	; 0x1a4
 80a242e:	d108      	bne.n	80a2442 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x4e>
 80a2430:	06c0      	lsls	r0, r0, #27
 80a2432:	d50a      	bpl.n	80a244a <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
          *p++ = g;
          *p++ = r;
          *p = b;
        } break;
      case TM1829: { // TM1829 is special RBG order
          if(r == 255) r = 254; // 255 on RED channel causes display to be in a special mode.
 80a2434:	2aff      	cmp	r2, #255	; 0xff
 80a2436:	bf08      	it	eq
 80a2438:	22fe      	moveq	r2, #254	; 0xfe
          *p++ = r;
 80a243a:	5472      	strb	r2, [r6, r1]
          *p++ = b;
 80a243c:	7065      	strb	r5, [r4, #1]
          *p = g;
 80a243e:	70a3      	strb	r3, [r4, #2]
 80a2440:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(type) {
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a2442:	5473      	strb	r3, [r6, r1]
          *p++ = r;
 80a2444:	7062      	strb	r2, [r4, #1]
          *p = b;
 80a2446:	70a5      	strb	r5, [r4, #2]
 80a2448:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p = g;
        } break;
      case WS2811: // WS2811 is RGB order
      case TM1803: // TM1803 is RGB order
      default: {   // default is RGB order
          *p++ = r;
 80a244a:	5472      	strb	r2, [r6, r1]
          *p++ = g;
 80a244c:	7063      	strb	r3, [r4, #1]
          *p = b;
 80a244e:	70a5      	strb	r5, [r4, #2]
 80a2450:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a2454 <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a2454:	b508      	push	{r3, lr}
 80a2456:	f000 f84f 	bl	80a24f8 <HAL_Pin_Map>

#if PLATFORM_ID == 0 // Core (0)
  #define pinLO(_pin) (PIN_MAP[_pin].gpio_peripheral->BRR = PIN_MAP[_pin].gpio_pin)
  #define pinHI(_pin) (PIN_MAP[_pin].gpio_peripheral->BSRR = PIN_MAP[_pin].gpio_pin)
#elif (PLATFORM_ID == 6) || (PLATFORM_ID == 8) || (PLATFORM_ID == 10) || (PLATFORM_ID == 88) // Photon (6), P1 (8), Electron (10) or Redbear Duo (88)
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a245a:	f000 f84d 	bl	80a24f8 <HAL_Pin_Map>
 80a245e:	4b01      	ldr	r3, [pc, #4]	; (80a2464 <_GLOBAL__sub_I_PIN_MAP2+0x10>)
 80a2460:	6018      	str	r0, [r3, #0]
 80a2462:	bd08      	pop	{r3, pc}
 80a2464:	20000468 	.word	0x20000468

080a2468 <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a2468:	b508      	push	{r3, lr}
 80a246a:	4b02      	ldr	r3, [pc, #8]	; (80a2474 <os_mutex_create+0xc>)
 80a246c:	681b      	ldr	r3, [r3, #0]
 80a246e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2470:	9301      	str	r3, [sp, #4]
 80a2472:	bd08      	pop	{r3, pc}
 80a2474:	080601d0 	.word	0x080601d0

080a2478 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a2478:	b508      	push	{r3, lr}
 80a247a:	4b02      	ldr	r3, [pc, #8]	; (80a2484 <os_mutex_recursive_create+0xc>)
 80a247c:	681b      	ldr	r3, [r3, #0]
 80a247e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a2480:	9301      	str	r3, [sp, #4]
 80a2482:	bd08      	pop	{r3, pc}
 80a2484:	080601d0 	.word	0x080601d0

080a2488 <os_mutex_recursive_lock>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
 80a2488:	b508      	push	{r3, lr}
 80a248a:	4b02      	ldr	r3, [pc, #8]	; (80a2494 <os_mutex_recursive_lock+0xc>)
 80a248c:	681b      	ldr	r3, [r3, #0]
 80a248e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a2490:	9301      	str	r3, [sp, #4]
 80a2492:	bd08      	pop	{r3, pc}
 80a2494:	080601d0 	.word	0x080601d0

080a2498 <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
 80a2498:	b508      	push	{r3, lr}
 80a249a:	4b02      	ldr	r3, [pc, #8]	; (80a24a4 <os_mutex_recursive_unlock+0xc>)
 80a249c:	681b      	ldr	r3, [r3, #0]
 80a249e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a24a0:	9301      	str	r3, [sp, #4]
 80a24a2:	bd08      	pop	{r3, pc}
 80a24a4:	080601d0 	.word	0x080601d0

080a24a8 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a24a8:	b508      	push	{r3, lr}
 80a24aa:	4b02      	ldr	r3, [pc, #8]	; (80a24b4 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a24ac:	681b      	ldr	r3, [r3, #0]
 80a24ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a24b0:	9301      	str	r3, [sp, #4]
 80a24b2:	bd08      	pop	{r3, pc}
 80a24b4:	080601b8 	.word	0x080601b8

080a24b8 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a24b8:	b508      	push	{r3, lr}
 80a24ba:	4b02      	ldr	r3, [pc, #8]	; (80a24c4 <HAL_RNG_GetRandomNumber+0xc>)
 80a24bc:	681b      	ldr	r3, [r3, #0]
 80a24be:	685b      	ldr	r3, [r3, #4]
 80a24c0:	9301      	str	r3, [sp, #4]
 80a24c2:	bd08      	pop	{r3, pc}
 80a24c4:	0806019c 	.word	0x0806019c

080a24c8 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a24c8:	b508      	push	{r3, lr}
 80a24ca:	4b02      	ldr	r3, [pc, #8]	; (80a24d4 <HAL_Delay_Microseconds+0xc>)
 80a24cc:	681b      	ldr	r3, [r3, #0]
 80a24ce:	68db      	ldr	r3, [r3, #12]
 80a24d0:	9301      	str	r3, [sp, #4]
 80a24d2:	bd08      	pop	{r3, pc}
 80a24d4:	0806019c 	.word	0x0806019c

080a24d8 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a24d8:	b508      	push	{r3, lr}
 80a24da:	4b02      	ldr	r3, [pc, #8]	; (80a24e4 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a24dc:	681b      	ldr	r3, [r3, #0]
 80a24de:	691b      	ldr	r3, [r3, #16]
 80a24e0:	9301      	str	r3, [sp, #4]
 80a24e2:	bd08      	pop	{r3, pc}
 80a24e4:	0806019c 	.word	0x0806019c

080a24e8 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a24e8:	b508      	push	{r3, lr}
 80a24ea:	4b02      	ldr	r3, [pc, #8]	; (80a24f4 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a24ec:	681b      	ldr	r3, [r3, #0]
 80a24ee:	695b      	ldr	r3, [r3, #20]
 80a24f0:	9301      	str	r3, [sp, #4]
 80a24f2:	bd08      	pop	{r3, pc}
 80a24f4:	0806019c 	.word	0x0806019c

080a24f8 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a24f8:	b508      	push	{r3, lr}
 80a24fa:	4b02      	ldr	r3, [pc, #8]	; (80a2504 <HAL_Pin_Map+0xc>)
 80a24fc:	681b      	ldr	r3, [r3, #0]
 80a24fe:	681b      	ldr	r3, [r3, #0]
 80a2500:	9301      	str	r3, [sp, #4]
 80a2502:	bd08      	pop	{r3, pc}
 80a2504:	080601b0 	.word	0x080601b0

080a2508 <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a2508:	b508      	push	{r3, lr}
 80a250a:	4b02      	ldr	r3, [pc, #8]	; (80a2514 <HAL_Validate_Pin_Function+0xc>)
 80a250c:	681b      	ldr	r3, [r3, #0]
 80a250e:	685b      	ldr	r3, [r3, #4]
 80a2510:	9301      	str	r3, [sp, #4]
 80a2512:	bd08      	pop	{r3, pc}
 80a2514:	080601b0 	.word	0x080601b0

080a2518 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a2518:	b508      	push	{r3, lr}
 80a251a:	4b02      	ldr	r3, [pc, #8]	; (80a2524 <HAL_Pin_Mode+0xc>)
 80a251c:	681b      	ldr	r3, [r3, #0]
 80a251e:	689b      	ldr	r3, [r3, #8]
 80a2520:	9301      	str	r3, [sp, #4]
 80a2522:	bd08      	pop	{r3, pc}
 80a2524:	080601b0 	.word	0x080601b0

080a2528 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a2528:	b508      	push	{r3, lr}
 80a252a:	4b02      	ldr	r3, [pc, #8]	; (80a2534 <HAL_Get_Pin_Mode+0xc>)
 80a252c:	681b      	ldr	r3, [r3, #0]
 80a252e:	68db      	ldr	r3, [r3, #12]
 80a2530:	9301      	str	r3, [sp, #4]
 80a2532:	bd08      	pop	{r3, pc}
 80a2534:	080601b0 	.word	0x080601b0

080a2538 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a2538:	b508      	push	{r3, lr}
 80a253a:	4b02      	ldr	r3, [pc, #8]	; (80a2544 <HAL_GPIO_Write+0xc>)
 80a253c:	681b      	ldr	r3, [r3, #0]
 80a253e:	691b      	ldr	r3, [r3, #16]
 80a2540:	9301      	str	r3, [sp, #4]
 80a2542:	bd08      	pop	{r3, pc}
 80a2544:	080601b0 	.word	0x080601b0

080a2548 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a2548:	b508      	push	{r3, lr}
 80a254a:	4b02      	ldr	r3, [pc, #8]	; (80a2554 <HAL_GPIO_Read+0xc>)
 80a254c:	681b      	ldr	r3, [r3, #0]
 80a254e:	695b      	ldr	r3, [r3, #20]
 80a2550:	9301      	str	r3, [sp, #4]
 80a2552:	bd08      	pop	{r3, pc}
 80a2554:	080601b0 	.word	0x080601b0

080a2558 <HAL_DAC_Write>:
DYNALIB_FN(6, hal_gpio, HAL_Interrupts_Attach, void(uint16_t, HAL_InterruptHandler, void*, InterruptMode, HAL_InterruptExtraConfiguration*))
DYNALIB_FN(7, hal_gpio, HAL_Interrupts_Detach, void(uint16_t))
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
 80a2558:	b508      	push	{r3, lr}
 80a255a:	4b02      	ldr	r3, [pc, #8]	; (80a2564 <HAL_DAC_Write+0xc>)
 80a255c:	681b      	ldr	r3, [r3, #0]
 80a255e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a2560:	9301      	str	r3, [sp, #4]
 80a2562:	bd08      	pop	{r3, pc}
 80a2564:	080601b0 	.word	0x080601b0

080a2568 <HAL_ADC_Read>:
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))
 80a2568:	b508      	push	{r3, lr}
 80a256a:	4b02      	ldr	r3, [pc, #8]	; (80a2574 <HAL_ADC_Read+0xc>)
 80a256c:	681b      	ldr	r3, [r3, #0]
 80a256e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2570:	9301      	str	r3, [sp, #4]
 80a2572:	bd08      	pop	{r3, pc}
 80a2574:	080601b0 	.word	0x080601b0

080a2578 <HAL_PWM_Write_Ext>:
DYNALIB_FN(25, hal_gpio, HAL_DAC_Get_Resolution, uint8_t(pin_t))
DYNALIB_FN(26, hal_gpio, HAL_DAC_Set_Resolution, void(pin_t, uint8_t))
DYNALIB_FN(27, hal_gpio, HAL_DAC_Enable_Buffer, void(pin_t pin, uint8_t state))
DYNALIB_FN(28, hal_gpio, HAL_PWM_Get_Resolution, uint8_t(uint16_t))
DYNALIB_FN(29, hal_gpio, HAL_PWM_Set_Resolution, void(uint16_t, uint8_t))
DYNALIB_FN(30, hal_gpio, HAL_PWM_Write_Ext, void(uint16_t, uint32_t))
 80a2578:	b508      	push	{r3, lr}
 80a257a:	4b02      	ldr	r3, [pc, #8]	; (80a2584 <HAL_PWM_Write_Ext+0xc>)
 80a257c:	681b      	ldr	r3, [r3, #0]
 80a257e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80a2580:	9301      	str	r3, [sp, #4]
 80a2582:	bd08      	pop	{r3, pc}
 80a2584:	080601b0 	.word	0x080601b0

080a2588 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a2588:	b508      	push	{r3, lr}
 80a258a:	4b02      	ldr	r3, [pc, #8]	; (80a2594 <HAL_I2C_Write_Data+0xc>)
 80a258c:	681b      	ldr	r3, [r3, #0]
 80a258e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a2590:	9301      	str	r3, [sp, #4]
 80a2592:	bd08      	pop	{r3, pc}
 80a2594:	080601ac 	.word	0x080601ac

080a2598 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a2598:	b508      	push	{r3, lr}
 80a259a:	4b02      	ldr	r3, [pc, #8]	; (80a25a4 <HAL_I2C_Available_Data+0xc>)
 80a259c:	681b      	ldr	r3, [r3, #0]
 80a259e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a25a0:	9301      	str	r3, [sp, #4]
 80a25a2:	bd08      	pop	{r3, pc}
 80a25a4:	080601ac 	.word	0x080601ac

080a25a8 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a25a8:	b508      	push	{r3, lr}
 80a25aa:	4b02      	ldr	r3, [pc, #8]	; (80a25b4 <HAL_I2C_Read_Data+0xc>)
 80a25ac:	681b      	ldr	r3, [r3, #0]
 80a25ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a25b0:	9301      	str	r3, [sp, #4]
 80a25b2:	bd08      	pop	{r3, pc}
 80a25b4:	080601ac 	.word	0x080601ac

080a25b8 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a25b8:	b508      	push	{r3, lr}
 80a25ba:	4b02      	ldr	r3, [pc, #8]	; (80a25c4 <HAL_I2C_Peek_Data+0xc>)
 80a25bc:	681b      	ldr	r3, [r3, #0]
 80a25be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a25c0:	9301      	str	r3, [sp, #4]
 80a25c2:	bd08      	pop	{r3, pc}
 80a25c4:	080601ac 	.word	0x080601ac

080a25c8 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a25c8:	b508      	push	{r3, lr}
 80a25ca:	4b02      	ldr	r3, [pc, #8]	; (80a25d4 <HAL_I2C_Flush_Data+0xc>)
 80a25cc:	681b      	ldr	r3, [r3, #0]
 80a25ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a25d0:	9301      	str	r3, [sp, #4]
 80a25d2:	bd08      	pop	{r3, pc}
 80a25d4:	080601ac 	.word	0x080601ac

080a25d8 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a25d8:	b508      	push	{r3, lr}
 80a25da:	4b02      	ldr	r3, [pc, #8]	; (80a25e4 <HAL_I2C_Is_Enabled+0xc>)
 80a25dc:	681b      	ldr	r3, [r3, #0]
 80a25de:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a25e0:	9301      	str	r3, [sp, #4]
 80a25e2:	bd08      	pop	{r3, pc}
 80a25e4:	080601ac 	.word	0x080601ac

080a25e8 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a25e8:	b508      	push	{r3, lr}
 80a25ea:	4b03      	ldr	r3, [pc, #12]	; (80a25f8 <HAL_I2C_Init+0x10>)
 80a25ec:	681b      	ldr	r3, [r3, #0]
 80a25ee:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a25f2:	9301      	str	r3, [sp, #4]
 80a25f4:	bd08      	pop	{r3, pc}
 80a25f6:	0000      	.short	0x0000
 80a25f8:	080601ac 	.word	0x080601ac

080a25fc <socket_active_status>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
 80a25fc:	b508      	push	{r3, lr}
 80a25fe:	4b02      	ldr	r3, [pc, #8]	; (80a2608 <socket_active_status+0xc>)
 80a2600:	681b      	ldr	r3, [r3, #0]
 80a2602:	681b      	ldr	r3, [r3, #0]
 80a2604:	9301      	str	r3, [sp, #4]
 80a2606:	bd08      	pop	{r3, pc}
 80a2608:	080601bc 	.word	0x080601bc

080a260c <socket_handle_valid>:
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a260c:	b508      	push	{r3, lr}
 80a260e:	4b02      	ldr	r3, [pc, #8]	; (80a2618 <socket_handle_valid+0xc>)
 80a2610:	681b      	ldr	r3, [r3, #0]
 80a2612:	685b      	ldr	r3, [r3, #4]
 80a2614:	9301      	str	r3, [sp, #4]
 80a2616:	bd08      	pop	{r3, pc}
 80a2618:	080601bc 	.word	0x080601bc

080a261c <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a261c:	b508      	push	{r3, lr}
 80a261e:	4b02      	ldr	r3, [pc, #8]	; (80a2628 <socket_create+0xc>)
 80a2620:	681b      	ldr	r3, [r3, #0]
 80a2622:	689b      	ldr	r3, [r3, #8]
 80a2624:	9301      	str	r3, [sp, #4]
 80a2626:	bd08      	pop	{r3, pc}
 80a2628:	080601bc 	.word	0x080601bc

080a262c <socket_connect>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
 80a262c:	b508      	push	{r3, lr}
 80a262e:	4b02      	ldr	r3, [pc, #8]	; (80a2638 <socket_connect+0xc>)
 80a2630:	681b      	ldr	r3, [r3, #0]
 80a2632:	68db      	ldr	r3, [r3, #12]
 80a2634:	9301      	str	r3, [sp, #4]
 80a2636:	bd08      	pop	{r3, pc}
 80a2638:	080601bc 	.word	0x080601bc

080a263c <socket_receive>:
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
 80a263c:	b508      	push	{r3, lr}
 80a263e:	4b02      	ldr	r3, [pc, #8]	; (80a2648 <socket_receive+0xc>)
 80a2640:	681b      	ldr	r3, [r3, #0]
 80a2642:	691b      	ldr	r3, [r3, #16]
 80a2644:	9301      	str	r3, [sp, #4]
 80a2646:	bd08      	pop	{r3, pc}
 80a2648:	080601bc 	.word	0x080601bc

080a264c <socket_close>:
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a264c:	b508      	push	{r3, lr}
 80a264e:	4b02      	ldr	r3, [pc, #8]	; (80a2658 <socket_close+0xc>)
 80a2650:	681b      	ldr	r3, [r3, #0]
 80a2652:	6a1b      	ldr	r3, [r3, #32]
 80a2654:	9301      	str	r3, [sp, #4]
 80a2656:	bd08      	pop	{r3, pc}
 80a2658:	080601bc 	.word	0x080601bc

080a265c <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a265c:	b508      	push	{r3, lr}
 80a265e:	4b02      	ldr	r3, [pc, #8]	; (80a2668 <socket_handle_invalid+0xc>)
 80a2660:	681b      	ldr	r3, [r3, #0]
 80a2662:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2664:	9301      	str	r3, [sp, #4]
 80a2666:	bd08      	pop	{r3, pc}
 80a2668:	080601bc 	.word	0x080601bc

080a266c <socket_send_ex>:
DYNALIB_FN(13, hal_socket, socket_join_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(14, hal_socket, socket_leave_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(15, hal_socket, socket_peer, sock_result_t(sock_handle_t, sock_peer_t*, void*))
DYNALIB_FN(16, hal_socket, socket_shutdown, sock_result_t(sock_handle_t, int))
DYNALIB_FN(17, hal_socket, socket_send_ex, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, system_tick_t, void*))
 80a266c:	b508      	push	{r3, lr}
 80a266e:	4b02      	ldr	r3, [pc, #8]	; (80a2678 <socket_send_ex+0xc>)
 80a2670:	681b      	ldr	r3, [r3, #0]
 80a2672:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a2674:	9301      	str	r3, [sp, #4]
 80a2676:	bd08      	pop	{r3, pc}
 80a2678:	080601bc 	.word	0x080601bc

080a267c <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a267c:	b508      	push	{r3, lr}
 80a267e:	4b02      	ldr	r3, [pc, #8]	; (80a2688 <HAL_SPI_Init+0xc>)
 80a2680:	681b      	ldr	r3, [r3, #0]
 80a2682:	69db      	ldr	r3, [r3, #28]
 80a2684:	9301      	str	r3, [sp, #4]
 80a2686:	bd08      	pop	{r3, pc}
 80a2688:	080601b4 	.word	0x080601b4

080a268c <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a268c:	b508      	push	{r3, lr}
 80a268e:	4b02      	ldr	r3, [pc, #8]	; (80a2698 <HAL_SPI_Is_Enabled+0xc>)
 80a2690:	681b      	ldr	r3, [r3, #0]
 80a2692:	6a1b      	ldr	r3, [r3, #32]
 80a2694:	9301      	str	r3, [sp, #4]
 80a2696:	bd08      	pop	{r3, pc}
 80a2698:	080601b4 	.word	0x080601b4

080a269c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a269c:	b508      	push	{r3, lr}
 80a269e:	4b02      	ldr	r3, [pc, #8]	; (80a26a8 <HAL_USART_Init+0xc>)
 80a26a0:	681b      	ldr	r3, [r3, #0]
 80a26a2:	699b      	ldr	r3, [r3, #24]
 80a26a4:	9301      	str	r3, [sp, #4]
 80a26a6:	bd08      	pop	{r3, pc}
 80a26a8:	080601c4 	.word	0x080601c4

080a26ac <HAL_USART_End>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
 80a26ac:	b508      	push	{r3, lr}
 80a26ae:	4b02      	ldr	r3, [pc, #8]	; (80a26b8 <HAL_USART_End+0xc>)
 80a26b0:	681b      	ldr	r3, [r3, #0]
 80a26b2:	6a1b      	ldr	r3, [r3, #32]
 80a26b4:	9301      	str	r3, [sp, #4]
 80a26b6:	bd08      	pop	{r3, pc}
 80a26b8:	080601c4 	.word	0x080601c4

080a26bc <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a26bc:	b508      	push	{r3, lr}
 80a26be:	4b02      	ldr	r3, [pc, #8]	; (80a26c8 <HAL_USART_Write_Data+0xc>)
 80a26c0:	681b      	ldr	r3, [r3, #0]
 80a26c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a26c4:	9301      	str	r3, [sp, #4]
 80a26c6:	bd08      	pop	{r3, pc}
 80a26c8:	080601c4 	.word	0x080601c4

080a26cc <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a26cc:	b508      	push	{r3, lr}
 80a26ce:	4b02      	ldr	r3, [pc, #8]	; (80a26d8 <HAL_USART_Available_Data+0xc>)
 80a26d0:	681b      	ldr	r3, [r3, #0]
 80a26d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a26d4:	9301      	str	r3, [sp, #4]
 80a26d6:	bd08      	pop	{r3, pc}
 80a26d8:	080601c4 	.word	0x080601c4

080a26dc <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a26dc:	b508      	push	{r3, lr}
 80a26de:	4b02      	ldr	r3, [pc, #8]	; (80a26e8 <HAL_USART_Read_Data+0xc>)
 80a26e0:	681b      	ldr	r3, [r3, #0]
 80a26e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a26e4:	9301      	str	r3, [sp, #4]
 80a26e6:	bd08      	pop	{r3, pc}
 80a26e8:	080601c4 	.word	0x080601c4

080a26ec <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a26ec:	b508      	push	{r3, lr}
 80a26ee:	4b02      	ldr	r3, [pc, #8]	; (80a26f8 <HAL_USART_Peek_Data+0xc>)
 80a26f0:	681b      	ldr	r3, [r3, #0]
 80a26f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a26f4:	9301      	str	r3, [sp, #4]
 80a26f6:	bd08      	pop	{r3, pc}
 80a26f8:	080601c4 	.word	0x080601c4

080a26fc <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a26fc:	b508      	push	{r3, lr}
 80a26fe:	4b02      	ldr	r3, [pc, #8]	; (80a2708 <HAL_USART_Flush_Data+0xc>)
 80a2700:	681b      	ldr	r3, [r3, #0]
 80a2702:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a2704:	9301      	str	r3, [sp, #4]
 80a2706:	bd08      	pop	{r3, pc}
 80a2708:	080601c4 	.word	0x080601c4

080a270c <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a270c:	b508      	push	{r3, lr}
 80a270e:	4b02      	ldr	r3, [pc, #8]	; (80a2718 <HAL_USART_Is_Enabled+0xc>)
 80a2710:	681b      	ldr	r3, [r3, #0]
 80a2712:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a2714:	9301      	str	r3, [sp, #4]
 80a2716:	bd08      	pop	{r3, pc}
 80a2718:	080601c4 	.word	0x080601c4

080a271c <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a271c:	b508      	push	{r3, lr}
 80a271e:	4b02      	ldr	r3, [pc, #8]	; (80a2728 <HAL_USART_Available_Data_For_Write+0xc>)
 80a2720:	681b      	ldr	r3, [r3, #0]
 80a2722:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a2724:	9301      	str	r3, [sp, #4]
 80a2726:	bd08      	pop	{r3, pc}
 80a2728:	080601c4 	.word	0x080601c4

080a272c <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, HAL_USART_BeginConfig, void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a272c:	b508      	push	{r3, lr}
 80a272e:	4b02      	ldr	r3, [pc, #8]	; (80a2738 <HAL_USART_BeginConfig+0xc>)
 80a2730:	681b      	ldr	r3, [r3, #0]
 80a2732:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a2734:	9301      	str	r3, [sp, #4]
 80a2736:	bd08      	pop	{r3, pc}
 80a2738:	080601c4 	.word	0x080601c4

080a273c <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a273c:	b508      	push	{r3, lr}
 80a273e:	4b02      	ldr	r3, [pc, #8]	; (80a2748 <HAL_USB_USART_Init+0xc>)
 80a2740:	681b      	ldr	r3, [r3, #0]
 80a2742:	681b      	ldr	r3, [r3, #0]
 80a2744:	9301      	str	r3, [sp, #4]
 80a2746:	bd08      	pop	{r3, pc}
 80a2748:	080601d8 	.word	0x080601d8

080a274c <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a274c:	b508      	push	{r3, lr}
 80a274e:	4b02      	ldr	r3, [pc, #8]	; (80a2758 <HAL_USB_USART_Begin+0xc>)
 80a2750:	681b      	ldr	r3, [r3, #0]
 80a2752:	685b      	ldr	r3, [r3, #4]
 80a2754:	9301      	str	r3, [sp, #4]
 80a2756:	bd08      	pop	{r3, pc}
 80a2758:	080601d8 	.word	0x080601d8

080a275c <HAL_USB_USART_End>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
 80a275c:	b508      	push	{r3, lr}
 80a275e:	4b02      	ldr	r3, [pc, #8]	; (80a2768 <HAL_USB_USART_End+0xc>)
 80a2760:	681b      	ldr	r3, [r3, #0]
 80a2762:	689b      	ldr	r3, [r3, #8]
 80a2764:	9301      	str	r3, [sp, #4]
 80a2766:	bd08      	pop	{r3, pc}
 80a2768:	080601d8 	.word	0x080601d8

080a276c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a276c:	b508      	push	{r3, lr}
 80a276e:	4b02      	ldr	r3, [pc, #8]	; (80a2778 <HAL_USB_USART_Available_Data+0xc>)
 80a2770:	681b      	ldr	r3, [r3, #0]
 80a2772:	691b      	ldr	r3, [r3, #16]
 80a2774:	9301      	str	r3, [sp, #4]
 80a2776:	bd08      	pop	{r3, pc}
 80a2778:	080601d8 	.word	0x080601d8

080a277c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a277c:	b508      	push	{r3, lr}
 80a277e:	4b02      	ldr	r3, [pc, #8]	; (80a2788 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a2780:	681b      	ldr	r3, [r3, #0]
 80a2782:	695b      	ldr	r3, [r3, #20]
 80a2784:	9301      	str	r3, [sp, #4]
 80a2786:	bd08      	pop	{r3, pc}
 80a2788:	080601d8 	.word	0x080601d8

080a278c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a278c:	b508      	push	{r3, lr}
 80a278e:	4b02      	ldr	r3, [pc, #8]	; (80a2798 <HAL_USB_USART_Receive_Data+0xc>)
 80a2790:	681b      	ldr	r3, [r3, #0]
 80a2792:	699b      	ldr	r3, [r3, #24]
 80a2794:	9301      	str	r3, [sp, #4]
 80a2796:	bd08      	pop	{r3, pc}
 80a2798:	080601d8 	.word	0x080601d8

080a279c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a279c:	b508      	push	{r3, lr}
 80a279e:	4b02      	ldr	r3, [pc, #8]	; (80a27a8 <HAL_USB_USART_Send_Data+0xc>)
 80a27a0:	681b      	ldr	r3, [r3, #0]
 80a27a2:	69db      	ldr	r3, [r3, #28]
 80a27a4:	9301      	str	r3, [sp, #4]
 80a27a6:	bd08      	pop	{r3, pc}
 80a27a8:	080601d8 	.word	0x080601d8

080a27ac <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a27ac:	b508      	push	{r3, lr}
 80a27ae:	4b02      	ldr	r3, [pc, #8]	; (80a27b8 <HAL_USB_USART_Flush_Data+0xc>)
 80a27b0:	681b      	ldr	r3, [r3, #0]
 80a27b2:	6a1b      	ldr	r3, [r3, #32]
 80a27b4:	9301      	str	r3, [sp, #4]
 80a27b6:	bd08      	pop	{r3, pc}
 80a27b8:	080601d8 	.word	0x080601d8

080a27bc <HAL_NET_SetNetWatchDog>:

DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, void(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
 80a27bc:	b508      	push	{r3, lr}
 80a27be:	4b02      	ldr	r3, [pc, #8]	; (80a27c8 <HAL_NET_SetNetWatchDog+0xc>)
 80a27c0:	681b      	ldr	r3, [r3, #0]
 80a27c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a27c4:	9301      	str	r3, [sp, #4]
 80a27c6:	bd08      	pop	{r3, pc}
 80a27c8:	080601c0 	.word	0x080601c0

080a27cc <inet_gethostbyname>:
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a27cc:	b508      	push	{r3, lr}
 80a27ce:	4b02      	ldr	r3, [pc, #8]	; (80a27d8 <inet_gethostbyname+0xc>)
 80a27d0:	681b      	ldr	r3, [r3, #0]
 80a27d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a27d4:	9301      	str	r3, [sp, #4]
 80a27d6:	bd08      	pop	{r3, pc}
 80a27d8:	080601c0 	.word	0x080601c0

080a27dc <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a27dc:	b508      	push	{r3, lr}
 80a27de:	4b02      	ldr	r3, [pc, #8]	; (80a27e8 <panic_+0xc>)
 80a27e0:	681b      	ldr	r3, [r3, #0]
 80a27e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a27e4:	9301      	str	r3, [sp, #4]
 80a27e6:	bd08      	pop	{r3, pc}
 80a27e8:	080201a8 	.word	0x080201a8

080a27ec <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
 80a27ec:	b508      	push	{r3, lr}
 80a27ee:	4b02      	ldr	r3, [pc, #8]	; (80a27f8 <log_message+0xc>)
 80a27f0:	681b      	ldr	r3, [r3, #0]
 80a27f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80a27f4:	9301      	str	r3, [sp, #4]
 80a27f6:	bd08      	pop	{r3, pc}
 80a27f8:	080201a8 	.word	0x080201a8

080a27fc <log_message_v>:
DYNALIB_FN(21, services, log_message_v, void(int, const char*, LogAttributes*, void*, const char*, va_list))
 80a27fc:	b508      	push	{r3, lr}
 80a27fe:	4b02      	ldr	r3, [pc, #8]	; (80a2808 <log_message_v+0xc>)
 80a2800:	681b      	ldr	r3, [r3, #0]
 80a2802:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a2804:	9301      	str	r3, [sp, #4]
 80a2806:	bd08      	pop	{r3, pc}
 80a2808:	080201a8 	.word	0x080201a8

080a280c <log_level_name>:
DYNALIB_FN(22, services, log_write, void(int, const char*, const char*, size_t, void*))
DYNALIB_FN(23, services, log_printf, void(int, const char*, void*, const char*, ...))
DYNALIB_FN(24, services, log_printf_v, void(int, const char*, void*, const char*, va_list))
DYNALIB_FN(25, services, log_dump, void(int, const char*, const void*, size_t, int, void*))
DYNALIB_FN(26, services, log_enabled, int(int, const char*, void*))
DYNALIB_FN(27, services, log_level_name, const char*(int, void*))
 80a280c:	b508      	push	{r3, lr}
 80a280e:	4b02      	ldr	r3, [pc, #8]	; (80a2818 <log_level_name+0xc>)
 80a2810:	681b      	ldr	r3, [r3, #0]
 80a2812:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a2814:	9301      	str	r3, [sp, #4]
 80a2816:	bd08      	pop	{r3, pc}
 80a2818:	080201a8 	.word	0x080201a8

080a281c <log_set_callbacks>:
DYNALIB_FN(28, services, log_set_callbacks, void(log_message_callback_type, log_write_callback_type, log_enabled_callback_type, void*))
 80a281c:	b508      	push	{r3, lr}
 80a281e:	4b02      	ldr	r3, [pc, #8]	; (80a2828 <log_set_callbacks+0xc>)
 80a2820:	681b      	ldr	r3, [r3, #0]
 80a2822:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a2824:	9301      	str	r3, [sp, #4]
 80a2826:	bd08      	pop	{r3, pc}
 80a2828:	080201a8 	.word	0x080201a8

080a282c <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a282c:	b508      	push	{r3, lr}
 80a282e:	4b02      	ldr	r3, [pc, #8]	; (80a2838 <set_system_mode+0xc>)
 80a2830:	681b      	ldr	r3, [r3, #0]
 80a2832:	685b      	ldr	r3, [r3, #4]
 80a2834:	9301      	str	r3, [sp, #4]
 80a2836:	bd08      	pop	{r3, pc}
 80a2838:	080601a4 	.word	0x080601a4

080a283c <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a283c:	b508      	push	{r3, lr}
 80a283e:	4b02      	ldr	r3, [pc, #8]	; (80a2848 <system_delay_ms+0xc>)
 80a2840:	681b      	ldr	r3, [r3, #0]
 80a2842:	695b      	ldr	r3, [r3, #20]
 80a2844:	9301      	str	r3, [sp, #4]
 80a2846:	bd08      	pop	{r3, pc}
 80a2848:	080601a4 	.word	0x080601a4

080a284c <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a284c:	b508      	push	{r3, lr}
 80a284e:	4b03      	ldr	r3, [pc, #12]	; (80a285c <system_ctrl_set_app_request_handler+0x10>)
 80a2850:	681b      	ldr	r3, [r3, #0]
 80a2852:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a2856:	9301      	str	r3, [sp, #4]
 80a2858:	bd08      	pop	{r3, pc}
 80a285a:	0000      	.short	0x0000
 80a285c:	080601a4 	.word	0x080601a4

080a2860 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a2860:	b508      	push	{r3, lr}
 80a2862:	4b03      	ldr	r3, [pc, #12]	; (80a2870 <system_ctrl_set_result+0x10>)
 80a2864:	681b      	ldr	r3, [r3, #0]
 80a2866:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a286a:	9301      	str	r3, [sp, #4]
 80a286c:	bd08      	pop	{r3, pc}
 80a286e:	0000      	.short	0x0000
 80a2870:	080601a4 	.word	0x080601a4

080a2874 <spark_process>:

DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a2874:	b508      	push	{r3, lr}
 80a2876:	4b02      	ldr	r3, [pc, #8]	; (80a2880 <spark_process+0xc>)
 80a2878:	681b      	ldr	r3, [r3, #0]
 80a287a:	689b      	ldr	r3, [r3, #8]
 80a287c:	9301      	str	r3, [sp, #4]
 80a287e:	bd08      	pop	{r3, pc}
 80a2880:	080601cc 	.word	0x080601cc

080a2884 <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
 80a2884:	b508      	push	{r3, lr}
 80a2886:	4b02      	ldr	r3, [pc, #8]	; (80a2890 <spark_cloud_flag_connect+0xc>)
 80a2888:	681b      	ldr	r3, [r3, #0]
 80a288a:	68db      	ldr	r3, [r3, #12]
 80a288c:	9301      	str	r3, [sp, #4]
 80a288e:	bd08      	pop	{r3, pc}
 80a2890:	080601cc 	.word	0x080601cc

080a2894 <spark_cloud_flag_connected>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a2894:	b508      	push	{r3, lr}
 80a2896:	4b02      	ldr	r3, [pc, #8]	; (80a28a0 <spark_cloud_flag_connected+0xc>)
 80a2898:	681b      	ldr	r3, [r3, #0]
 80a289a:	695b      	ldr	r3, [r3, #20]
 80a289c:	9301      	str	r3, [sp, #4]
 80a289e:	bd08      	pop	{r3, pc}
 80a28a0:	080601cc 	.word	0x080601cc

080a28a4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a28a4:	b508      	push	{r3, lr}
 80a28a6:	4b02      	ldr	r3, [pc, #8]	; (80a28b0 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a28a8:	681b      	ldr	r3, [r3, #0]
 80a28aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a28ac:	9301      	str	r3, [sp, #4]
 80a28ae:	bd08      	pop	{r3, pc}
 80a28b0:	080601cc 	.word	0x080601cc

080a28b4 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a28b4:	b508      	push	{r3, lr}
 80a28b6:	4b02      	ldr	r3, [pc, #8]	; (80a28c0 <network_ready+0xc>)
 80a28b8:	681b      	ldr	r3, [r3, #0]
 80a28ba:	691b      	ldr	r3, [r3, #16]
 80a28bc:	9301      	str	r3, [sp, #4]
 80a28be:	bd08      	pop	{r3, pc}
 80a28c0:	080601c8 	.word	0x080601c8

080a28c4 <network_set_credentials>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
 80a28c4:	b508      	push	{r3, lr}
 80a28c6:	4b02      	ldr	r3, [pc, #8]	; (80a28d0 <network_set_credentials+0xc>)
 80a28c8:	681b      	ldr	r3, [r3, #0]
 80a28ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a28cc:	9301      	str	r3, [sp, #4]
 80a28ce:	bd08      	pop	{r3, pc}
 80a28d0:	080601c8 	.word	0x080601c8

080a28d4 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a28d4:	b508      	push	{r3, lr}
 80a28d6:	4b02      	ldr	r3, [pc, #8]	; (80a28e0 <malloc+0xc>)
 80a28d8:	681b      	ldr	r3, [r3, #0]
 80a28da:	681b      	ldr	r3, [r3, #0]
 80a28dc:	9301      	str	r3, [sp, #4]
 80a28de:	bd08      	pop	{r3, pc}
 80a28e0:	080601a0 	.word	0x080601a0

080a28e4 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a28e4:	b508      	push	{r3, lr}
 80a28e6:	4b02      	ldr	r3, [pc, #8]	; (80a28f0 <free+0xc>)
 80a28e8:	681b      	ldr	r3, [r3, #0]
 80a28ea:	685b      	ldr	r3, [r3, #4]
 80a28ec:	9301      	str	r3, [sp, #4]
 80a28ee:	bd08      	pop	{r3, pc}
 80a28f0:	080601a0 	.word	0x080601a0

080a28f4 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a28f4:	b508      	push	{r3, lr}
 80a28f6:	4b02      	ldr	r3, [pc, #8]	; (80a2900 <realloc+0xc>)
 80a28f8:	681b      	ldr	r3, [r3, #0]
 80a28fa:	689b      	ldr	r3, [r3, #8]
 80a28fc:	9301      	str	r3, [sp, #4]
 80a28fe:	bd08      	pop	{r3, pc}
 80a2900:	080601a0 	.word	0x080601a0

080a2904 <snprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
 80a2904:	b508      	push	{r3, lr}
 80a2906:	4b02      	ldr	r3, [pc, #8]	; (80a2910 <snprintf+0xc>)
 80a2908:	681b      	ldr	r3, [r3, #0]
 80a290a:	69db      	ldr	r3, [r3, #28]
 80a290c:	9301      	str	r3, [sp, #4]
 80a290e:	bd08      	pop	{r3, pc}
 80a2910:	080601a0 	.word	0x080601a0

080a2914 <vsnprintf>:
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a2914:	b508      	push	{r3, lr}
 80a2916:	4b02      	ldr	r3, [pc, #8]	; (80a2920 <vsnprintf+0xc>)
 80a2918:	681b      	ldr	r3, [r3, #0]
 80a291a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a291c:	9301      	str	r3, [sp, #4]
 80a291e:	bd08      	pop	{r3, pc}
 80a2920:	080601a0 	.word	0x080601a0

080a2924 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a2924:	2100      	movs	r1, #0
 80a2926:	f7ff bf89 	b.w	80a283c <system_delay_ms>

080a292a <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a292a:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a292c:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a292e:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a2930:	b113      	cbz	r3, 80a2938 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a2932:	2203      	movs	r2, #3
 80a2934:	4601      	mov	r1, r0
 80a2936:	4798      	blx	r3
    }
 80a2938:	4620      	mov	r0, r4
 80a293a:	bd10      	pop	{r4, pc}

080a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a293c:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a293e:	6804      	ldr	r4, [r0, #0]
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a2940:	4605      	mov	r5, r0
      {
	if (_M_pi != nullptr)
 80a2942:	b17c      	cbz	r4, 80a2964 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a2944:	6863      	ldr	r3, [r4, #4]
 80a2946:	3b01      	subs	r3, #1
 80a2948:	6063      	str	r3, [r4, #4]
 80a294a:	b95b      	cbnz	r3, 80a2964 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
        {
          _M_dispose();
 80a294c:	6823      	ldr	r3, [r4, #0]
 80a294e:	4620      	mov	r0, r4
 80a2950:	689b      	ldr	r3, [r3, #8]
 80a2952:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a2954:	68a3      	ldr	r3, [r4, #8]
 80a2956:	3b01      	subs	r3, #1
 80a2958:	60a3      	str	r3, [r4, #8]
 80a295a:	b91b      	cbnz	r3, 80a2964 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a295c:	6823      	ldr	r3, [r4, #0]
 80a295e:	4620      	mov	r0, r4
 80a2960:	68db      	ldr	r3, [r3, #12]
 80a2962:	4798      	blx	r3

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
 80a2964:	4628      	mov	r0, r5
 80a2966:	bd38      	pop	{r3, r4, r5, pc}

080a2968 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a2968:	680b      	ldr	r3, [r1, #0]
 80a296a:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a296c:	b113      	cbz	r3, 80a2974 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a296e:	685a      	ldr	r2, [r3, #4]
 80a2970:	3201      	adds	r2, #1
 80a2972:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
 80a2974:	4770      	bx	lr

080a2976 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a2976:	4770      	bx	lr

080a2978 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a2978:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a297a:	4606      	mov	r6, r0
 80a297c:	4615      	mov	r5, r2
 80a297e:	460c      	mov	r4, r1
 80a2980:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a2982:	42bc      	cmp	r4, r7
 80a2984:	d006      	beq.n	80a2994 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a2986:	6833      	ldr	r3, [r6, #0]
 80a2988:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a298c:	689b      	ldr	r3, [r3, #8]
 80a298e:	4630      	mov	r0, r6
 80a2990:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a2992:	e7f6      	b.n	80a2982 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a2994:	4628      	mov	r0, r5
 80a2996:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2998 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a2998:	2200      	movs	r2, #0
 80a299a:	7c00      	ldrb	r0, [r0, #16]
 80a299c:	f7ff bdf4 	b.w	80a2588 <HAL_I2C_Write_Data>

080a29a0 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a29a0:	2100      	movs	r1, #0
 80a29a2:	7c00      	ldrb	r0, [r0, #16]
 80a29a4:	f7ff bdf8 	b.w	80a2598 <HAL_I2C_Available_Data>

080a29a8 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a29a8:	2100      	movs	r1, #0
 80a29aa:	7c00      	ldrb	r0, [r0, #16]
 80a29ac:	f7ff bdfc 	b.w	80a25a8 <HAL_I2C_Read_Data>

080a29b0 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a29b0:	2100      	movs	r1, #0
 80a29b2:	7c00      	ldrb	r0, [r0, #16]
 80a29b4:	f7ff be00 	b.w	80a25b8 <HAL_I2C_Peek_Data>

080a29b8 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a29b8:	2100      	movs	r1, #0
 80a29ba:	7c00      	ldrb	r0, [r0, #16]
 80a29bc:	f7ff be04 	b.w	80a25c8 <HAL_I2C_Flush_Data>

080a29c0 <_ZN7TwoWireD0Ev>:
 80a29c0:	b510      	push	{r4, lr}
 80a29c2:	4604      	mov	r4, r0
 80a29c4:	f7fd fb6b 	bl	80a009e <_ZdlPv>
 80a29c8:	4620      	mov	r0, r4
 80a29ca:	bd10      	pop	{r4, pc}

080a29cc <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a29cc:	b510      	push	{r4, lr}
 80a29ce:	4604      	mov	r4, r0
 80a29d0:	4608      	mov	r0, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a29d2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a29d6:	60a3      	str	r3, [r4, #8]
 80a29d8:	4b04      	ldr	r3, [pc, #16]	; (80a29ec <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a29da:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a29dc:	7420      	strb	r0, [r4, #16]
 80a29de:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a29e0:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a29e2:	f7ff fe01 	bl	80a25e8 <HAL_I2C_Init>

}
 80a29e6:	4620      	mov	r0, r4
 80a29e8:	bd10      	pop	{r4, pc}
 80a29ea:	bf00      	nop
 80a29ec:	080a58d4 	.word	0x080a58d4

080a29f0 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a29f0:	2100      	movs	r1, #0
 80a29f2:	7c00      	ldrb	r0, [r0, #16]
 80a29f4:	f7ff bdf0 	b.w	80a25d8 <HAL_I2C_Is_Enabled>

080a29f8 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a29f8:	4770      	bx	lr

080a29fa <_ZN9IPAddressD0Ev>:
 80a29fa:	b510      	push	{r4, lr}
 80a29fc:	4604      	mov	r4, r0
 80a29fe:	f7fd fb4e 	bl	80a009e <_ZdlPv>
 80a2a02:	4620      	mov	r0, r4
 80a2a04:	bd10      	pop	{r4, pc}

080a2a06 <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a2a06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2a08:	460f      	mov	r7, r1
 80a2a0a:	f100 0608 	add.w	r6, r0, #8
 80a2a0e:	1d05      	adds	r5, r0, #4
 80a2a10:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a2a12:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a2a16:	220a      	movs	r2, #10
 80a2a18:	4638      	mov	r0, r7
 80a2a1a:	f001 fa3e 	bl	80a3e9a <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a2a1e:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a2a20:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a2a22:	d007      	beq.n	80a2a34 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a2a24:	2c00      	cmp	r4, #0
 80a2a26:	d0f4      	beq.n	80a2a12 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a2a28:	212e      	movs	r1, #46	; 0x2e
 80a2a2a:	4638      	mov	r0, r7
 80a2a2c:	f001 f9f2 	bl	80a3e14 <_ZN5Print5printEc>
 80a2a30:	4404      	add	r4, r0
 80a2a32:	e7ee      	b.n	80a2a12 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a2a34:	4620      	mov	r0, r4
 80a2a36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2a38 <_ZN9IPAddressC1Ev>:
#include "spark_wiring_ipaddress.h"
#include "spark_wiring_print.h"
#include "spark_wiring_platform.h"
#include "string.h"

IPAddress::IPAddress()
 80a2a38:	b510      	push	{r4, lr}
 80a2a3a:	4604      	mov	r4, r0
 80a2a3c:	4b04      	ldr	r3, [pc, #16]	; (80a2a50 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a2a3e:	2211      	movs	r2, #17
 80a2a40:	f840 3b04 	str.w	r3, [r0], #4
 80a2a44:	2100      	movs	r1, #0
 80a2a46:	f002 fa8b 	bl	80a4f60 <memset>
{
    clear();
}
 80a2a4a:	4620      	mov	r0, r4
 80a2a4c:	bd10      	pop	{r4, pc}
 80a2a4e:	bf00      	nop
 80a2a50:	080a58fc 	.word	0x080a58fc

080a2a54 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a2a54:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a2a56:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a2a5a:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a2a5e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a2a62:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a2a66:	2304      	movs	r3, #4
 80a2a68:	6041      	str	r1, [r0, #4]
 80a2a6a:	7503      	strb	r3, [r0, #20]
 80a2a6c:	bd10      	pop	{r4, pc}
	...

080a2a70 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a2a70:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a2a72:	4d04      	ldr	r5, [pc, #16]	; (80a2a84 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a2a74:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a2a76:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a2a7a:	9500      	str	r5, [sp, #0]
 80a2a7c:	f7ff ffea 	bl	80a2a54 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a2a80:	b003      	add	sp, #12
 80a2a82:	bd30      	pop	{r4, r5, pc}
 80a2a84:	080a58fc 	.word	0x080a58fc

080a2a88 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>:
#include <cstdarg>

namespace {

// Skips token and all its children tokens if any
const jsmntok_t* skipToken(const jsmntok_t *t) {
 80a2a88:	f100 0210 	add.w	r2, r0, #16
    size_t n = 1;
 80a2a8c:	2301      	movs	r3, #1
    do {
        if (t->type == JSMN_OBJECT) {
 80a2a8e:	f812 1c10 	ldrb.w	r1, [r2, #-16]
 80a2a92:	4610      	mov	r0, r2
 80a2a94:	2901      	cmp	r1, #1
 80a2a96:	d104      	bne.n	80a2aa2 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x1a>
            n += t->size * 2; // Number of name and value tokens
 80a2a98:	f852 1c04 	ldr.w	r1, [r2, #-4]
 80a2a9c:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 80a2aa0:	e004      	b.n	80a2aac <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x24>
        } else if (t->type == JSMN_ARRAY) {
 80a2aa2:	2902      	cmp	r1, #2
            n += t->size; // Number of value tokens
 80a2aa4:	bf04      	itt	eq
 80a2aa6:	f852 1c04 	ldreq.w	r1, [r2, #-4]
 80a2aaa:	185b      	addeq	r3, r3, r1
namespace {

// Skips token and all its children tokens if any
const jsmntok_t* skipToken(const jsmntok_t *t) {
    size_t n = 1;
    do {
 80a2aac:	3b01      	subs	r3, #1
 80a2aae:	f102 0210 	add.w	r2, r2, #16
 80a2ab2:	d1ec      	bne.n	80a2a8e <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t+0x6>
        }
        ++t;
        --n;
    } while (n);
    return t;
}
 80a2ab4:	4770      	bx	lr

080a2ab6 <_ZN5spark10JSONWriter6printfEPKcz>:
    write("null", 4);
    state_ = NEXT;
    return *this;
}

void spark::JSONWriter::printf(const char *fmt, ...) {
 80a2ab6:	b40e      	push	{r1, r2, r3}
 80a2ab8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2abc:	b087      	sub	sp, #28
 80a2abe:	af00      	add	r7, sp, #0
 80a2ac0:	f107 0434 	add.w	r4, r7, #52	; 0x34
 80a2ac4:	f854 6b04 	ldr.w	r6, [r4], #4
 80a2ac8:	4605      	mov	r5, r0
    char buf[16];
    va_list args;
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a2aca:	4623      	mov	r3, r4
 80a2acc:	4632      	mov	r2, r6
 80a2ace:	2110      	movs	r1, #16
 80a2ad0:	f107 0008 	add.w	r0, r7, #8
}

void spark::JSONWriter::printf(const char *fmt, ...) {
    char buf[16];
    va_list args;
    va_start(args, fmt);
 80a2ad4:	607c      	str	r4, [r7, #4]
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a2ad6:	f7ff ff1d 	bl	80a2914 <vsnprintf>
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
 80a2ada:	280f      	cmp	r0, #15
 80a2adc:	d916      	bls.n	80a2b0c <_ZN5spark10JSONWriter6printfEPKcz+0x56>
        char buf[n + 1]; // Use larger buffer
 80a2ade:	f100 0308 	add.w	r3, r0, #8
 80a2ae2:	f023 0307 	bic.w	r3, r3, #7
        va_start(args, fmt);
        n = vsnprintf(buf, sizeof(buf), fmt, args);
        va_end(args);
        if (n > 0) {
            write(buf, n);
        }
 80a2ae6:	46e8      	mov	r8, sp
    va_list args;
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
        char buf[n + 1]; // Use larger buffer
 80a2ae8:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(args, fmt);
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a2aec:	4632      	mov	r2, r6
 80a2aee:	1c41      	adds	r1, r0, #1
 80a2af0:	4623      	mov	r3, r4
 80a2af2:	4668      	mov	r0, sp
    va_start(args, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    if ((size_t)n >= sizeof(buf)) {
        char buf[n + 1]; // Use larger buffer
        va_start(args, fmt);
 80a2af4:	607c      	str	r4, [r7, #4]
        n = vsnprintf(buf, sizeof(buf), fmt, args);
 80a2af6:	f7ff ff0d 	bl	80a2914 <vsnprintf>
        va_end(args);
        if (n > 0) {
 80a2afa:	1e02      	subs	r2, r0, #0
 80a2afc:	dd04      	ble.n	80a2b08 <_ZN5spark10JSONWriter6printfEPKcz+0x52>
            write(buf, n);
 80a2afe:	682b      	ldr	r3, [r5, #0]
 80a2b00:	4669      	mov	r1, sp
 80a2b02:	689b      	ldr	r3, [r3, #8]
 80a2b04:	4628      	mov	r0, r5
 80a2b06:	4798      	blx	r3
 80a2b08:	46c5      	mov	sp, r8
 80a2b0a:	e007      	b.n	80a2b1c <_ZN5spark10JSONWriter6printfEPKcz+0x66>
        }
    } else if (n > 0) {
 80a2b0c:	b130      	cbz	r0, 80a2b1c <_ZN5spark10JSONWriter6printfEPKcz+0x66>
        write(buf, n);
 80a2b0e:	682b      	ldr	r3, [r5, #0]
 80a2b10:	4602      	mov	r2, r0
 80a2b12:	689b      	ldr	r3, [r3, #8]
 80a2b14:	f107 0108 	add.w	r1, r7, #8
 80a2b18:	4628      	mov	r0, r5
 80a2b1a:	4798      	blx	r3
    }
}
 80a2b1c:	371c      	adds	r7, #28
 80a2b1e:	46bd      	mov	sp, r7
 80a2b20:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a2b24:	b003      	add	sp, #12
 80a2b26:	4770      	bx	lr

080a2b28 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a2b28:	b510      	push	{r4, lr}
 80a2b2a:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a2b2c:	6803      	ldr	r3, [r0, #0]
 80a2b2e:	689b      	ldr	r3, [r3, #8]
 80a2b30:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a2b32:	68a3      	ldr	r3, [r4, #8]
 80a2b34:	3b01      	subs	r3, #1
 80a2b36:	60a3      	str	r3, [r4, #8]
 80a2b38:	b92b      	cbnz	r3, 80a2b46 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12+0x1e>
            _M_destroy();
 80a2b3a:	6823      	ldr	r3, [r4, #0]
 80a2b3c:	4620      	mov	r0, r4
        }
    }
 80a2b3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a2b42:	68db      	ldr	r3, [r3, #12]
 80a2b44:	4718      	bx	r3
 80a2b46:	bd10      	pop	{r4, pc}

080a2b48 <_ZN5spark10JSONWriter5writeEc>:

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a2b48:	b513      	push	{r0, r1, r4, lr}
    write(&c, 1);
 80a2b4a:	6802      	ldr	r2, [r0, #0]

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a2b4c:	ab02      	add	r3, sp, #8
 80a2b4e:	f803 1d01 	strb.w	r1, [r3, #-1]!
    write(&c, 1);
 80a2b52:	6894      	ldr	r4, [r2, #8]
 80a2b54:	4619      	mov	r1, r3
 80a2b56:	2201      	movs	r2, #1
 80a2b58:	47a0      	blx	r4
}
 80a2b5a:	b002      	add	sp, #8
 80a2b5c:	bd10      	pop	{r4, pc}

080a2b5e <_ZNK5spark9JSONValue4typeEv>:
        return 0.0;
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
 80a2b5e:	6883      	ldr	r3, [r0, #8]
 80a2b60:	b1fb      	cbz	r3, 80a2ba2 <_ZNK5spark9JSONValue4typeEv+0x44>
        return JSON_TYPE_INVALID;
    }
    switch (t_->type) {
 80a2b62:	781a      	ldrb	r2, [r3, #0]
 80a2b64:	2a03      	cmp	r2, #3
 80a2b66:	d81a      	bhi.n	80a2b9e <_ZNK5spark9JSONValue4typeEv+0x40>
 80a2b68:	e8df f002 	tbb	[pc, r2]
 80a2b6c:	1d021704 	.word	0x1d021704
        return JSON_TYPE_INVALID;
    }
    case JSMN_STRING:
        return JSON_TYPE_STRING;
    case JSMN_ARRAY:
        return JSON_TYPE_ARRAY;
 80a2b70:	2005      	movs	r0, #5
 80a2b72:	4770      	bx	lr
    if (!t_) {
        return JSON_TYPE_INVALID;
    }
    switch (t_->type) {
    case JSMN_PRIMITIVE: {
        const char c = d_->json[t_->start];
 80a2b74:	6802      	ldr	r2, [r0, #0]
 80a2b76:	685b      	ldr	r3, [r3, #4]
 80a2b78:	6852      	ldr	r2, [r2, #4]
 80a2b7a:	5cd0      	ldrb	r0, [r2, r3]
        if (c == '-' || (c >= '0' && c <= '9')) {
 80a2b7c:	282d      	cmp	r0, #45	; 0x2d
 80a2b7e:	d014      	beq.n	80a2baa <_ZNK5spark9JSONValue4typeEv+0x4c>
 80a2b80:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 80a2b84:	2b09      	cmp	r3, #9
 80a2b86:	d910      	bls.n	80a2baa <_ZNK5spark9JSONValue4typeEv+0x4c>
            return JSON_TYPE_NUMBER;
        } else if (c == 't' || c == 'f') { // Literal names are always in lower case
 80a2b88:	2874      	cmp	r0, #116	; 0x74
 80a2b8a:	d010      	beq.n	80a2bae <_ZNK5spark9JSONValue4typeEv+0x50>
 80a2b8c:	2866      	cmp	r0, #102	; 0x66
 80a2b8e:	d00e      	beq.n	80a2bae <_ZNK5spark9JSONValue4typeEv+0x50>
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
        return JSON_TYPE_INVALID;
 80a2b90:	f1a0 036e 	sub.w	r3, r0, #110	; 0x6e
 80a2b94:	4258      	negs	r0, r3
 80a2b96:	4158      	adcs	r0, r3
 80a2b98:	4770      	bx	lr
    case JSMN_STRING:
        return JSON_TYPE_STRING;
    case JSMN_ARRAY:
        return JSON_TYPE_ARRAY;
    case JSMN_OBJECT:
        return JSON_TYPE_OBJECT;
 80a2b9a:	2006      	movs	r0, #6
 80a2b9c:	4770      	bx	lr
    default:
        return JSON_TYPE_INVALID;
 80a2b9e:	2000      	movs	r0, #0
 80a2ba0:	4770      	bx	lr
    }
}

spark::JSONType spark::JSONValue::type() const {
    if (!t_) {
        return JSON_TYPE_INVALID;
 80a2ba2:	4618      	mov	r0, r3
 80a2ba4:	4770      	bx	lr
            return JSON_TYPE_NULL;
        }
        return JSON_TYPE_INVALID;
    }
    case JSMN_STRING:
        return JSON_TYPE_STRING;
 80a2ba6:	2004      	movs	r0, #4
 80a2ba8:	4770      	bx	lr
    }
    switch (t_->type) {
    case JSMN_PRIMITIVE: {
        const char c = d_->json[t_->start];
        if (c == '-' || (c >= '0' && c <= '9')) {
            return JSON_TYPE_NUMBER;
 80a2baa:	2003      	movs	r0, #3
 80a2bac:	4770      	bx	lr
        } else if (c == 't' || c == 'f') { // Literal names are always in lower case
            return JSON_TYPE_BOOL;
 80a2bae:	2002      	movs	r0, #2
    case JSMN_OBJECT:
        return JSON_TYPE_OBJECT;
    default:
        return JSON_TYPE_INVALID;
    }
}
 80a2bb0:	4770      	bx	lr

080a2bb2 <_ZNK5spark9JSONValue5toIntEv>:
    default:
        return false;
    }
}

int spark::JSONValue::toInt() const {
 80a2bb2:	b510      	push	{r4, lr}
 80a2bb4:	4604      	mov	r4, r0
    switch (type()) {
 80a2bb6:	f7ff ffd2 	bl	80a2b5e <_ZNK5spark9JSONValue4typeEv>
 80a2bba:	2802      	cmp	r0, #2
 80a2bbc:	d00d      	beq.n	80a2bda <_ZNK5spark9JSONValue5toIntEv+0x28>
 80a2bbe:	d316      	bcc.n	80a2bee <_ZNK5spark9JSONValue5toIntEv+0x3c>
 80a2bc0:	2804      	cmp	r0, #4
 80a2bc2:	d814      	bhi.n	80a2bee <_ZNK5spark9JSONValue5toIntEv+0x3c>
    }
    case JSON_TYPE_NUMBER:
    case JSON_TYPE_STRING: {
        // toInt() may produce incorrect results for floating point numbers, since we want to keep
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
 80a2bc4:	6822      	ldr	r2, [r4, #0]
 80a2bc6:	68a3      	ldr	r3, [r4, #8]
        return strtol(s, nullptr, 10);
 80a2bc8:	6850      	ldr	r0, [r2, #4]
 80a2bca:	685b      	ldr	r3, [r3, #4]
 80a2bcc:	220a      	movs	r2, #10
 80a2bce:	2100      	movs	r1, #0
 80a2bd0:	4418      	add	r0, r3
    }
    default:
        return 0;
    }
}
 80a2bd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    case JSON_TYPE_NUMBER:
    case JSON_TYPE_STRING: {
        // toInt() may produce incorrect results for floating point numbers, since we want to keep
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
        return strtol(s, nullptr, 10);
 80a2bd6:	f002 badf 	b.w	80a5198 <strtol>
}

int spark::JSONValue::toInt() const {
    switch (type()) {
    case JSON_TYPE_BOOL: {
        const char* const s = d_->json + t_->start;
 80a2bda:	6822      	ldr	r2, [r4, #0]
 80a2bdc:	68a3      	ldr	r3, [r4, #8]
        return *s == 't';
 80a2bde:	6852      	ldr	r2, [r2, #4]
 80a2be0:	685b      	ldr	r3, [r3, #4]
 80a2be2:	5cd0      	ldrb	r0, [r2, r3]
 80a2be4:	f1a0 0374 	sub.w	r3, r0, #116	; 0x74
 80a2be8:	4258      	negs	r0, r3
 80a2bea:	4158      	adcs	r0, r3
 80a2bec:	bd10      	pop	{r4, pc}
        // compile-time dependency on strtod() optional
        const char* const s = d_->json + t_->start;
        return strtol(s, nullptr, 10);
    }
    default:
        return 0;
 80a2bee:	2000      	movs	r0, #0
    }
}
 80a2bf0:	bd10      	pop	{r4, pc}

080a2bf2 <_ZN5spark18JSONObjectIterator4nextEv>:
        n_ = t->size; // Number of properties
        d_ = d;
    }
}

bool spark::JSONObjectIterator::next() {
 80a2bf2:	b510      	push	{r4, lr}
    if (!n_) {
 80a2bf4:	6943      	ldr	r3, [r0, #20]
        n_ = t->size; // Number of properties
        d_ = d;
    }
}

bool spark::JSONObjectIterator::next() {
 80a2bf6:	4604      	mov	r4, r0
    if (!n_) {
 80a2bf8:	b15b      	cbz	r3, 80a2c12 <_ZN5spark18JSONObjectIterator4nextEv+0x20>
        return false;
    }
    k_ = t_; // Name
 80a2bfa:	6880      	ldr	r0, [r0, #8]
    ++t_;
    v_ = t_; // Value
    --n_;
 80a2bfc:	3b01      	subs	r3, #1

bool spark::JSONObjectIterator::next() {
    if (!n_) {
        return false;
    }
    k_ = t_; // Name
 80a2bfe:	60e0      	str	r0, [r4, #12]
    ++t_;
 80a2c00:	3010      	adds	r0, #16
 80a2c02:	60a0      	str	r0, [r4, #8]
    v_ = t_; // Value
 80a2c04:	6120      	str	r0, [r4, #16]
    --n_;
 80a2c06:	6163      	str	r3, [r4, #20]
    if (n_) {
 80a2c08:	b12b      	cbz	r3, 80a2c16 <_ZN5spark18JSONObjectIterator4nextEv+0x24>
        t_ = skipToken(t_);
 80a2c0a:	f7ff ff3d 	bl	80a2a88 <_ZN12_GLOBAL__N_19skipTokenEPK9jsmntok_t>
 80a2c0e:	60a0      	str	r0, [r4, #8]
 80a2c10:	e001      	b.n	80a2c16 <_ZN5spark18JSONObjectIterator4nextEv+0x24>
    }
}

bool spark::JSONObjectIterator::next() {
    if (!n_) {
        return false;
 80a2c12:	4618      	mov	r0, r3
 80a2c14:	bd10      	pop	{r4, pc}
    v_ = t_; // Value
    --n_;
    if (n_) {
        t_ = skipToken(t_);
    }
    return true;
 80a2c16:	2001      	movs	r0, #1
}
 80a2c18:	bd10      	pop	{r4, pc}

080a2c1a <_ZN5spark10JSONWriter9endObjectEv>:
    write('{');
    state_ = BEGIN;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::endObject() {
 80a2c1a:	b510      	push	{r4, lr}
 80a2c1c:	4604      	mov	r4, r0
    write('}');
 80a2c1e:	217d      	movs	r1, #125	; 0x7d
 80a2c20:	f7ff ff92 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
    state_ = NEXT;
 80a2c24:	2301      	movs	r3, #1
 80a2c26:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2c28:	4620      	mov	r0, r4
 80a2c2a:	bd10      	pop	{r4, pc}

080a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>:
    } else if (n > 0) {
        write(buf, n);
    }
}

void spark::JSONWriter::writeSeparator() {
 80a2c2c:	b508      	push	{r3, lr}
    switch (state_) {
 80a2c2e:	7903      	ldrb	r3, [r0, #4]
 80a2c30:	2b01      	cmp	r3, #1
 80a2c32:	d002      	beq.n	80a2c3a <_ZN5spark10JSONWriter14writeSeparatorEv+0xe>
 80a2c34:	2b02      	cmp	r3, #2
 80a2c36:	d002      	beq.n	80a2c3e <_ZN5spark10JSONWriter14writeSeparatorEv+0x12>
 80a2c38:	bd08      	pop	{r3, pc}
    case NEXT:
        write(',');
 80a2c3a:	212c      	movs	r1, #44	; 0x2c
 80a2c3c:	e000      	b.n	80a2c40 <_ZN5spark10JSONWriter14writeSeparatorEv+0x14>
        break;
    case VALUE:
        write(':');
 80a2c3e:	213a      	movs	r1, #58	; 0x3a
 80a2c40:	f7ff ff82 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
 80a2c44:	bd08      	pop	{r3, pc}

080a2c46 <_ZN5spark10JSONWriter11beginObjectEv>:
    write(']');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::beginObject() {
 80a2c46:	b510      	push	{r4, lr}
 80a2c48:	4604      	mov	r4, r0
    writeSeparator();
 80a2c4a:	f7ff ffef 	bl	80a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>
    write('{');
 80a2c4e:	4620      	mov	r0, r4
 80a2c50:	217b      	movs	r1, #123	; 0x7b
 80a2c52:	f7ff ff79 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
    state_ = BEGIN;
 80a2c56:	2300      	movs	r3, #0
 80a2c58:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2c5a:	4620      	mov	r0, r4
 80a2c5c:	bd10      	pop	{r4, pc}
	...

080a2c60 <_ZN5spark10JSONWriter5valueEi>:
    }
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::value(int val) {
 80a2c60:	b538      	push	{r3, r4, r5, lr}
 80a2c62:	4604      	mov	r4, r0
 80a2c64:	460d      	mov	r5, r1
    writeSeparator();
 80a2c66:	f7ff ffe1 	bl	80a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%d", val);
 80a2c6a:	6823      	ldr	r3, [r4, #0]
 80a2c6c:	4620      	mov	r0, r4
 80a2c6e:	68db      	ldr	r3, [r3, #12]
 80a2c70:	462a      	mov	r2, r5
 80a2c72:	4903      	ldr	r1, [pc, #12]	; (80a2c80 <_ZN5spark10JSONWriter5valueEi+0x20>)
 80a2c74:	4798      	blx	r3
    state_ = NEXT;
 80a2c76:	2301      	movs	r3, #1
 80a2c78:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2c7a:	4620      	mov	r0, r4
 80a2c7c:	bd38      	pop	{r3, r4, r5, pc}
 80a2c7e:	bf00      	nop
 80a2c80:	080a5917 	.word	0x080a5917

080a2c84 <_ZN5spark10JSONWriter5valueEj>:

spark::JSONWriter& spark::JSONWriter::value(unsigned val) {
 80a2c84:	b538      	push	{r3, r4, r5, lr}
 80a2c86:	4604      	mov	r4, r0
 80a2c88:	460d      	mov	r5, r1
    writeSeparator();
 80a2c8a:	f7ff ffcf 	bl	80a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%u", val);
 80a2c8e:	6823      	ldr	r3, [r4, #0]
 80a2c90:	4620      	mov	r0, r4
 80a2c92:	68db      	ldr	r3, [r3, #12]
 80a2c94:	462a      	mov	r2, r5
 80a2c96:	4903      	ldr	r1, [pc, #12]	; (80a2ca4 <_ZN5spark10JSONWriter5valueEj+0x20>)
 80a2c98:	4798      	blx	r3
    state_ = NEXT;
 80a2c9a:	2301      	movs	r3, #1
 80a2c9c:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2c9e:	4620      	mov	r0, r4
 80a2ca0:	bd38      	pop	{r3, r4, r5, pc}
 80a2ca2:	bf00      	nop
 80a2ca4:	080a591a 	.word	0x080a591a

080a2ca8 <_ZN5spark10JSONWriter12writeEscapedEPKcj>:
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a2ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2caa:	460d      	mov	r5, r1
 80a2cac:	4617      	mov	r7, r2
    write('"');
 80a2cae:	2122      	movs	r1, #34	; 0x22
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a2cb0:	4604      	mov	r4, r0
    write('"');
 80a2cb2:	f7ff ff49 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
 80a2cb6:	462a      	mov	r2, r5
    const char* const end = str + size;
 80a2cb8:	4629      	mov	r1, r5
 80a2cba:	442f      	add	r7, r5
    const char *s = str;
    while (s != end) {
 80a2cbc:	42ba      	cmp	r2, r7
 80a2cbe:	d038      	beq.n	80a2d32 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x8a>
        const char c = *s;
 80a2cc0:	4616      	mov	r6, r2
 80a2cc2:	f816 5b01 	ldrb.w	r5, [r6], #1
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
 80a2cc6:	2d22      	cmp	r5, #34	; 0x22
 80a2cc8:	d003      	beq.n	80a2cd2 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a2cca:	2d5c      	cmp	r5, #92	; 0x5c
 80a2ccc:	d001      	beq.n	80a2cd2 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a2cce:	2d1f      	cmp	r5, #31
 80a2cd0:	d82d      	bhi.n	80a2d2e <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x86>
            write(str, s - str); // Write preceeding characters
 80a2cd2:	6823      	ldr	r3, [r4, #0]
 80a2cd4:	1a52      	subs	r2, r2, r1
 80a2cd6:	689b      	ldr	r3, [r3, #8]
 80a2cd8:	4620      	mov	r0, r4
 80a2cda:	4798      	blx	r3
            write('\\');
 80a2cdc:	215c      	movs	r1, #92	; 0x5c
 80a2cde:	4620      	mov	r0, r4
 80a2ce0:	f7ff ff32 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
            switch (c) {
 80a2ce4:	2d0c      	cmp	r5, #12
 80a2ce6:	d019      	beq.n	80a2d1c <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x74>
 80a2ce8:	d807      	bhi.n	80a2cfa <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x52>
 80a2cea:	2d09      	cmp	r5, #9
 80a2cec:	d00f      	beq.n	80a2d0e <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x66>
 80a2cee:	2d0a      	cmp	r5, #10
 80a2cf0:	d012      	beq.n	80a2d18 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x70>
 80a2cf2:	2d08      	cmp	r5, #8
 80a2cf4:	d114      	bne.n	80a2d20 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a2cf6:	2162      	movs	r1, #98	; 0x62
 80a2cf8:	e00a      	b.n	80a2d10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
    while (s != end) {
        const char c = *s;
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
 80a2cfa:	2d22      	cmp	r5, #34	; 0x22
 80a2cfc:	d005      	beq.n	80a2d0a <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a2cfe:	2d5c      	cmp	r5, #92	; 0x5c
 80a2d00:	d003      	beq.n	80a2d0a <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a2d02:	2d0d      	cmp	r5, #13
 80a2d04:	d10c      	bne.n	80a2d20 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
                break;
            case 0x0c: // Form feed
                write('f');
                break;
            case 0x0d: // Carriage return
                write('r');
 80a2d06:	2172      	movs	r1, #114	; 0x72
 80a2d08:	e002      	b.n	80a2d10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
            case '"':
            case '\\':
                write(c);
 80a2d0a:	4629      	mov	r1, r5
 80a2d0c:	e000      	b.n	80a2d10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x08: // Backspace
                write('b');
                break;
            case 0x09: // Tab
                write('t');
 80a2d0e:	2174      	movs	r1, #116	; 0x74
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a2d10:	4620      	mov	r0, r4
 80a2d12:	f7ff ff19 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
                break;
 80a2d16:	e009      	b.n	80a2d2c <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x84>
            case 0x09: // Tab
                write('t');
                break;
            case 0x0a: // Line feed
                write('n');
 80a2d18:	216e      	movs	r1, #110	; 0x6e
 80a2d1a:	e7f9      	b.n	80a2d10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x0c: // Form feed
                write('f');
 80a2d1c:	2166      	movs	r1, #102	; 0x66
 80a2d1e:	e7f7      	b.n	80a2d10 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            case 0x0d: // Carriage return
                write('r');
                break;
            default:
                // All other control characters are written in hex, e.g. "\u001f"
                printf("u%04x", (unsigned)c);
 80a2d20:	6823      	ldr	r3, [r4, #0]
 80a2d22:	462a      	mov	r2, r5
 80a2d24:	68db      	ldr	r3, [r3, #12]
 80a2d26:	4909      	ldr	r1, [pc, #36]	; (80a2d4c <_ZN5spark10JSONWriter12writeEscapedEPKcj+0xa4>)
 80a2d28:	4620      	mov	r0, r4
 80a2d2a:	4798      	blx	r3
                break;
            }
            str = s + 1;
 80a2d2c:	4631      	mov	r1, r6

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
    write('"');
    const char* const end = str + size;
    const char *s = str;
    while (s != end) {
 80a2d2e:	4632      	mov	r2, r6
 80a2d30:	e7c4      	b.n	80a2cbc <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x14>
            }
            str = s + 1;
        }
        ++s;
    }
    if (s != str) {
 80a2d32:	4291      	cmp	r1, r2
 80a2d34:	d004      	beq.n	80a2d40 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x98>
        write(str, s - str); // Write remaining characters
 80a2d36:	6823      	ldr	r3, [r4, #0]
 80a2d38:	1a52      	subs	r2, r2, r1
 80a2d3a:	689d      	ldr	r5, [r3, #8]
 80a2d3c:	4620      	mov	r0, r4
 80a2d3e:	47a8      	blx	r5
    }
    write('"');
 80a2d40:	2122      	movs	r1, #34	; 0x22
 80a2d42:	4620      	mov	r0, r4
 80a2d44:	f7ff ff00 	bl	80a2b48 <_ZN5spark10JSONWriter5writeEc>
 80a2d48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a2d4a:	bf00      	nop
 80a2d4c:	080a5925 	.word	0x080a5925

080a2d50 <_ZN5spark10JSONWriter4nameEPKcj>:
    write('}');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::name(const char *name, size_t size) {
 80a2d50:	b570      	push	{r4, r5, r6, lr}
 80a2d52:	4604      	mov	r4, r0
 80a2d54:	460d      	mov	r5, r1
 80a2d56:	4616      	mov	r6, r2
    writeSeparator();
 80a2d58:	f7ff ff68 	bl	80a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(name, size);
 80a2d5c:	4620      	mov	r0, r4
 80a2d5e:	4632      	mov	r2, r6
 80a2d60:	4629      	mov	r1, r5
 80a2d62:	f7ff ffa1 	bl	80a2ca8 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = VALUE;
 80a2d66:	2302      	movs	r3, #2
 80a2d68:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2d6a:	4620      	mov	r0, r4
 80a2d6c:	bd70      	pop	{r4, r5, r6, pc}

080a2d6e <_ZN5spark10JSONWriter5valueEPKcj>:
    printf("%g", val);
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::value(const char *val, size_t size) {
 80a2d6e:	b570      	push	{r4, r5, r6, lr}
 80a2d70:	4604      	mov	r4, r0
 80a2d72:	460d      	mov	r5, r1
 80a2d74:	4616      	mov	r6, r2
    writeSeparator();
 80a2d76:	f7ff ff59 	bl	80a2c2c <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(val, size);
 80a2d7a:	4620      	mov	r0, r4
 80a2d7c:	4632      	mov	r2, r6
 80a2d7e:	4629      	mov	r1, r5
 80a2d80:	f7ff ff92 	bl	80a2ca8 <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = NEXT;
 80a2d84:	2301      	movs	r3, #1
 80a2d86:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a2d88:	4620      	mov	r0, r4
 80a2d8a:	bd70      	pop	{r4, r5, r6, pc}

080a2d8c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>:
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
 80a2d8c:	b538      	push	{r3, r4, r5, lr}
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a2d8e:	680c      	ldr	r4, [r1, #0]
	if (__tmp != _M_pi)
 80a2d90:	6803      	ldr	r3, [r0, #0]
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
 80a2d92:	4605      	mov	r5, r0
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
 80a2d94:	429c      	cmp	r4, r3
 80a2d96:	d00c      	beq.n	80a2db2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x26>
	  {
	    if (__tmp != 0)
 80a2d98:	b114      	cbz	r4, 80a2da0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x14>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a2d9a:	6863      	ldr	r3, [r4, #4]
 80a2d9c:	3301      	adds	r3, #1
 80a2d9e:	6063      	str	r3, [r4, #4]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	if (__tmp != _M_pi)
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
 80a2da0:	6828      	ldr	r0, [r5, #0]
 80a2da2:	b128      	cbz	r0, 80a2db0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x24>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a2da4:	6843      	ldr	r3, [r0, #4]
 80a2da6:	3b01      	subs	r3, #1
 80a2da8:	6043      	str	r3, [r0, #4]
 80a2daa:	b90b      	cbnz	r3, 80a2db0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_+0x24>
 80a2dac:	f7ff febc 	bl	80a2b28 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>
	  {
	    if (__tmp != 0)
	      __tmp->_M_add_ref_copy();
	    if (_M_pi != 0)
	      _M_pi->_M_release();
	    _M_pi = __tmp;
 80a2db0:	602c      	str	r4, [r5, #0]
	  }
	return *this;
      }
 80a2db2:	4628      	mov	r0, r5
 80a2db4:	bd38      	pop	{r3, r4, r5, pc}
	...

080a2db8 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:
    t->end = str - json; // Update string length
    return true;
}

// spark::JSONString
spark::JSONString::JSONString(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a2db8:	b510      	push	{r4, lr}
 80a2dba:	4604      	mov	r4, r0

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a2dbc:	2300      	movs	r3, #0
 80a2dbe:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a2dc0:	6043      	str	r3, [r0, #4]
}

// spark::JSONString
inline spark::JSONString::JSONString() :
        s_(""),
        n_(0) {
 80a2dc2:	4810      	ldr	r0, [pc, #64]	; (80a2e04 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x4c>)
 80a2dc4:	60e3      	str	r3, [r4, #12]
 80a2dc6:	60a0      	str	r0, [r4, #8]
        JSONString() {
    if (t && (t->type == JSMN_STRING || t->type == JSMN_PRIMITIVE)) {
 80a2dc8:	b1d1      	cbz	r1, 80a2e00 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x48>
 80a2dca:	780b      	ldrb	r3, [r1, #0]
 80a2dcc:	2b03      	cmp	r3, #3
 80a2dce:	d006      	beq.n	80a2dde <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x26>
 80a2dd0:	b9b3      	cbnz	r3, 80a2e00 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x48>
        if (t->type != JSMN_PRIMITIVE || d->json[t->start] != 'n') { // Nulls are treated as empty strings
 80a2dd2:	6813      	ldr	r3, [r2, #0]
 80a2dd4:	6858      	ldr	r0, [r3, #4]
 80a2dd6:	684b      	ldr	r3, [r1, #4]
 80a2dd8:	5cc3      	ldrb	r3, [r0, r3]
 80a2dda:	2b6e      	cmp	r3, #110	; 0x6e
 80a2ddc:	d008      	beq.n	80a2df0 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x38>
            s_ = d->json + t->start;
 80a2dde:	6813      	ldr	r3, [r2, #0]
 80a2de0:	6858      	ldr	r0, [r3, #4]
 80a2de2:	684b      	ldr	r3, [r1, #4]
 80a2de4:	4403      	add	r3, r0
 80a2de6:	60a3      	str	r3, [r4, #8]
            n_ = t->end - t->start;
 80a2de8:	688b      	ldr	r3, [r1, #8]
 80a2dea:	6849      	ldr	r1, [r1, #4]
 80a2dec:	1a5b      	subs	r3, r3, r1
 80a2dee:	60e3      	str	r3, [r4, #12]
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a2df0:	4611      	mov	r1, r2
 80a2df2:	4620      	mov	r0, r4
 80a2df4:	f851 3b04 	ldr.w	r3, [r1], #4
 80a2df8:	f840 3b04 	str.w	r3, [r0], #4
 80a2dfc:	f7ff ffc6 	bl	80a2d8c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        }
        d_ = d;
    }
}
 80a2e00:	4620      	mov	r0, r4
 80a2e02:	bd10      	pop	{r4, pc}
 80a2e04:	080a54a5 	.word	0x080a54a5

080a2e08 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a2e08:	2300      	movs	r3, #0
bool spark::JSONString::operator==(const JSONString &str) const {
    return n_ == str.n_ && strncmp(s_, str.s_, n_) == 0;
}

// spark::JSONObjectIterator
spark::JSONObjectIterator::JSONObjectIterator(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a2e0a:	b510      	push	{r4, lr}
 80a2e0c:	4604      	mov	r4, r0
 80a2e0e:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a2e10:	6043      	str	r3, [r0, #4]
// spark::JSONObjectIterator
inline spark::JSONObjectIterator::JSONObjectIterator() :
        t_(nullptr),
        k_(nullptr),
        v_(nullptr),
        n_(0) {
 80a2e12:	6083      	str	r3, [r0, #8]
 80a2e14:	60c3      	str	r3, [r0, #12]
 80a2e16:	6103      	str	r3, [r0, #16]
 80a2e18:	6143      	str	r3, [r0, #20]
        JSONObjectIterator() {
    if (t && t->type == JSMN_OBJECT) {
 80a2e1a:	b171      	cbz	r1, 80a2e3a <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x32>
 80a2e1c:	780b      	ldrb	r3, [r1, #0]
 80a2e1e:	2b01      	cmp	r3, #1
 80a2e20:	d10b      	bne.n	80a2e3a <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x32>
        t_ = t + 1; // First property's name
 80a2e22:	f101 0310 	add.w	r3, r1, #16
 80a2e26:	6083      	str	r3, [r0, #8]
        n_ = t->size; // Number of properties
 80a2e28:	68cb      	ldr	r3, [r1, #12]
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a2e2a:	4611      	mov	r1, r2
 80a2e2c:	6143      	str	r3, [r0, #20]
 80a2e2e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a2e32:	f840 3b04 	str.w	r3, [r0], #4
 80a2e36:	f7ff ffa9 	bl	80a2d8c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        d_ = d;
    }
}
 80a2e3a:	4620      	mov	r0, r4
 80a2e3c:	bd10      	pop	{r4, pc}

080a2e3e <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>:

    public:
      typedef _Tp   element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
 80a2e3e:	2300      	movs	r3, #0
        }
    }
};

// spark::JSONValue
spark::JSONValue::JSONValue(const jsmntok_t *t, detail::JSONDataPtr d) :
 80a2e40:	b510      	push	{r4, lr}
 80a2e42:	4604      	mov	r4, r0
 80a2e44:	6003      	str	r3, [r0, #0]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a2e46:	6043      	str	r3, [r0, #4]
        JSONValue() {
    if (t) {
        t_ = t;
 80a2e48:	6081      	str	r1, [r0, #8]
};

// spark::JSONValue
spark::JSONValue::JSONValue(const jsmntok_t *t, detail::JSONDataPtr d) :
        JSONValue() {
    if (t) {
 80a2e4a:	b131      	cbz	r1, 80a2e5a <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE+0x1c>
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
 80a2e4c:	4611      	mov	r1, r2
 80a2e4e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a2e52:	f840 3b04 	str.w	r3, [r0], #4
 80a2e56:	f7ff ff99 	bl	80a2d8c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_>
        t_ = t;
        d_ = d;
    }
}
 80a2e5a:	4620      	mov	r0, r4
 80a2e5c:	bd10      	pop	{r4, pc}

080a2e5e <_ZN5spark16JSONStreamWriter5writeEPKcj>:
inline Print* spark::JSONStreamWriter::stream() const {
    return &strm_;
}

inline void spark::JSONStreamWriter::write(const char *data, size_t size) {
    strm_.write((const uint8_t*)data, size);
 80a2e5e:	6880      	ldr	r0, [r0, #8]
 80a2e60:	6803      	ldr	r3, [r0, #0]
 80a2e62:	68db      	ldr	r3, [r3, #12]
 80a2e64:	4718      	bx	r3

080a2e66 <_ZN5spark20JSONStreamLogHandler5writeEPKcj>:
inline void spark::StreamLogHandler::printf(const char *fmt, ArgsT... args) {
    stream_->printf(fmt, args...);
}

// spark::JSONStreamLogHandler
inline void spark::JSONStreamLogHandler::write(const char *data, size_t size) {
 80a2e66:	4770      	bx	lr

080a2e68 <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE>:

#if Wiring_LogConfig

// spark::LogHandlerFactory
inline void spark::LogHandlerFactory::destroyHandler(LogHandler *handler) {
    delete handler;
 80a2e68:	b119      	cbz	r1, 80a2e72 <_ZN5spark17LogHandlerFactory14destroyHandlerEPNS_10LogHandlerE+0xa>
 80a2e6a:	680b      	ldr	r3, [r1, #0]
 80a2e6c:	4608      	mov	r0, r1
 80a2e6e:	685b      	ldr	r3, [r3, #4]
 80a2e70:	4718      	bx	r3
 80a2e72:	4770      	bx	lr

080a2e74 <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print>:
}

// spark::OutputStreamFactory
inline void spark::OutputStreamFactory::destroyStream(Print *stream) {
    delete stream;
 80a2e74:	b119      	cbz	r1, 80a2e7e <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print+0xa>
 80a2e76:	680b      	ldr	r3, [r1, #0]
 80a2e78:	4608      	mov	r0, r1
 80a2e7a:	685b      	ldr	r3, [r3, #4]
 80a2e7c:	4718      	bx	r3
 80a2e7e:	4770      	bx	lr

080a2e80 <_ZN5spark26DefaultOutputStreamFactoryD1Ev>:

    virtual Print* createStream(const char *type, const JSONValue &params) = 0;
    virtual void destroyStream(Print *stream);
};

class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a2e80:	4770      	bx	lr

080a2e82 <_ZN5spark24DefaultLogHandlerFactoryD1Ev>:
    virtual LogHandler* createHandler(const char *type, LogLevel level, LogCategoryFilters filters, Print *stream,
            const JSONValue &params) = 0; // TODO: Use some generic container or a buffer instead of JSONValue
    virtual void destroyHandler(LogHandler *handler);
};

class DefaultLogHandlerFactory: public LogHandlerFactory {
 80a2e82:	4770      	bx	lr

080a2e84 <_ZN5spark16JSONStreamWriterD1Ev>:
    void writeSeparator();
    void writeEscaped(const char *data, size_t size);
    void write(char c);
};

class JSONStreamWriter: public JSONWriter {
 80a2e84:	4770      	bx	lr

080a2e86 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>:
    return s;
}
#endif

// Iterates over subcategory names separated by '.' character
const char* nextSubcategoryName(const char* &category, size_t &size) {
 80a2e86:	b538      	push	{r3, r4, r5, lr}
 80a2e88:	4604      	mov	r4, r0
 80a2e8a:	460d      	mov	r5, r1
    const char *s = strchrnul(category, '.');
 80a2e8c:	6800      	ldr	r0, [r0, #0]
 80a2e8e:	212e      	movs	r1, #46	; 0x2e
 80a2e90:	f002 f8a4 	bl	80a4fdc <strchrnul>
    size = s - category;
 80a2e94:	6823      	ldr	r3, [r4, #0]
 80a2e96:	1ac3      	subs	r3, r0, r3
 80a2e98:	602b      	str	r3, [r5, #0]
    if (size) {
 80a2e9a:	b123      	cbz	r3, 80a2ea6 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x20>
        if (*s) {
 80a2e9c:	7803      	ldrb	r3, [r0, #0]
 80a2e9e:	b103      	cbz	r3, 80a2ea2 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj+0x1c>
            ++s;
 80a2ea0:	3001      	adds	r0, #1
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a2ea2:	6823      	ldr	r3, [r4, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a2ea4:	6020      	str	r0, [r4, #0]
        }
        std::swap(s, category);
        return s;
    }
    return nullptr;
 80a2ea6:	4618      	mov	r0, r3
}
 80a2ea8:	bd38      	pop	{r3, r4, r5, pc}

080a2eaa <_ZN5spark16JSONStreamWriterD0Ev>:
 80a2eaa:	b510      	push	{r4, lr}
 80a2eac:	4604      	mov	r4, r0
 80a2eae:	f7fd f8f6 	bl	80a009e <_ZdlPv>
 80a2eb2:	4620      	mov	r0, r4
 80a2eb4:	bd10      	pop	{r4, pc}

080a2eb6 <_ZN5spark24DefaultLogHandlerFactoryD0Ev>:
 80a2eb6:	b510      	push	{r4, lr}
 80a2eb8:	4604      	mov	r4, r0
 80a2eba:	f7fd f8f0 	bl	80a009e <_ZdlPv>
 80a2ebe:	4620      	mov	r0, r4
 80a2ec0:	bd10      	pop	{r4, pc}

080a2ec2 <_ZN5spark26DefaultOutputStreamFactoryD0Ev>:

    virtual Print* createStream(const char *type, const JSONValue &params) = 0;
    virtual void destroyStream(Print *stream);
};

class DefaultOutputStreamFactory: public OutputStreamFactory {
 80a2ec2:	b510      	push	{r4, lr}
 80a2ec4:	4604      	mov	r4, r0
 80a2ec6:	f7fd f8ea 	bl	80a009e <_ZdlPv>
 80a2eca:	4620      	mov	r0, r4
 80a2ecc:	bd10      	pop	{r4, pc}

080a2ece <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print>:
    }
#endif // PLATFORM_ID != 3
    return nullptr;
}

void spark::DefaultOutputStreamFactory::destroyStream(Print *stream) {
 80a2ece:	b538      	push	{r3, r4, r5, lr}
 80a2ed0:	460c      	mov	r4, r1
 80a2ed2:	4605      	mov	r5, r0
#if PLATFORM_ID != 3
    if (stream == &Serial) {
 80a2ed4:	f001 fc96 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a2ed8:	4284      	cmp	r4, r0
 80a2eda:	d102      	bne.n	80a2ee2 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x14>
        Serial.end();
 80a2edc:	f001 fc92 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a2ee0:	e005      	b.n	80a2eee <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x20>
        return;
    }
#if Wiring_USBSerial1
    if (stream == &USBSerial1) {
 80a2ee2:	f001 fccb 	bl	80a487c <_Z17_fetch_usbserial1v>
 80a2ee6:	4284      	cmp	r4, r0
 80a2ee8:	d105      	bne.n	80a2ef6 <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x28>
        USBSerial1.end();
 80a2eea:	f001 fcc7 	bl	80a487c <_Z17_fetch_usbserial1v>
        Serial1.end();
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}
 80a2eee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        Serial.end();
        return;
    }
#if Wiring_USBSerial1
    if (stream == &USBSerial1) {
        USBSerial1.end();
 80a2ef2:	f001 bc6d 	b.w	80a47d0 <_ZN9USBSerial3endEv>
        return;
    }
#endif
    if (stream == &Serial1) {
 80a2ef6:	f001 fc03 	bl	80a4700 <_Z22__fetch_global_Serial1v>
 80a2efa:	4284      	cmp	r4, r0
 80a2efc:	d105      	bne.n	80a2f0a <_ZN5spark26DefaultOutputStreamFactory13destroyStreamEP5Print+0x3c>
        Serial1.end();
 80a2efe:	f001 fbff 	bl	80a4700 <_Z22__fetch_global_Serial1v>
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}
 80a2f02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        USBSerial1.end();
        return;
    }
#endif
    if (stream == &Serial1) {
        Serial1.end();
 80a2f06:	f001 bbf4 	b.w	80a46f2 <_ZN11USARTSerial3endEv>
        return;
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
 80a2f0a:	4621      	mov	r1, r4
 80a2f0c:	4628      	mov	r0, r5
 80a2f0e:	f7ff ffb1 	bl	80a2e74 <_ZN5spark19OutputStreamFactory13destroyStreamEP5Print>
 80a2f12:	bd38      	pop	{r3, r4, r5, pc}

080a2f14 <_ZNK5spark10JSONStringeqEPKc.isra.7>:

inline bool spark::JSONString::isEmpty() const {
    return !n_;
}

inline bool spark::JSONString::operator==(const char *str) const {
 80a2f14:	b508      	push	{r3, lr}
    return strcmp(s_, str) == 0;
 80a2f16:	f002 f86b 	bl	80a4ff0 <strcmp>
}
 80a2f1a:	fab0 f080 	clz	r0, r0
 80a2f1e:	0940      	lsrs	r0, r0, #5
 80a2f20:	bd08      	pop	{r3, pc}

080a2f22 <_ZN5spark10JSONWriter5valueEPKc>:

inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a2f22:	b538      	push	{r3, r4, r5, lr}
 80a2f24:	4605      	mov	r5, r0
    return value(val, strlen(val));
 80a2f26:	4608      	mov	r0, r1

inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
 80a2f28:	460c      	mov	r4, r1
    return value(val, strlen(val));
 80a2f2a:	f002 f86b 	bl	80a5004 <strlen>
 80a2f2e:	4621      	mov	r1, r4
 80a2f30:	4602      	mov	r2, r0
 80a2f32:	4628      	mov	r0, r5
}
 80a2f34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
inline spark::JSONWriter& spark::JSONWriter::name(const String &name) {
    return this->name(name.c_str(), name.length());
}

inline spark::JSONWriter& spark::JSONWriter::value(const char *val) {
    return value(val, strlen(val));
 80a2f38:	f7ff bf19 	b.w	80a2d6e <_ZN5spark10JSONWriter5valueEPKcj>

080a2f3c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
    }
    write("\r\n", 2);
}

// spark::JSONStreamLogHandler
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a2f3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a2f40:	4691      	mov	r9, r2
 80a2f42:	b085      	sub	sp, #20
    write(&c, 1);
}

// spark::JSONStreamWriter
inline spark::JSONStreamWriter::JSONStreamWriter(Print &stream) :
        strm_(stream) {
 80a2f44:	4a49      	ldr	r2, [pc, #292]	; (80a306c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x130>)
 80a2f46:	461d      	mov	r5, r3
 80a2f48:	6a03      	ldr	r3, [r0, #32]
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a2f4a:	f04f 0800 	mov.w	r8, #0
 80a2f4e:	4607      	mov	r7, r0
    JSONStreamWriter json(*this->stream());
    json.beginObject();
 80a2f50:	a801      	add	r0, sp, #4
    }
    write("\r\n", 2);
}

// spark::JSONStreamLogHandler
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a2f52:	460e      	mov	r6, r1
    write(&c, 1);
}

// spark::JSONStreamWriter
inline spark::JSONStreamWriter::JSONStreamWriter(Print &stream) :
        strm_(stream) {
 80a2f54:	9201      	str	r2, [sp, #4]
 80a2f56:	9303      	str	r3, [sp, #12]
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a2f58:	f88d 8008 	strb.w	r8, [sp, #8]
 80a2f5c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    JSONStreamWriter json(*this->stream());
    json.beginObject();
 80a2f5e:	f7ff fe72 	bl	80a2c46 <_ZN5spark10JSONWriter11beginObjectEv>
inline LogLevel spark::LogHandler::level(const char *category) const {
    return filter_.level(category);
}

inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
 80a2f62:	4641      	mov	r1, r8
 80a2f64:	4648      	mov	r0, r9
 80a2f66:	f7ff fc51 	bl	80a280c <log_level_name>
 80a2f6a:	4680      	mov	r8, r0
    // Level
    const char *s = levelName(level);
    json.name("l", 1).value(s);
 80a2f6c:	4940      	ldr	r1, [pc, #256]	; (80a3070 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x134>)
 80a2f6e:	2201      	movs	r2, #1
 80a2f70:	a801      	add	r0, sp, #4
 80a2f72:	f7ff feed 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a2f76:	4641      	mov	r1, r8
 80a2f78:	f7ff ffd3 	bl	80a2f22 <_ZN5spark10JSONWriter5valueEPKc>
    // Message
    if (msg) {
 80a2f7c:	b13e      	cbz	r6, 80a2f8e <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x52>
        json.name("m", 1).value(msg);
 80a2f7e:	493d      	ldr	r1, [pc, #244]	; (80a3074 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x138>)
 80a2f80:	2201      	movs	r2, #1
 80a2f82:	a801      	add	r0, sp, #4
 80a2f84:	f7ff fee4 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a2f88:	4631      	mov	r1, r6
 80a2f8a:	f7ff ffca 	bl	80a2f22 <_ZN5spark10JSONWriter5valueEPKc>
    }
    // Category
    if (category) {
 80a2f8e:	b13d      	cbz	r5, 80a2fa0 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x64>
        json.name("c", 1).value(category);
 80a2f90:	4939      	ldr	r1, [pc, #228]	; (80a3078 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x13c>)
 80a2f92:	2201      	movs	r2, #1
 80a2f94:	a801      	add	r0, sp, #4
 80a2f96:	f7ff fedb 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a2f9a:	4629      	mov	r1, r5
 80a2f9c:	f7ff ffc1 	bl	80a2f22 <_ZN5spark10JSONWriter5valueEPKc>
    }
    // File name
    if (attr.has_file) {
 80a2fa0:	7923      	ldrb	r3, [r4, #4]
 80a2fa2:	07de      	lsls	r6, r3, #31
 80a2fa4:	d50e      	bpl.n	80a2fc4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x88>
        s = extractFileName(attr.file); // Strip directory path
 80a2fa6:	68a5      	ldr	r5, [r4, #8]
    }
    return nullptr;
}

const char* extractFileName(const char *s) {
    const char *s1 = strrchr(s, '/');
 80a2fa8:	212f      	movs	r1, #47	; 0x2f
 80a2faa:	4628      	mov	r0, r5
 80a2fac:	f002 f85a 	bl	80a5064 <strrchr>
    if (s1) {
 80a2fb0:	b100      	cbz	r0, 80a2fb4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x78>
        return s1 + 1;
 80a2fb2:	1c45      	adds	r5, r0, #1
        json.name("c", 1).value(category);
    }
    // File name
    if (attr.has_file) {
        s = extractFileName(attr.file); // Strip directory path
        json.name("f", 1).value(s);
 80a2fb4:	4931      	ldr	r1, [pc, #196]	; (80a307c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x140>)
 80a2fb6:	2201      	movs	r2, #1
 80a2fb8:	a801      	add	r0, sp, #4
 80a2fba:	f7ff fec9 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a2fbe:	4629      	mov	r1, r5
 80a2fc0:	f7ff ffaf 	bl	80a2f22 <_ZN5spark10JSONWriter5valueEPKc>
    }
    // Line number
    if (attr.has_line) {
 80a2fc4:	7923      	ldrb	r3, [r4, #4]
 80a2fc6:	079d      	lsls	r5, r3, #30
 80a2fc8:	d507      	bpl.n	80a2fda <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x9e>
        json.name("ln", 2).value(attr.line);
 80a2fca:	492d      	ldr	r1, [pc, #180]	; (80a3080 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x144>)
 80a2fcc:	2202      	movs	r2, #2
 80a2fce:	a801      	add	r0, sp, #4
 80a2fd0:	f7ff febe 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a2fd4:	68e1      	ldr	r1, [r4, #12]
 80a2fd6:	f7ff fe43 	bl	80a2c60 <_ZN5spark10JSONWriter5valueEi>
    }
    // Function name
    if (attr.has_function) {
 80a2fda:	7923      	ldrb	r3, [r4, #4]
 80a2fdc:	0758      	lsls	r0, r3, #29
 80a2fde:	d516      	bpl.n	80a300e <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xd2>
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a2fe0:	6925      	ldr	r5, [r4, #16]
 80a2fe2:	462e      	mov	r6, r5
    return s;
}

const char* extractFuncName(const char *s, size_t *size) {
    const char *s1 = s;
    for (; *s; ++s) {
 80a2fe4:	4633      	mov	r3, r6
 80a2fe6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a2fea:	b13a      	cbz	r2, 80a2ffc <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc0>
        if (*s == ' ') {
 80a2fec:	2a20      	cmp	r2, #32
 80a2fee:	d101      	bne.n	80a2ff4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb8>
            s1 = s + 1; // Skip return type
 80a2ff0:	461d      	mov	r5, r3
 80a2ff2:	e001      	b.n	80a2ff8 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xbc>
        } else if (*s == '(') {
 80a2ff4:	2a28      	cmp	r2, #40	; 0x28
 80a2ff6:	d001      	beq.n	80a2ffc <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xc0>
    }
    write("\r\n", 2);
}

// spark::JSONStreamLogHandler
void spark::JSONStreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a2ff8:	461e      	mov	r6, r3
 80a2ffa:	e7f3      	b.n	80a2fe4 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xa8>
    }
    // Function name
    if (attr.has_function) {
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
        json.name("fn", 2).value(s, n);
 80a2ffc:	2202      	movs	r2, #2
 80a2ffe:	4921      	ldr	r1, [pc, #132]	; (80a3084 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x148>)
 80a3000:	a801      	add	r0, sp, #4
 80a3002:	f7ff fea5 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a3006:	1b72      	subs	r2, r6, r5
 80a3008:	4629      	mov	r1, r5
 80a300a:	f7ff feb0 	bl	80a2d6e <_ZN5spark10JSONWriter5valueEPKcj>
    }
    // Timestamp
    if (attr.has_time) {
 80a300e:	7923      	ldrb	r3, [r4, #4]
 80a3010:	0719      	lsls	r1, r3, #28
 80a3012:	d507      	bpl.n	80a3024 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xe8>
        json.name("t", 1).value((unsigned)attr.time);
 80a3014:	491c      	ldr	r1, [pc, #112]	; (80a3088 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x14c>)
 80a3016:	2201      	movs	r2, #1
 80a3018:	a801      	add	r0, sp, #4
 80a301a:	f7ff fe99 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a301e:	6961      	ldr	r1, [r4, #20]
 80a3020:	f7ff fe30 	bl	80a2c84 <_ZN5spark10JSONWriter5valueEj>
    }
    // Code (additional attribute)
    if (attr.has_code) {
 80a3024:	7923      	ldrb	r3, [r4, #4]
 80a3026:	06da      	lsls	r2, r3, #27
 80a3028:	d508      	bpl.n	80a303c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x100>
        json.name("code", 4).value((int)attr.code);
 80a302a:	2204      	movs	r2, #4
 80a302c:	4917      	ldr	r1, [pc, #92]	; (80a308c <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x150>)
 80a302e:	eb0d 0002 	add.w	r0, sp, r2
 80a3032:	f7ff fe8d 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a3036:	69a1      	ldr	r1, [r4, #24]
 80a3038:	f7ff fe12 	bl	80a2c60 <_ZN5spark10JSONWriter5valueEi>
    }
    // Details (additional attribute)
    if (attr.has_details) {
 80a303c:	7923      	ldrb	r3, [r4, #4]
 80a303e:	069b      	lsls	r3, r3, #26
 80a3040:	d507      	bpl.n	80a3052 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x116>
        json.name("detail", 6).value(attr.details);
 80a3042:	4913      	ldr	r1, [pc, #76]	; (80a3090 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x154>)
 80a3044:	2206      	movs	r2, #6
 80a3046:	a801      	add	r0, sp, #4
 80a3048:	f7ff fe82 	bl	80a2d50 <_ZN5spark10JSONWriter4nameEPKcj>
 80a304c:	69e1      	ldr	r1, [r4, #28]
 80a304e:	f7ff ff68 	bl	80a2f22 <_ZN5spark10JSONWriter5valueEPKc>
    }
    json.endObject();
 80a3052:	a801      	add	r0, sp, #4
 80a3054:	f7ff fde1 	bl	80a2c1a <_ZN5spark10JSONWriter9endObjectEv>
 80a3058:	6a38      	ldr	r0, [r7, #32]
    this->stream()->write((const uint8_t*)"\r\n", 2);
 80a305a:	2202      	movs	r2, #2
 80a305c:	6803      	ldr	r3, [r0, #0]
 80a305e:	490d      	ldr	r1, [pc, #52]	; (80a3094 <_ZN5spark20JSONStreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x158>)
 80a3060:	68db      	ldr	r3, [r3, #12]
 80a3062:	4798      	blx	r3
}
 80a3064:	b005      	add	sp, #20
 80a3066:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a306a:	bf00      	nop
 80a306c:	080a5934 	.word	0x080a5934
 80a3070:	080a59b7 	.word	0x080a59b7
 80a3074:	080a59cd 	.word	0x080a59cd
 80a3078:	080a5a46 	.word	0x080a5a46
 80a307c:	080a5974 	.word	0x080a5974
 80a3080:	080a5976 	.word	0x080a5976
 80a3084:	080a5979 	.word	0x080a5979
 80a3088:	080a59e2 	.word	0x080a59e2
 80a308c:	080a597c 	.word	0x080a597c
 80a3090:	080a5981 	.word	0x080a5981
 80a3094:	080a54a3 	.word	0x080a54a3

080a3098 <_ZN14RecursiveMutex4lockEv>:
            os_mutex_recursive_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
 80a3098:	6800      	ldr	r0, [r0, #0]
 80a309a:	f7ff b9f5 	b.w	80a2488 <os_mutex_recursive_lock>

080a309e <_ZN5spark16StreamLogHandler5writeEPKc>:

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
 80a309e:	b570      	push	{r4, r5, r6, lr}
 80a30a0:	4604      	mov	r4, r0
    write(str, strlen(str));
 80a30a2:	4608      	mov	r0, r1

inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
 80a30a4:	460d      	mov	r5, r1
    write(str, strlen(str));
 80a30a6:	f001 ffad 	bl	80a5004 <strlen>
 80a30aa:	6823      	ldr	r3, [r4, #0]
 80a30ac:	4602      	mov	r2, r0
 80a30ae:	4629      	mov	r1, r5
 80a30b0:	4620      	mov	r0, r4
}
 80a30b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
inline void spark::StreamLogHandler::write(const char *data, size_t size) {
    stream_->write((const uint8_t*)data, size);
}

inline void spark::StreamLogHandler::write(const char *str) {
    write(str, strlen(str));
 80a30b6:	68db      	ldr	r3, [r3, #12]
 80a30b8:	4718      	bx	r3

080a30ba <_ZN5spark16StreamLogHandler5writeEc>:
}

inline void spark::StreamLogHandler::write(char c) {
 80a30ba:	b513      	push	{r0, r1, r4, lr}
    write(&c, 1);
 80a30bc:	6802      	ldr	r2, [r0, #0]

inline void spark::StreamLogHandler::write(const char *str) {
    write(str, strlen(str));
}

inline void spark::StreamLogHandler::write(char c) {
 80a30be:	ab02      	add	r3, sp, #8
 80a30c0:	f803 1d01 	strb.w	r1, [r3, #-1]!
    write(&c, 1);
 80a30c4:	68d4      	ldr	r4, [r2, #12]
 80a30c6:	4619      	mov	r1, r3
 80a30c8:	2201      	movs	r2, #1
 80a30ca:	47a0      	blx	r4
}
 80a30cc:	b002      	add	sp, #8
 80a30ce:	bd10      	pop	{r4, pc}

080a30d0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes>:
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a30d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a30d4:	9d06      	ldr	r5, [sp, #24]
 80a30d6:	4698      	mov	r8, r3
    const char *s = nullptr;
    // Timestamp
    if (attr.has_time) {
 80a30d8:	792b      	ldrb	r3, [r5, #4]
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a30da:	460e      	mov	r6, r1
    const char *s = nullptr;
    // Timestamp
    if (attr.has_time) {
 80a30dc:	0719      	lsls	r1, r3, #28
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a30de:	4604      	mov	r4, r0
 80a30e0:	4617      	mov	r7, r2
    const char *s = nullptr;
    // Timestamp
    if (attr.has_time) {
 80a30e2:	d505      	bpl.n	80a30f0 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x20>
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a30e4:	696b      	ldr	r3, [r5, #20]
 80a30e6:	4a54      	ldr	r2, [pc, #336]	; (80a3238 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x168>)
 80a30e8:	2100      	movs	r1, #0
 80a30ea:	6a00      	ldr	r0, [r0, #32]
 80a30ec:	f000 ff0d 	bl	80a3f0a <_ZN5Print11printf_implEbPKcz>
        printf("%010u ", (unsigned)attr.time);
    }
    // Category
    if (category) {
 80a30f0:	f1b8 0f00 	cmp.w	r8, #0
 80a30f4:	d00d      	beq.n	80a3112 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x42>
        write('[');
 80a30f6:	215b      	movs	r1, #91	; 0x5b
 80a30f8:	4620      	mov	r0, r4
 80a30fa:	f7ff ffde 	bl	80a30ba <_ZN5spark16StreamLogHandler5writeEc>
        write(category);
 80a30fe:	4641      	mov	r1, r8
 80a3100:	4620      	mov	r0, r4
 80a3102:	f7ff ffcc 	bl	80a309e <_ZN5spark16StreamLogHandler5writeEPKc>
        write("] ", 2);
 80a3106:	6823      	ldr	r3, [r4, #0]
 80a3108:	2202      	movs	r2, #2
 80a310a:	68db      	ldr	r3, [r3, #12]
 80a310c:	494b      	ldr	r1, [pc, #300]	; (80a323c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x16c>)
 80a310e:	4620      	mov	r0, r4
 80a3110:	4798      	blx	r3
    }
    // Source file
    if (attr.has_file) {
 80a3112:	792b      	ldrb	r3, [r5, #4]
 80a3114:	07da      	lsls	r2, r3, #31
 80a3116:	d525      	bpl.n	80a3164 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x94>
        s = extractFileName(attr.file); // Strip directory path
 80a3118:	f8d5 8008 	ldr.w	r8, [r5, #8]
    }
    return nullptr;
}

const char* extractFileName(const char *s) {
    const char *s1 = strrchr(s, '/');
 80a311c:	212f      	movs	r1, #47	; 0x2f
 80a311e:	4640      	mov	r0, r8
 80a3120:	f001 ffa0 	bl	80a5064 <strrchr>
    if (s1) {
 80a3124:	b108      	cbz	r0, 80a312a <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x5a>
        return s1 + 1;
 80a3126:	f100 0801 	add.w	r8, r0, #1
        write("] ", 2);
    }
    // Source file
    if (attr.has_file) {
        s = extractFileName(attr.file); // Strip directory path
        write(s); // File name
 80a312a:	4641      	mov	r1, r8
 80a312c:	4620      	mov	r0, r4
 80a312e:	f7ff ffb6 	bl	80a309e <_ZN5spark16StreamLogHandler5writeEPKc>
        if (attr.has_line) {
 80a3132:	792b      	ldrb	r3, [r5, #4]
 80a3134:	079b      	lsls	r3, r3, #30
 80a3136:	d509      	bpl.n	80a314c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x7c>
            write(':');
 80a3138:	213a      	movs	r1, #58	; 0x3a
 80a313a:	4620      	mov	r0, r4
 80a313c:	f7ff ffbd 	bl	80a30ba <_ZN5spark16StreamLogHandler5writeEc>
 80a3140:	68eb      	ldr	r3, [r5, #12]
 80a3142:	4a3f      	ldr	r2, [pc, #252]	; (80a3240 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x170>)
 80a3144:	2100      	movs	r1, #0
 80a3146:	6a20      	ldr	r0, [r4, #32]
 80a3148:	f000 fedf 	bl	80a3f0a <_ZN5Print11printf_implEbPKcz>
            printf("%d", (int)attr.line); // Line number
        }
        if (attr.has_function) {
 80a314c:	792b      	ldrb	r3, [r5, #4]
            write(", ", 2);
 80a314e:	2202      	movs	r2, #2
        write(s); // File name
        if (attr.has_line) {
            write(':');
            printf("%d", (int)attr.line); // Line number
        }
        if (attr.has_function) {
 80a3150:	f013 0f04 	tst.w	r3, #4
 80a3154:	6823      	ldr	r3, [r4, #0]
            write(", ", 2);
 80a3156:	bf18      	it	ne
 80a3158:	493a      	ldrne	r1, [pc, #232]	; (80a3244 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x174>)
 80a315a:	68db      	ldr	r3, [r3, #12]
        } else {
            write(": ", 2);
 80a315c:	bf08      	it	eq
 80a315e:	493a      	ldreq	r1, [pc, #232]	; (80a3248 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x178>)
 80a3160:	4620      	mov	r0, r4
 80a3162:	4798      	blx	r3
        }
    }
    // Function name
    if (attr.has_function) {
 80a3164:	792b      	ldrb	r3, [r5, #4]
 80a3166:	0758      	lsls	r0, r3, #29
 80a3168:	d518      	bpl.n	80a319c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xcc>
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
 80a316a:	6929      	ldr	r1, [r5, #16]
 80a316c:	460a      	mov	r2, r1
    return s;
}

const char* extractFuncName(const char *s, size_t *size) {
    const char *s1 = s;
    for (; *s; ++s) {
 80a316e:	4613      	mov	r3, r2
 80a3170:	f813 0b01 	ldrb.w	r0, [r3], #1
 80a3174:	b138      	cbz	r0, 80a3186 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
        if (*s == ' ') {
 80a3176:	2820      	cmp	r0, #32
 80a3178:	d101      	bne.n	80a317e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xae>
            s1 = s + 1; // Skip return type
 80a317a:	4619      	mov	r1, r3
 80a317c:	e001      	b.n	80a3182 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb2>
        } else if (*s == '(') {
 80a317e:	2828      	cmp	r0, #40	; 0x28
 80a3180:	d001      	beq.n	80a3186 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xb6>
                return cmp < 0;
            }));
}

// spark::StreamLogHandler
void spark::StreamLogHandler::logMessage(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
 80a3182:	461a      	mov	r2, r3
 80a3184:	e7f3      	b.n	80a316e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x9e>
    }
    // Function name
    if (attr.has_function) {
        size_t n = 0;
        s = extractFuncName(attr.function, &n); // Strip argument and return types
        write(s, n);
 80a3186:	6823      	ldr	r3, [r4, #0]
 80a3188:	1a52      	subs	r2, r2, r1
 80a318a:	68db      	ldr	r3, [r3, #12]
 80a318c:	4620      	mov	r0, r4
 80a318e:	4798      	blx	r3
        write("(): ", 4);
 80a3190:	6823      	ldr	r3, [r4, #0]
 80a3192:	2204      	movs	r2, #4
 80a3194:	68db      	ldr	r3, [r3, #12]
 80a3196:	492d      	ldr	r1, [pc, #180]	; (80a324c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x17c>)
 80a3198:	4620      	mov	r0, r4
 80a319a:	4798      	blx	r3
inline LogLevel spark::LogHandler::level(const char *category) const {
    return filter_.level(category);
}

inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
 80a319c:	2100      	movs	r1, #0
 80a319e:	4638      	mov	r0, r7
 80a31a0:	f7ff fb34 	bl	80a280c <log_level_name>
    }
    // Level
    s = levelName(level);
    write(s);
 80a31a4:	4601      	mov	r1, r0
 80a31a6:	4620      	mov	r0, r4
 80a31a8:	f7ff ff79 	bl	80a309e <_ZN5spark16StreamLogHandler5writeEPKc>
    write(": ", 2);
 80a31ac:	6823      	ldr	r3, [r4, #0]
 80a31ae:	2202      	movs	r2, #2
 80a31b0:	68db      	ldr	r3, [r3, #12]
 80a31b2:	4925      	ldr	r1, [pc, #148]	; (80a3248 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x178>)
 80a31b4:	4620      	mov	r0, r4
 80a31b6:	4798      	blx	r3
    // Message
    if (msg) {
 80a31b8:	b11e      	cbz	r6, 80a31c2 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0xf2>
        write(msg);
 80a31ba:	4631      	mov	r1, r6
 80a31bc:	4620      	mov	r0, r4
 80a31be:	f7ff ff6e 	bl	80a309e <_ZN5spark16StreamLogHandler5writeEPKc>
    }
    // Additional attributes
    if (attr.has_code || attr.has_details) {
 80a31c2:	792b      	ldrb	r3, [r5, #4]
 80a31c4:	f013 0f30 	tst.w	r3, #48	; 0x30
 80a31c8:	d02d      	beq.n	80a3226 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x156>
        write(" [", 2);
 80a31ca:	6823      	ldr	r3, [r4, #0]
 80a31cc:	4920      	ldr	r1, [pc, #128]	; (80a3250 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x180>)
 80a31ce:	68db      	ldr	r3, [r3, #12]
 80a31d0:	2202      	movs	r2, #2
 80a31d2:	4620      	mov	r0, r4
 80a31d4:	4798      	blx	r3
        // Code
        if (attr.has_code) {
 80a31d6:	792b      	ldrb	r3, [r5, #4]
 80a31d8:	06d9      	lsls	r1, r3, #27
 80a31da:	d50b      	bpl.n	80a31f4 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x124>
            write("code = ", 7);
 80a31dc:	6823      	ldr	r3, [r4, #0]
 80a31de:	2207      	movs	r2, #7
 80a31e0:	68db      	ldr	r3, [r3, #12]
 80a31e2:	491c      	ldr	r1, [pc, #112]	; (80a3254 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x184>)
 80a31e4:	4620      	mov	r0, r4
 80a31e6:	4798      	blx	r3
 80a31e8:	69ab      	ldr	r3, [r5, #24]
 80a31ea:	4a1b      	ldr	r2, [pc, #108]	; (80a3258 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x188>)
 80a31ec:	2100      	movs	r1, #0
 80a31ee:	6a20      	ldr	r0, [r4, #32]
 80a31f0:	f000 fe8b 	bl	80a3f0a <_ZN5Print11printf_implEbPKcz>
            printf("%" PRIiPTR, (intptr_t)attr.code);
        }
        // Details
        if (attr.has_details) {
 80a31f4:	792b      	ldrb	r3, [r5, #4]
 80a31f6:	069a      	lsls	r2, r3, #26
 80a31f8:	d511      	bpl.n	80a321e <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x14e>
            if (attr.has_code) {
 80a31fa:	06db      	lsls	r3, r3, #27
 80a31fc:	d505      	bpl.n	80a320a <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x13a>
                write(", ", 2);
 80a31fe:	6823      	ldr	r3, [r4, #0]
 80a3200:	2202      	movs	r2, #2
 80a3202:	68db      	ldr	r3, [r3, #12]
 80a3204:	490f      	ldr	r1, [pc, #60]	; (80a3244 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x174>)
 80a3206:	4620      	mov	r0, r4
 80a3208:	4798      	blx	r3
            }
            write("details = ", 10);
 80a320a:	6823      	ldr	r3, [r4, #0]
 80a320c:	4913      	ldr	r1, [pc, #76]	; (80a325c <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x18c>)
 80a320e:	4620      	mov	r0, r4
 80a3210:	68db      	ldr	r3, [r3, #12]
 80a3212:	220a      	movs	r2, #10
 80a3214:	4798      	blx	r3
            write(attr.details);
 80a3216:	69e9      	ldr	r1, [r5, #28]
 80a3218:	4620      	mov	r0, r4
 80a321a:	f7ff ff40 	bl	80a309e <_ZN5spark16StreamLogHandler5writeEPKc>
        }
        write(']');
 80a321e:	215d      	movs	r1, #93	; 0x5d
 80a3220:	4620      	mov	r0, r4
 80a3222:	f7ff ff4a 	bl	80a30ba <_ZN5spark16StreamLogHandler5writeEc>
    }
    write("\r\n", 2);
 80a3226:	6823      	ldr	r3, [r4, #0]
 80a3228:	4620      	mov	r0, r4
}
 80a322a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            write("details = ", 10);
            write(attr.details);
        }
        write(']');
    }
    write("\r\n", 2);
 80a322e:	68db      	ldr	r3, [r3, #12]
 80a3230:	2202      	movs	r2, #2
 80a3232:	490b      	ldr	r1, [pc, #44]	; (80a3260 <_ZN5spark16StreamLogHandler10logMessageEPKc8LogLevelS2_RK13LogAttributes+0x190>)
 80a3234:	4718      	bx	r3
 80a3236:	bf00      	nop
 80a3238:	080a5988 	.word	0x080a5988
 80a323c:	080a524a 	.word	0x080a524a
 80a3240:	080a5917 	.word	0x080a5917
 80a3244:	080a598f 	.word	0x080a598f
 80a3248:	080a5994 	.word	0x080a5994
 80a324c:	080a5992 	.word	0x080a5992
 80a3250:	080a5997 	.word	0x080a5997
 80a3254:	080a599a 	.word	0x080a599a
 80a3258:	080a524d 	.word	0x080a524d
 80a325c:	080a59a2 	.word	0x080a59a2
 80a3260:	080a54a3 	.word	0x080a54a3

080a3264 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>:
        }
    }
    return level;
}

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a3264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3268:	6807      	ldr	r7, [r0, #0]
 80a326a:	468b      	mov	fp, r1
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
 80a326c:	463c      	mov	r4, r7
 80a326e:	6845      	ldr	r5, [r0, #4]
 80a3270:	4691      	mov	r9, r2
 80a3272:	2214      	movs	r2, #20
 80a3274:	4355      	muls	r5, r2
 80a3276:	b085      	sub	sp, #20
 80a3278:	9301      	str	r3, [sp, #4]
 80a327a:	10ab      	asrs	r3, r5, #2
 80a327c:	4d18      	ldr	r5, [pc, #96]	; (80a32e0 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x7c>)
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
 80a327e:	9202      	str	r2, [sp, #8]
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
 80a3280:	435d      	muls	r5, r3
    return std::distance(nodes.begin(), std::lower_bound(nodes.begin(), nodes.end(), std::make_pair(name, size),
            [&found](const Node &node, const std::pair<const char*, size_t> &value) {
                const int cmp = strncmp(node.name, value.first, std::min<size_t>(node.size, value.second));
                if (cmp == 0) {
                    if (node.size == value.second) { // Lengths are equal
                        found = true; // Allows caller code to avoid extra call to strncmp()
 80a3282:	2301      	movs	r3, #1
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 80a3284:	2d00      	cmp	r5, #0
 80a3286:	9303      	str	r3, [sp, #12]
 80a3288:	dd23      	ble.n	80a32d2 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x6e>
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
 80a328a:	9b02      	ldr	r3, [sp, #8]
	{
	  _DistanceType __half = __len >> 1;
 80a328c:	106e      	asrs	r6, r5, #1
 80a328e:	fb03 f006 	mul.w	r0, r3, r6
 80a3292:	eb04 0800 	add.w	r8, r4, r0

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
    // Using binary search to find existent node or suitable position for new node
    return std::distance(nodes.begin(), std::lower_bound(nodes.begin(), nodes.end(), std::make_pair(name, size),
            [&found](const Node &node, const std::pair<const char*, size_t> &value) {
                const int cmp = strncmp(node.name, value.first, std::min<size_t>(node.size, value.second));
 80a3296:	f8b8 a004 	ldrh.w	sl, [r8, #4]
 80a329a:	464a      	mov	r2, r9
 80a329c:	45d1      	cmp	r9, sl
 80a329e:	bf28      	it	cs
 80a32a0:	4652      	movcs	r2, sl
 80a32a2:	4659      	mov	r1, fp
 80a32a4:	5820      	ldr	r0, [r4, r0]
 80a32a6:	f001 feb5 	bl	80a5014 <strncmp>
                if (cmp == 0) {
 80a32aa:	9b03      	ldr	r3, [sp, #12]
 80a32ac:	b948      	cbnz	r0, 80a32c2 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x5e>
                    if (node.size == value.second) { // Lengths are equal
 80a32ae:	45d1      	cmp	r9, sl
 80a32b0:	d103      	bne.n	80a32ba <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x56>
                        found = true; // Allows caller code to avoid extra call to strncmp()
 80a32b2:	9a01      	ldr	r2, [sp, #4]
 80a32b4:	7013      	strb	r3, [r2, #0]
        }
    }
    return level;
}

int spark::detail::LogFilter::nodeIndex(const Vector<Node> &nodes, const char *name, size_t size, bool &found) {
 80a32b6:	4635      	mov	r5, r6
 80a32b8:	e7e4      	b.n	80a3284 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x20>
                if (cmp == 0) {
                    if (node.size == value.second) { // Lengths are equal
                        found = true; // Allows caller code to avoid extra call to strncmp()
                        return false;
                    }
                    return node.size < value.second;
 80a32ba:	bf8c      	ite	hi
 80a32bc:	2001      	movhi	r0, #1
 80a32be:	2000      	movls	r0, #0
 80a32c0:	e000      	b.n	80a32c4 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x60>
                }
                return cmp < 0;
 80a32c2:	0fc0      	lsrs	r0, r0, #31
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
 80a32c4:	2800      	cmp	r0, #0
 80a32c6:	d0f6      	beq.n	80a32b6 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x52>
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
 80a32c8:	1bae      	subs	r6, r5, r6
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
	    {
	      __first = __middle;
	      ++__first;
 80a32ca:	f108 0414 	add.w	r4, r8, #20
	      __len = __len - __half - 1;
 80a32ce:	3e01      	subs	r6, #1
 80a32d0:	e7f1      	b.n	80a32b6 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x52>
            }));
 80a32d2:	1be4      	subs	r4, r4, r7
}
 80a32d4:	4802      	ldr	r0, [pc, #8]	; (80a32e0 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb+0x7c>)
                        return false;
                    }
                    return node.size < value.second;
                }
                return cmp < 0;
            }));
 80a32d6:	10a4      	asrs	r4, r4, #2
}
 80a32d8:	4360      	muls	r0, r4
 80a32da:	b005      	add	sp, #20
 80a32dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a32e0:	cccccccd 	.word	0xcccccccd

080a32e4 <_ZNK5spark6detail9LogFilter5levelEPKc>:
}

spark::detail::LogFilter::~LogFilter() {
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a32e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
 80a32e6:	6903      	ldr	r3, [r0, #16]
}

spark::detail::LogFilter::~LogFilter() {
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
 80a32e8:	b085      	sub	sp, #20
 80a32ea:	9101      	str	r1, [sp, #4]
    LogLevel level = level_; // Default level
 80a32ec:	7e06      	ldrb	r6, [r0, #24]
    if (!nodes_.isEmpty() && category) {
 80a32ee:	b313      	cbz	r3, 80a3336 <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
 80a32f0:	b309      	cbz	r1, 80a3336 <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a32f2:	2300      	movs	r3, #0
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
 80a32f4:	461d      	mov	r5, r3
LogLevel spark::detail::LogFilter::level(const char *category) const {
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a32f6:	af04      	add	r7, sp, #16
}

LogLevel spark::detail::LogFilter::level(const char *category) const {
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
 80a32f8:	f100 040c 	add.w	r4, r0, #12
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a32fc:	f847 3d04 	str.w	r3, [r7, #-4]!
        while ((name = nextSubcategoryName(category, size))) {
 80a3300:	4639      	mov	r1, r7
 80a3302:	a801      	add	r0, sp, #4
 80a3304:	f7ff fdbf 	bl	80a2e86 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a3308:	4601      	mov	r1, r0
 80a330a:	b1a0      	cbz	r0, 80a3336 <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
            bool found = false;
 80a330c:	ab04      	add	r3, sp, #16
 80a330e:	f803 5d05 	strb.w	r5, [r3, #-5]!
            const int index = nodeIndex(*pNodes, name, size, found);
 80a3312:	9a03      	ldr	r2, [sp, #12]
 80a3314:	4620      	mov	r0, r4
 80a3316:	f7ff ffa5 	bl	80a3264 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found) {
 80a331a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80a331e:	b153      	cbz	r3, 80a3336 <_ZNK5spark6detail9LogFilter5levelEPKc+0x52>
    return data_[i];
}

template<typename T, typename AllocatorT>
inline const T& spark::Vector<T, AllocatorT>::at(int i) const {
    return data_[i];
 80a3320:	6823      	ldr	r3, [r4, #0]
 80a3322:	2414      	movs	r4, #20
 80a3324:	fb04 3400 	mla	r4, r4, r0, r3
                break;
            }
            const Node &node = pNodes->at(index);
            if (node.level >= 0) {
 80a3328:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
                level = (LogLevel)node.level;
            }
            pNodes = &node.nodes;
 80a332c:	3408      	adds	r4, #8
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found) {
                break;
            }
            const Node &node = pNodes->at(index);
            if (node.level >= 0) {
 80a332e:	2b00      	cmp	r3, #0
                level = (LogLevel)node.level;
 80a3330:	bfa8      	it	ge
 80a3332:	b2de      	uxtbge	r6, r3
    LogLevel level = level_; // Default level
    if (!nodes_.isEmpty() && category) {
        const Vector<Node> *pNodes = &nodes_; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a3334:	e7e4      	b.n	80a3300 <_ZNK5spark6detail9LogFilter5levelEPKc+0x1c>
            }
            pNodes = &node.nodes;
        }
    }
    return level;
}
 80a3336:	4630      	mov	r0, r6
 80a3338:	b005      	add	sp, #20
 80a333a:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a333c <_ZN5spark24DefaultLogHandlerFactory8instanceEv>:
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
    }
    return nullptr; // Unknown handler type
}

spark::DefaultLogHandlerFactory* spark::DefaultLogHandlerFactory::instance() {
 80a333c:	b510      	push	{r4, lr}
    static DefaultLogHandlerFactory factory;
 80a333e:	4c09      	ldr	r4, [pc, #36]	; (80a3364 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x28>)
 80a3340:	6823      	ldr	r3, [r4, #0]
 80a3342:	07db      	lsls	r3, r3, #31
 80a3344:	d40b      	bmi.n	80a335e <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a3346:	4620      	mov	r0, r4
 80a3348:	f7fc feb6 	bl	80a00b8 <__cxa_guard_acquire>
 80a334c:	b138      	cbz	r0, 80a335e <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x22>
 80a334e:	4620      	mov	r0, r4
 80a3350:	f7fc feb7 	bl	80a00c2 <__cxa_guard_release>
 80a3354:	4a04      	ldr	r2, [pc, #16]	; (80a3368 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x2c>)
 80a3356:	4905      	ldr	r1, [pc, #20]	; (80a336c <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x30>)
 80a3358:	4805      	ldr	r0, [pc, #20]	; (80a3370 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x34>)
 80a335a:	f001 fc5f 	bl	80a4c1c <__aeabi_atexit>
    return &factory;
}
 80a335e:	4804      	ldr	r0, [pc, #16]	; (80a3370 <_ZN5spark24DefaultLogHandlerFactory8instanceEv+0x34>)
 80a3360:	bd10      	pop	{r4, pc}
 80a3362:	bf00      	nop
 80a3364:	2000046c 	.word	0x2000046c
 80a3368:	2000039c 	.word	0x2000039c
 80a336c:	080a2e83 	.word	0x080a2e83
 80a3370:	20000328 	.word	0x20000328

080a3374 <_ZN5spark26DefaultOutputStreamFactory8instanceEv>:
    }
#endif // PLATFORM_ID != 3
    OutputStreamFactory::destroyStream(stream);
}

spark::DefaultOutputStreamFactory* spark::DefaultOutputStreamFactory::instance() {
 80a3374:	b510      	push	{r4, lr}
    static DefaultOutputStreamFactory factory;
 80a3376:	4c09      	ldr	r4, [pc, #36]	; (80a339c <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x28>)
 80a3378:	6823      	ldr	r3, [r4, #0]
 80a337a:	07db      	lsls	r3, r3, #31
 80a337c:	d40b      	bmi.n	80a3396 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a337e:	4620      	mov	r0, r4
 80a3380:	f7fc fe9a 	bl	80a00b8 <__cxa_guard_acquire>
 80a3384:	b138      	cbz	r0, 80a3396 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x22>
 80a3386:	4620      	mov	r0, r4
 80a3388:	f7fc fe9b 	bl	80a00c2 <__cxa_guard_release>
 80a338c:	4a04      	ldr	r2, [pc, #16]	; (80a33a0 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x2c>)
 80a338e:	4905      	ldr	r1, [pc, #20]	; (80a33a4 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x30>)
 80a3390:	4805      	ldr	r0, [pc, #20]	; (80a33a8 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x34>)
 80a3392:	f001 fc43 	bl	80a4c1c <__aeabi_atexit>
    return &factory;
}
 80a3396:	4804      	ldr	r0, [pc, #16]	; (80a33a8 <_ZN5spark26DefaultOutputStreamFactory8instanceEv+0x34>)
 80a3398:	bd10      	pop	{r4, pc}
 80a339a:	bf00      	nop
 80a339c:	2000049c 	.word	0x2000049c
 80a33a0:	2000039c 	.word	0x2000039c
 80a33a4:	080a2e81 	.word	0x080a2e81
 80a33a8:	2000032c 	.word	0x2000032c

080a33ac <_ZN5spark10LogManagerC1Ev>:
    Print *stream;
};

#endif // Wiring_LogConfig

spark::LogManager::LogManager() {
 80a33ac:	b538      	push	{r3, r4, r5, lr}
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a33ae:	2500      	movs	r5, #0
 80a33b0:	4604      	mov	r4, r0
 80a33b2:	6005      	str	r5, [r0, #0]
 80a33b4:	6045      	str	r5, [r0, #4]
 80a33b6:	6085      	str	r5, [r0, #8]
 80a33b8:	6105      	str	r5, [r0, #16]
 80a33ba:	6145      	str	r5, [r0, #20]
 80a33bc:	6185      	str	r5, [r0, #24]
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a33be:	f840 5f24 	str.w	r5, [r0, #36]!
    {
        os_mutex_recursive_create(&handle_);
 80a33c2:	f7ff f859 	bl	80a2478 <os_mutex_recursive_create>
#if Wiring_LogConfig
    handlerFactory_ = DefaultLogHandlerFactory::instance();
 80a33c6:	f7ff ffb9 	bl	80a333c <_ZN5spark24DefaultLogHandlerFactory8instanceEv>
 80a33ca:	61e0      	str	r0, [r4, #28]
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a33cc:	f7ff ffd2 	bl	80a3374 <_ZN5spark26DefaultOutputStreamFactory8instanceEv>
#endif
    outputActive_ = false;
 80a33d0:	7325      	strb	r5, [r4, #12]
#endif // Wiring_LogConfig

spark::LogManager::LogManager() {
#if Wiring_LogConfig
    handlerFactory_ = DefaultLogHandlerFactory::instance();
    streamFactory_ = DefaultOutputStreamFactory::instance();
 80a33d2:	6220      	str	r0, [r4, #32]
#endif
    outputActive_ = false;
}
 80a33d4:	4620      	mov	r0, r4
 80a33d6:	bd38      	pop	{r3, r4, r5, pc}

080a33d8 <_ZN5spark10LogManager8instanceEv>:
            resetSystemCallbacks();
        }
    }
}

spark::LogManager* spark::LogManager::instance() {
 80a33d8:	b510      	push	{r4, lr}
    static LogManager mgr;
 80a33da:	4c0a      	ldr	r4, [pc, #40]	; (80a3404 <_ZN5spark10LogManager8instanceEv+0x2c>)
 80a33dc:	6823      	ldr	r3, [r4, #0]
 80a33de:	07db      	lsls	r3, r3, #31
 80a33e0:	d40e      	bmi.n	80a3400 <_ZN5spark10LogManager8instanceEv+0x28>
 80a33e2:	4620      	mov	r0, r4
 80a33e4:	f7fc fe68 	bl	80a00b8 <__cxa_guard_acquire>
 80a33e8:	b150      	cbz	r0, 80a3400 <_ZN5spark10LogManager8instanceEv+0x28>
 80a33ea:	4807      	ldr	r0, [pc, #28]	; (80a3408 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a33ec:	f7ff ffde 	bl	80a33ac <_ZN5spark10LogManagerC1Ev>
 80a33f0:	4620      	mov	r0, r4
 80a33f2:	f7fc fe66 	bl	80a00c2 <__cxa_guard_release>
 80a33f6:	4a05      	ldr	r2, [pc, #20]	; (80a340c <_ZN5spark10LogManager8instanceEv+0x34>)
 80a33f8:	4905      	ldr	r1, [pc, #20]	; (80a3410 <_ZN5spark10LogManager8instanceEv+0x38>)
 80a33fa:	4803      	ldr	r0, [pc, #12]	; (80a3408 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a33fc:	f001 fc0e 	bl	80a4c1c <__aeabi_atexit>
    return &mgr;
}
 80a3400:	4801      	ldr	r0, [pc, #4]	; (80a3408 <_ZN5spark10LogManager8instanceEv+0x30>)
 80a3402:	bd10      	pop	{r4, pc}
 80a3404:	20000470 	.word	0x20000470
 80a3408:	20000474 	.word	0x20000474
 80a340c:	2000039c 	.word	0x2000039c
 80a3410:	080a3861 	.word	0x080a3861

080a3414 <_ZN5spark10LogManager18setSystemCallbacksEv>:
}

#endif // Wiring_LogConfig

void spark::LogManager::setSystemCallbacks() {
    log_set_callbacks(logMessage, logWrite, logEnabled, nullptr);
 80a3414:	2300      	movs	r3, #0
 80a3416:	4a02      	ldr	r2, [pc, #8]	; (80a3420 <_ZN5spark10LogManager18setSystemCallbacksEv+0xc>)
 80a3418:	4902      	ldr	r1, [pc, #8]	; (80a3424 <_ZN5spark10LogManager18setSystemCallbacksEv+0x10>)
 80a341a:	4803      	ldr	r0, [pc, #12]	; (80a3428 <_ZN5spark10LogManager18setSystemCallbacksEv+0x14>)
 80a341c:	f7ff b9fe 	b.w	80a281c <log_set_callbacks>
 80a3420:	080a3745 	.word	0x080a3745
 80a3424:	080a36d5 	.word	0x080a36d5
 80a3428:	080a365d 	.word	0x080a365d

080a342c <_ZN5spark10LogManager20resetSystemCallbacksEv>:
}

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
 80a342c:	2300      	movs	r3, #0
 80a342e:	461a      	mov	r2, r3
 80a3430:	4619      	mov	r1, r3
 80a3432:	4618      	mov	r0, r3
 80a3434:	f7ff b9f2 	b.w	80a281c <log_set_callbacks>

080a3438 <_ZNK5spark18JSONObjectIterator4nameEv>:

inline spark::JSONObjectIterator::JSONObjectIterator(const JSONValue &value) :
        JSONObjectIterator(value.t_, value.d_) {
}

inline spark::JSONString spark::JSONObjectIterator::name() const {
 80a3438:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a343a:	4605      	mov	r5, r0
    return JSONString(k_, d_);
 80a343c:	68ce      	ldr	r6, [r1, #12]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a343e:	f851 3b04 	ldr.w	r3, [r1], #4
 80a3442:	ac02      	add	r4, sp, #8
 80a3444:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a3448:	a801      	add	r0, sp, #4
 80a344a:	f7ff fa8d 	bl	80a2968 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a344e:	4622      	mov	r2, r4
 80a3450:	4631      	mov	r1, r6
 80a3452:	4628      	mov	r0, r5
 80a3454:	f7ff fcb0 	bl	80a2db8 <_ZN5spark10JSONStringC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a3458:	a801      	add	r0, sp, #4
 80a345a:	f7ff fa6f 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a345e:	4628      	mov	r0, r5
 80a3460:	b002      	add	sp, #8
 80a3462:	bd70      	pop	{r4, r5, r6, pc}

080a3464 <_ZNK5spark18JSONObjectIterator5valueEv>:

inline spark::JSONValue spark::JSONObjectIterator::value() const {
 80a3464:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a3466:	4605      	mov	r5, r0
    return JSONValue(v_, d_);
 80a3468:	690e      	ldr	r6, [r1, #16]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a346a:	f851 3b04 	ldr.w	r3, [r1], #4
 80a346e:	ac02      	add	r4, sp, #8
 80a3470:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a3474:	a801      	add	r0, sp, #4
 80a3476:	f7ff fa77 	bl	80a2968 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a347a:	4622      	mov	r2, r4
 80a347c:	4631      	mov	r1, r6
 80a347e:	4628      	mov	r0, r5
 80a3480:	f7ff fcdd 	bl	80a2e3e <_ZN5spark9JSONValueC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a3484:	a801      	add	r0, sp, #4
 80a3486:	f7ff fa59 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a348a:	4628      	mov	r0, r5
 80a348c:	b002      	add	sp, #8
 80a348e:	bd70      	pop	{r4, r5, r6, pc}

080a3490 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>:
        k_(nullptr),
        v_(nullptr),
        n_(0) {
}

inline spark::JSONObjectIterator::JSONObjectIterator(const JSONValue &value) :
 80a3490:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a3492:	4605      	mov	r5, r0
        JSONObjectIterator(value.t_, value.d_) {
 80a3494:	688e      	ldr	r6, [r1, #8]
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a3496:	f851 3b04 	ldr.w	r3, [r1], #4
 80a349a:	ac02      	add	r4, sp, #8
 80a349c:	f844 3d08 	str.w	r3, [r4, #-8]!
 80a34a0:	a801      	add	r0, sp, #4
 80a34a2:	f7ff fa61 	bl	80a2968 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
 80a34a6:	4622      	mov	r2, r4
 80a34a8:	4631      	mov	r1, r6
 80a34aa:	4628      	mov	r0, r5
 80a34ac:	f7ff fcac 	bl	80a2e08 <_ZN5spark18JSONObjectIteratorC1EPK9jsmntok_tSt10shared_ptrINS_6detail8JSONDataEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a34b0:	a801      	add	r0, sp, #4
 80a34b2:	f7ff fa43 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a34b6:	4628      	mov	r0, r5
 80a34b8:	b002      	add	sp, #8
 80a34ba:	bd70      	pop	{r4, r5, r6, pc}

080a34bc <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>:
spark::DefaultOutputStreamFactory* spark::DefaultOutputStreamFactory::instance() {
    static DefaultOutputStreamFactory factory;
    return &factory;
}

void spark::DefaultOutputStreamFactory::getParams(const JSONValue &params, int *baudRate) {
 80a34bc:	b530      	push	{r4, r5, lr}
 80a34be:	b08b      	sub	sp, #44	; 0x2c
 80a34c0:	460d      	mov	r5, r1
    JSONObjectIterator it(params);
 80a34c2:	4601      	mov	r1, r0
 80a34c4:	a804      	add	r0, sp, #16
 80a34c6:	f7ff ffe3 	bl	80a3490 <_ZN5spark18JSONObjectIteratorC1ERKNS_9JSONValueE>
    while (it.next()) {
 80a34ca:	a804      	add	r0, sp, #16
 80a34cc:	f7ff fb91 	bl	80a2bf2 <_ZN5spark18JSONObjectIterator4nextEv>
 80a34d0:	b1e8      	cbz	r0, 80a350e <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x52>
        if (it.name() == "baud" && baudRate) {
 80a34d2:	a904      	add	r1, sp, #16
 80a34d4:	4668      	mov	r0, sp
 80a34d6:	f7ff ffaf 	bl	80a3438 <_ZNK5spark18JSONObjectIterator4nameEv>
 80a34da:	490f      	ldr	r1, [pc, #60]	; (80a3518 <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x5c>)
 80a34dc:	9802      	ldr	r0, [sp, #8]
 80a34de:	f7ff fd19 	bl	80a2f14 <_ZNK5spark10JSONStringeqEPKc.isra.7>
 80a34e2:	4604      	mov	r4, r0
 80a34e4:	b110      	cbz	r0, 80a34ec <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0x30>
 80a34e6:	1c2c      	adds	r4, r5, #0
 80a34e8:	bf18      	it	ne
 80a34ea:	2401      	movne	r4, #1
 80a34ec:	a801      	add	r0, sp, #4
 80a34ee:	f7ff fa25 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a34f2:	2c00      	cmp	r4, #0
 80a34f4:	d0e9      	beq.n	80a34ca <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0xe>
            *baudRate = it.value().toInt();
 80a34f6:	a904      	add	r1, sp, #16
 80a34f8:	4668      	mov	r0, sp
 80a34fa:	f7ff ffb3 	bl	80a3464 <_ZNK5spark18JSONObjectIterator5valueEv>
 80a34fe:	4668      	mov	r0, sp
 80a3500:	f7ff fb57 	bl	80a2bb2 <_ZNK5spark9JSONValue5toIntEv>
 80a3504:	6028      	str	r0, [r5, #0]
 80a3506:	a801      	add	r0, sp, #4
 80a3508:	f7ff fa18 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a350c:	e7dd      	b.n	80a34ca <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi+0xe>
 80a350e:	a805      	add	r0, sp, #20
 80a3510:	f7ff fa14 	bl	80a293c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        }
    }
}
 80a3514:	b00b      	add	sp, #44	; 0x2c
 80a3516:	bd30      	pop	{r4, r5, pc}
 80a3518:	080a59ad 	.word	0x080a59ad

080a351c <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE>:
    static DefaultLogHandlerFactory factory;
    return &factory;
}

// spark::DefaultOutputStreamFactory
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a351c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a351e:	460c      	mov	r4, r1
#if PLATFORM_ID != 3
    if (strcmp(type, "Serial") == 0) {
 80a3520:	491a      	ldr	r1, [pc, #104]	; (80a358c <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x70>)
 80a3522:	4620      	mov	r0, r4
    static DefaultLogHandlerFactory factory;
    return &factory;
}

// spark::DefaultOutputStreamFactory
Print* spark::DefaultOutputStreamFactory::createStream(const char *type, const JSONValue &params) {
 80a3524:	4615      	mov	r5, r2
#if PLATFORM_ID != 3
    if (strcmp(type, "Serial") == 0) {
 80a3526:	f001 fd63 	bl	80a4ff0 <strcmp>
 80a352a:	b940      	cbnz	r0, 80a353e <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x22>
        Serial.begin();
 80a352c:	f001 f96a 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a3530:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a3534:	f001 f948 	bl	80a47c8 <_ZN9USBSerial5beginEl>
        return &Serial;
 80a3538:	f001 f964 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a353c:	e023      	b.n	80a3586 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#if Wiring_USBSerial1
    if (strcmp(type, "USBSerial1") == 0) {
 80a353e:	4914      	ldr	r1, [pc, #80]	; (80a3590 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x74>)
 80a3540:	4620      	mov	r0, r4
 80a3542:	f001 fd55 	bl	80a4ff0 <strcmp>
 80a3546:	b940      	cbnz	r0, 80a355a <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x3e>
        USBSerial1.begin();
 80a3548:	f001 f998 	bl	80a487c <_Z17_fetch_usbserial1v>
 80a354c:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a3550:	f001 f93a 	bl	80a47c8 <_ZN9USBSerial5beginEl>
        return &USBSerial1;
 80a3554:	f001 f992 	bl	80a487c <_Z17_fetch_usbserial1v>
 80a3558:	e015      	b.n	80a3586 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#endif
    if (strcmp(type, "Serial1") == 0) {
 80a355a:	490e      	ldr	r1, [pc, #56]	; (80a3594 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x78>)
 80a355c:	4620      	mov	r0, r4
 80a355e:	f001 fd47 	bl	80a4ff0 <strcmp>
 80a3562:	b978      	cbnz	r0, 80a3584 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x68>
        int baud = 9600;
 80a3564:	a902      	add	r1, sp, #8
 80a3566:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80a356a:	f841 3d04 	str.w	r3, [r1, #-4]!
        getParams(params, &baud);
 80a356e:	4628      	mov	r0, r5
 80a3570:	f7ff ffa4 	bl	80a34bc <_ZN5spark26DefaultOutputStreamFactory9getParamsERKNS_9JSONValueEPi>
        Serial1.begin(baud);
 80a3574:	f001 f8c4 	bl	80a4700 <_Z22__fetch_global_Serial1v>
 80a3578:	9901      	ldr	r1, [sp, #4]
 80a357a:	f001 f8b7 	bl	80a46ec <_ZN11USARTSerial5beginEm>
        return &Serial1;
 80a357e:	f001 f8bf 	bl	80a4700 <_Z22__fetch_global_Serial1v>
 80a3582:	e000      	b.n	80a3586 <_ZN5spark26DefaultOutputStreamFactory12createStreamEPKcRKNS_9JSONValueE+0x6a>
    }
#endif // PLATFORM_ID != 3
    return nullptr;
 80a3584:	2000      	movs	r0, #0
}
 80a3586:	b003      	add	sp, #12
 80a3588:	bd30      	pop	{r4, r5, pc}
 80a358a:	bf00      	nop
 80a358c:	080a59b2 	.word	0x080a59b2
 80a3590:	080a59b9 	.word	0x080a59b9
 80a3594:	080a59bc 	.word	0x080a59bc

080a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a3598:	b570      	push	{r4, r5, r6, lr}
 80a359a:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a359c:	6804      	ldr	r4, [r0, #0]
 80a359e:	6843      	ldr	r3, [r0, #4]
 80a35a0:	2614      	movs	r6, #20
 80a35a2:	fb06 4603 	mla	r6, r6, r3, r4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a35a6:	42a6      	cmp	r6, r4
 80a35a8:	d005      	beq.n	80a35b6 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0x1e>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a35aa:	f104 0008 	add.w	r0, r4, #8
 80a35ae:	f7ff fff3 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a35b2:	3414      	adds	r4, #20
 80a35b4:	e7f7      	b.n	80a35a6 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev+0xe>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a35b6:	6828      	ldr	r0, [r5, #0]
 80a35b8:	f7ff f994 	bl	80a28e4 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a35bc:	4628      	mov	r0, r5
 80a35be:	bd70      	pop	{r4, r5, r6, pc}

080a35c0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
 80a35c0:	b570      	push	{r4, r5, r6, lr}
 80a35c2:	4605      	mov	r5, r0
    destruct(data_, data_ + size_);
 80a35c4:	6804      	ldr	r4, [r0, #0]
 80a35c6:	6843      	ldr	r3, [r0, #4]
 80a35c8:	eb04 1603 	add.w	r6, r4, r3, lsl #4
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a35cc:	42a6      	cmp	r6, r4
 80a35ce:	d004      	beq.n	80a35da <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0x1a>
            p->~T();
 80a35d0:	4620      	mov	r0, r4
 80a35d2:	f000 fd42 	bl	80a405a <_ZN6StringD1Ev>
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a35d6:	3410      	adds	r4, #16
 80a35d8:	e7f8      	b.n	80a35cc <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0xc>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a35da:	6828      	ldr	r0, [r5, #0]
 80a35dc:	f7ff f982 	bl	80a28e4 <free>

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
    AllocatorT::free(data_);
}
 80a35e0:	4628      	mov	r0, r5
 80a35e2:	bd70      	pop	{r4, r5, r6, pc}

080a35e4 <_ZN5spark6detail9LogFilterD1Ev>:
    swap(cats_, cats);
    swap(nodes_, nodes);
    level_ = level;
}

spark::detail::LogFilter::~LogFilter() {
 80a35e4:	b510      	push	{r4, lr}
 80a35e6:	4604      	mov	r4, r0
 80a35e8:	300c      	adds	r0, #12
 80a35ea:	f7ff ffd5 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a35ee:	4620      	mov	r0, r4
 80a35f0:	f7ff ffe6 	bl	80a35c0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
}
 80a35f4:	4620      	mov	r0, r4
 80a35f6:	bd10      	pop	{r4, pc}

080a35f8 <_ZN5spark16StreamLogHandlerD1Ev>:
/*!
    \brief Stream-based log handler.

    Adapter class allowing to use existent stream objects as destination for logging output.
*/
class StreamLogHandler: public LogHandler {
 80a35f8:	b510      	push	{r4, lr}
 80a35fa:	4604      	mov	r4, r0
    */
    LogHandler(LogLevel level, LogCategoryFilters filters);
    /*!
        \brief Destructor.
    */
    virtual ~LogHandler() = default;
 80a35fc:	4b03      	ldr	r3, [pc, #12]	; (80a360c <_ZN5spark16StreamLogHandlerD1Ev+0x14>)
 80a35fe:	f840 3b04 	str.w	r3, [r0], #4
 80a3602:	f7ff ffef 	bl	80a35e4 <_ZN5spark6detail9LogFilterD1Ev>
/*!
    \brief Stream-based log handler.

    Adapter class allowing to use existent stream objects as destination for logging output.
*/
class StreamLogHandler: public LogHandler {
 80a3606:	4620      	mov	r0, r4
 80a3608:	bd10      	pop	{r4, pc}
 80a360a:	bf00      	nop
 80a360c:	080a51c8 	.word	0x080a51c8

080a3610 <_ZN5spark16StreamLogHandlerD0Ev>:
 80a3610:	b510      	push	{r4, lr}
 80a3612:	4604      	mov	r4, r0
 80a3614:	f7ff fff0 	bl	80a35f8 <_ZN5spark16StreamLogHandlerD1Ev>
 80a3618:	4620      	mov	r0, r4
 80a361a:	f7fc fd40 	bl	80a009e <_ZdlPv>
 80a361e:	4620      	mov	r0, r4
 80a3620:	bd10      	pop	{r4, pc}
	...

080a3624 <_ZN5spark20JSONStreamLogHandlerD1Ev>:

private:
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
 80a3624:	b510      	push	{r4, lr}
 80a3626:	4604      	mov	r4, r0
 80a3628:	4b02      	ldr	r3, [pc, #8]	; (80a3634 <_ZN5spark20JSONStreamLogHandlerD1Ev+0x10>)
 80a362a:	6003      	str	r3, [r0, #0]
 80a362c:	f7ff ffe4 	bl	80a35f8 <_ZN5spark16StreamLogHandlerD1Ev>
 80a3630:	4620      	mov	r0, r4
 80a3632:	bd10      	pop	{r4, pc}
 80a3634:	080a594c 	.word	0x080a594c

080a3638 <_ZN5spark20JSONStreamLogHandlerD0Ev>:
 80a3638:	b510      	push	{r4, lr}
 80a363a:	4604      	mov	r4, r0
 80a363c:	f7ff fff2 	bl	80a3624 <_ZN5spark20JSONStreamLogHandlerD1Ev>
 80a3640:	4620      	mov	r0, r4
 80a3642:	f7fc fd2c 	bl	80a009e <_ZdlPv>
 80a3646:	4620      	mov	r0, r4
 80a3648:	bd10      	pop	{r4, pc}

080a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>:
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
      { } // calling thread owns mutex

      ~lock_guard()
 80a364a:	b510      	push	{r4, lr}
 80a364c:	4604      	mov	r4, r0
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a364e:	6803      	ldr	r3, [r0, #0]
 80a3650:	6818      	ldr	r0, [r3, #0]
 80a3652:	f7fe ff21 	bl	80a2498 <os_mutex_recursive_unlock>
      { _M_device.unlock(); }
 80a3656:	4620      	mov	r0, r4
 80a3658:	bd10      	pop	{r4, pc}
	...

080a365c <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv>:

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
}

void spark::LogManager::logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved) {
 80a365c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3660:	469b      	mov	fp, r3
#endif // defined(STM32F10X_MD) || defined(STM32F10X_HD)

#if defined(STM32F10X_MD) || defined(STM32F10X_HD) || defined(STM32F2XX)
inline bool HAL_IsISR()
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) != 0;
 80a3662:	4b1b      	ldr	r3, [pc, #108]	; (80a36d0 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x74>)
 80a3664:	b085      	sub	sp, #20
 80a3666:	685b      	ldr	r3, [r3, #4]
 80a3668:	4682      	mov	sl, r0
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a366a:	f3c3 0308 	ubfx	r3, r3, #0, #9

void spark::LogManager::resetSystemCallbacks() {
    log_set_callbacks(nullptr, nullptr, nullptr, nullptr);
}

void spark::LogManager::logMessage(const char *msg, int level, const char *category, const LogAttributes *attr, void *reserved) {
 80a366e:	460e      	mov	r6, r1
 80a3670:	4690      	mov	r8, r2
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a3672:	bb53      	cbnz	r3, 80a36ca <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x6e>
        return;
    }
#endif
    LogManager *that = instance();
 80a3674:	f7ff feb0 	bl	80a33d8 <_ZN5spark10LogManager8instanceEv>
 80a3678:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a367a:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a367c:	9003      	str	r0, [sp, #12]
      { _M_device.lock(); }
 80a367e:	f7ff fd0b 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
        // prevent re-entry
        if (that->isActive()) {
 80a3682:	7b23      	ldrb	r3, [r4, #12]
 80a3684:	b9f3      	cbnz	r3, 80a36c4 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x68>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a3686:	2301      	movs	r3, #1
 80a3688:	7323      	strb	r3, [r4, #12]
 80a368a:	6825      	ldr	r5, [r4, #0]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a368c:	6863      	ldr	r3, [r4, #4]
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
            handler->message(msg, (LogLevel)level, category, *attr);
 80a368e:	b2f6      	uxtb	r6, r6
 80a3690:	eb05 0983 	add.w	r9, r5, r3, lsl #2
        // prevent re-entry
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
 80a3694:	454d      	cmp	r5, r9
 80a3696:	d013      	beq.n	80a36c0 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x64>
 80a3698:	f855 7b04 	ldr.w	r7, [r5], #4
inline const char* spark::LogHandler::levelName(LogLevel level) {
    return log_level_name(level, nullptr);
}

inline void spark::LogHandler::message(const char *msg, LogLevel level, const char *category, const LogAttributes &attr) {
    if (level >= filter_.level(category)) {
 80a369c:	4641      	mov	r1, r8
 80a369e:	1d38      	adds	r0, r7, #4
 80a36a0:	f7ff fe20 	bl	80a32e4 <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a36a4:	4286      	cmp	r6, r0
 80a36a6:	d3f5      	bcc.n	80a3694 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x38>
        logMessage(msg, level, category, attr);
 80a36a8:	683b      	ldr	r3, [r7, #0]
 80a36aa:	f8cd b000 	str.w	fp, [sp]
 80a36ae:	689b      	ldr	r3, [r3, #8]
 80a36b0:	4638      	mov	r0, r7
 80a36b2:	469e      	mov	lr, r3
 80a36b4:	4632      	mov	r2, r6
 80a36b6:	4643      	mov	r3, r8
 80a36b8:	4651      	mov	r1, sl
 80a36ba:	4677      	mov	r7, lr
 80a36bc:	47b8      	blx	r7
 80a36be:	e7e9      	b.n	80a3694 <_ZN5spark10LogManager10logMessageEPKciS2_PK13LogAttributesPv+0x38>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a36c0:	2300      	movs	r3, #0
 80a36c2:	7323      	strb	r3, [r4, #12]
#endif
    LogManager *that = instance();
    LOG_WITH_LOCK(that->mutex_) {
        // prevent re-entry
        if (that->isActive()) {
            return;
 80a36c4:	a803      	add	r0, sp, #12
 80a36c6:	f7ff ffc0 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        for (LogHandler *handler: that->activeHandlers_) {
            handler->message(msg, (LogLevel)level, category, *attr);
        }
        that->setActive(false);
    }
}
 80a36ca:	b005      	add	sp, #20
 80a36cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a36d0:	e000ed00 	.word	0xe000ed00

080a36d4 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv>:

void spark::LogManager::logWrite(const char *data, size_t size, int level, const char *category, void *reserved) {
 80a36d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a36d8:	4699      	mov	r9, r3
 80a36da:	4b19      	ldr	r3, [pc, #100]	; (80a3740 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x6c>)
 80a36dc:	4607      	mov	r7, r0
 80a36de:	685b      	ldr	r3, [r3, #4]
 80a36e0:	4688      	mov	r8, r1
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a36e2:	f3c3 0308 	ubfx	r3, r3, #0, #9
        }
        that->setActive(false);
    }
}

void spark::LogManager::logWrite(const char *data, size_t size, int level, const char *category, void *reserved) {
 80a36e6:	4616      	mov	r6, r2
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a36e8:	bb33      	cbnz	r3, 80a3738 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x64>
        return;
    }
#endif
    LogManager *that = instance();
 80a36ea:	f7ff fe75 	bl	80a33d8 <_ZN5spark10LogManager8instanceEv>
 80a36ee:	4604      	mov	r4, r0
    LOG_WITH_LOCK(that->mutex_) {
 80a36f0:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a36f2:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a36f4:	f7ff fcd0 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
        // prevent re-entry
        if (that->isActive()) {
 80a36f8:	7b23      	ldrb	r3, [r4, #12]
 80a36fa:	b9d3      	cbnz	r3, 80a3732 <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x5e>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a36fc:	2301      	movs	r3, #1
 80a36fe:	7323      	strb	r3, [r4, #12]
 80a3700:	6825      	ldr	r5, [r4, #0]
 80a3702:	6863      	ldr	r3, [r4, #4]
    }
}

inline void spark::LogHandler::write(const char *data, size_t size, LogLevel level, const char *category) {
    if (level >= filter_.level(category)) {
 80a3704:	fa5f fb86 	uxtb.w	fp, r6
 80a3708:	eb05 0a83 	add.w	sl, r5, r3, lsl #2
        // prevent re-entry
        if (that->isActive()) {
            return;
        }
        that->setActive(true);
        for (LogHandler *handler: that->activeHandlers_) {
 80a370c:	4555      	cmp	r5, sl
 80a370e:	d00e      	beq.n	80a372e <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x5a>
 80a3710:	f855 6b04 	ldr.w	r6, [r5], #4
 80a3714:	4649      	mov	r1, r9
 80a3716:	1d30      	adds	r0, r6, #4
 80a3718:	f7ff fde4 	bl	80a32e4 <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a371c:	4583      	cmp	fp, r0
 80a371e:	d3f5      	bcc.n	80a370c <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x38>
        write(data, size);
 80a3720:	6833      	ldr	r3, [r6, #0]
 80a3722:	4642      	mov	r2, r8
 80a3724:	68db      	ldr	r3, [r3, #12]
 80a3726:	4639      	mov	r1, r7
 80a3728:	4630      	mov	r0, r6
 80a372a:	4798      	blx	r3
 80a372c:	e7ee      	b.n	80a370c <_ZN5spark10LogManager8logWriteEPKcjiS2_Pv+0x38>
inline bool spark::LogManager::isActive() const {
    return outputActive_;
}

inline void spark::LogManager::setActive(bool outputActive) {
    outputActive_ = outputActive;
 80a372e:	2300      	movs	r3, #0
 80a3730:	7323      	strb	r3, [r4, #12]
#endif
    LogManager *that = instance();
    LOG_WITH_LOCK(that->mutex_) {
        // prevent re-entry
        if (that->isActive()) {
            return;
 80a3732:	a801      	add	r0, sp, #4
 80a3734:	f7ff ff89 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        for (LogHandler *handler: that->activeHandlers_) {
            handler->write(data, size, (LogLevel)level, category);
        }
        that->setActive(false);
    }
}
 80a3738:	b003      	add	sp, #12
 80a373a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a373e:	bf00      	nop
 80a3740:	e000ed00 	.word	0xe000ed00

080a3744 <_ZN5spark10LogManager10logEnabledEiPKcPv>:

int spark::LogManager::logEnabled(int level, const char *category, void *reserved) {
 80a3744:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a3748:	4b15      	ldr	r3, [pc, #84]	; (80a37a0 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x5c>)
 80a374a:	4604      	mov	r4, r0
 80a374c:	685b      	ldr	r3, [r3, #4]
 80a374e:	4688      	mov	r8, r1
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
 80a3750:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80a3754:	b9fb      	cbnz	r3, 80a3796 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x52>
        return 0;
    }
#endif
    LogManager *that = instance();
 80a3756:	f7ff fe3f 	bl	80a33d8 <_ZN5spark10LogManager8instanceEv>
 80a375a:	4606      	mov	r6, r0
    int minLevel = LOG_LEVEL_NONE;
    LOG_WITH_LOCK(that->mutex_) {
 80a375c:	3024      	adds	r0, #36	; 0x24
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a375e:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a3760:	f7ff fc9a 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
 80a3764:	e896 00a0 	ldmia.w	r6, {r5, r7}
 80a3768:	2646      	movs	r6, #70	; 0x46
 80a376a:	eb05 0787 	add.w	r7, r5, r7, lsl #2
        for (LogHandler *handler: that->activeHandlers_) {
 80a376e:	42af      	cmp	r7, r5
 80a3770:	d107      	bne.n	80a3782 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x3e>
        return 0;
    }
#endif
    LogManager *that = instance();
    int minLevel = LOG_LEVEL_NONE;
    LOG_WITH_LOCK(that->mutex_) {
 80a3772:	a801      	add	r0, sp, #4
 80a3774:	f7ff ff69 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
            if (level < minLevel) {
                minLevel = level;
            }
        }
    }
    return (level >= minLevel);
 80a3778:	42b4      	cmp	r4, r6
 80a377a:	bfb4      	ite	lt
 80a377c:	2000      	movlt	r0, #0
 80a377e:	2001      	movge	r0, #1
 80a3780:	e00a      	b.n	80a3798 <_ZN5spark10LogManager10logEnabledEiPKcPv+0x54>
inline LogLevel spark::LogHandler::level() const {
    return filter_.level();
}

inline LogLevel spark::LogHandler::level(const char *category) const {
    return filter_.level(category);
 80a3782:	f855 0b04 	ldr.w	r0, [r5], #4
 80a3786:	4641      	mov	r1, r8
 80a3788:	3004      	adds	r0, #4
 80a378a:	f7ff fdab 	bl	80a32e4 <_ZNK5spark6detail9LogFilter5levelEPKc>
 80a378e:	4286      	cmp	r6, r0
 80a3790:	bfa8      	it	ge
 80a3792:	4606      	movge	r6, r0
 80a3794:	e7eb      	b.n	80a376e <_ZN5spark10LogManager10logEnabledEiPKcPv+0x2a>
}

int spark::LogManager::logEnabled(int level, const char *category, void *reserved) {
#ifndef LOG_FROM_ISR
    if (HAL_IsISR()) {
        return 0;
 80a3796:	2000      	movs	r0, #0
                minLevel = level;
            }
        }
    }
    return (level >= minLevel);
}
 80a3798:	b002      	add	sp, #8
 80a379a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a379e:	bf00      	nop
 80a37a0:	e000ed00 	.word	0xe000ed00

080a37a4 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>:
    move(p, p + n, data_ + size_);
    size_ -= n;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
 80a37a4:	b570      	push	{r4, r5, r6, lr}
 80a37a6:	4604      	mov	r4, r0
    T* const p = find(data_, data_ + size_, value);
 80a37a8:	6803      	ldr	r3, [r0, #0]
 80a37aa:	6842      	ldr	r2, [r0, #4]
 80a37ac:	eb03 0282 	add.w	r2, r3, r2, lsl #2
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
 80a37b0:	429a      	cmp	r2, r3
 80a37b2:	4618      	mov	r0, r3
 80a37b4:	d00d      	beq.n	80a37d2 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0x2e>
            if (*p == value) {
 80a37b6:	6806      	ldr	r6, [r0, #0]
 80a37b8:	680d      	ldr	r5, [r1, #0]
 80a37ba:	3304      	adds	r3, #4
 80a37bc:	42ae      	cmp	r6, r5
 80a37be:	d1f7      	bne.n	80a37b0 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_+0xc>
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
 80a37c0:	1d01      	adds	r1, r0, #4
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a37c2:	1a52      	subs	r2, r2, r1
 80a37c4:	f001 fbb1 	bl	80a4f2a <memmove>
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
    --size_;
 80a37c8:	6863      	ldr	r3, [r4, #4]
    return true;
 80a37ca:	2001      	movs	r0, #1
    if (!p) {
        return false;
    }
    p->~T();
    move(p, p + 1, data_ + size_);
    --size_;
 80a37cc:	3b01      	subs	r3, #1
 80a37ce:	6063      	str	r3, [r4, #4]
    return true;
}
 80a37d0:	bd70      	pop	{r4, r5, r6, pc}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
    T* const p = find(data_, data_ + size_, value);
    if (!p) {
        return false;
 80a37d2:	2000      	movs	r0, #0
 80a37d4:	bd70      	pop	{r4, r5, r6, pc}

080a37d6 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE>:
        }
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
 80a37d6:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80a37d8:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a37da:	3024      	adds	r0, #36	; 0x24
        }
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
 80a37dc:	9101      	str	r1, [sp, #4]
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a37de:	9003      	str	r0, [sp, #12]
      { _M_device.lock(); }
 80a37e0:	f7ff fc5a 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
 80a37e4:	a901      	add	r1, sp, #4
 80a37e6:	4620      	mov	r0, r4
 80a37e8:	f7ff ffdc 	bl	80a37a4 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
 80a37ec:	b920      	cbnz	r0, 80a37f8 <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x22>
    }
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
 80a37ee:	a803      	add	r0, sp, #12
 80a37f0:	f7ff ff2b 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
            resetSystemCallbacks();
        }
    }
}
 80a37f4:	b004      	add	sp, #16
 80a37f6:	bd10      	pop	{r4, pc}
    return true;
}

void spark::LogManager::removeHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.removeOne(handler) && activeHandlers_.isEmpty()) {
 80a37f8:	6863      	ldr	r3, [r4, #4]
 80a37fa:	2b00      	cmp	r3, #0
 80a37fc:	d1f7      	bne.n	80a37ee <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x18>
            resetSystemCallbacks();
 80a37fe:	f7ff fe15 	bl	80a342c <_ZN5spark10LogManager20resetSystemCallbacksEv>
 80a3802:	e7f4      	b.n	80a37ee <_ZN5spark10LogManager13removeHandlerEPNS_10LogHandlerE+0x18>

080a3804 <_ZN5spark10LogManager22destroyFactoryHandlersEv>:
            break;
        }
    }
}

void spark::LogManager::destroyFactoryHandlers() {
 80a3804:	b570      	push	{r4, r5, r6, lr}
 80a3806:	4604      	mov	r4, r0
 80a3808:	6905      	ldr	r5, [r0, #16]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a380a:	6943      	ldr	r3, [r0, #20]
 80a380c:	2618      	movs	r6, #24
 80a380e:	fb06 5603 	mla	r6, r6, r3, r5
    for (const FactoryHandler &h: factoryHandlers_) {
 80a3812:	42ae      	cmp	r6, r5
 80a3814:	d015      	beq.n	80a3842 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3e>
        activeHandlers_.removeOne(h.handler);
 80a3816:	f105 0110 	add.w	r1, r5, #16
 80a381a:	4620      	mov	r0, r4
 80a381c:	f7ff ffc2 	bl	80a37a4 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE9removeOneERKS2_>
        if (activeHandlers_.isEmpty()) {
 80a3820:	6863      	ldr	r3, [r4, #4]
 80a3822:	b90b      	cbnz	r3, 80a3828 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x24>
            resetSystemCallbacks();
 80a3824:	f7ff fe02 	bl	80a342c <_ZN5spark10LogManager20resetSystemCallbacksEv>
        }
        handlerFactory_->destroyHandler(h.handler);
 80a3828:	69e0      	ldr	r0, [r4, #28]
 80a382a:	6929      	ldr	r1, [r5, #16]
 80a382c:	6803      	ldr	r3, [r0, #0]
 80a382e:	68db      	ldr	r3, [r3, #12]
 80a3830:	4798      	blx	r3
        if (h.stream) {
 80a3832:	6969      	ldr	r1, [r5, #20]
 80a3834:	b119      	cbz	r1, 80a383e <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x3a>
            streamFactory_->destroyStream(h.stream);
 80a3836:	6a20      	ldr	r0, [r4, #32]
 80a3838:	6803      	ldr	r3, [r0, #0]
 80a383a:	68db      	ldr	r3, [r3, #12]
 80a383c:	4798      	blx	r3
 80a383e:	3518      	adds	r5, #24
        }
    }
}

void spark::LogManager::destroyFactoryHandlers() {
    for (const FactoryHandler &h: factoryHandlers_) {
 80a3840:	e7e7      	b.n	80a3812 <_ZN5spark10LogManager22destroyFactoryHandlersEv+0xe>
    return true;
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
 80a3842:	6925      	ldr	r5, [r4, #16]
 80a3844:	6963      	ldr	r3, [r4, #20]
 80a3846:	2618      	movs	r6, #24
 80a3848:	fb06 5603 	mla	r6, r6, r3, r5
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a384c:	42b5      	cmp	r5, r6
 80a384e:	d004      	beq.n	80a385a <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x56>
        }
    }
}

// spark::LogManager
struct spark::LogManager::FactoryHandler {
 80a3850:	4628      	mov	r0, r5
 80a3852:	f000 fc02 	bl	80a405a <_ZN6StringD1Ev>
 80a3856:	3518      	adds	r5, #24
 80a3858:	e7f8      	b.n	80a384c <_ZN5spark10LogManager22destroyFactoryHandlersEv+0x48>
}

template<typename T, typename AllocatorT>
inline void spark::Vector<T, AllocatorT>::clear() {
    destruct(data_, data_ + size_);
    size_ = 0;
 80a385a:	2300      	movs	r3, #0
 80a385c:	6163      	str	r3, [r4, #20]
 80a385e:	bd70      	pop	{r4, r5, r6, pc}

080a3860 <_ZN5spark10LogManagerD1Ev>:
    streamFactory_ = DefaultOutputStreamFactory::instance();
#endif
    outputActive_ = false;
}

spark::LogManager::~LogManager() {
 80a3860:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a3862:	4604      	mov	r4, r0
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a3864:	ad02      	add	r5, sp, #8
    resetSystemCallbacks();
 80a3866:	f7ff fde1 	bl	80a342c <_ZN5spark10LogManager20resetSystemCallbacksEv>
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
 80a386a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80a386e:	f845 0d04 	str.w	r0, [r5, #-4]!
      { _M_device.lock(); }
 80a3872:	f7ff fc11 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
         destroyFactoryHandlers();
 80a3876:	4620      	mov	r0, r4
 80a3878:	f7ff ffc4 	bl	80a3804 <_ZN5spark10LogManager22destroyFactoryHandlersEv>
}

spark::LogManager::~LogManager() {
    resetSystemCallbacks();
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
 80a387c:	4628      	mov	r0, r5
 80a387e:	f7ff fee4 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
    swap(*this, vector);
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::~Vector() {
    destruct(data_, data_ + size_);
 80a3882:	6925      	ldr	r5, [r4, #16]
 80a3884:	6963      	ldr	r3, [r4, #20]
 80a3886:	2618      	movs	r6, #24
 80a3888:	fb06 5603 	mla	r6, r6, r3, r5
            new(p) T(std::forward<ArgsT>(args)...);
        }
    }

    static void destruct(T* p, const T* end) {
        for (; p != end; ++p) {
 80a388c:	42b5      	cmp	r5, r6
 80a388e:	d004      	beq.n	80a389a <_ZN5spark10LogManagerD1Ev+0x3a>
        }
    }
}

// spark::LogManager
struct spark::LogManager::FactoryHandler {
 80a3890:	4628      	mov	r0, r5
 80a3892:	f000 fbe2 	bl	80a405a <_ZN6StringD1Ev>
 80a3896:	3518      	adds	r5, #24
 80a3898:	e7f8      	b.n	80a388c <_ZN5spark10LogManagerD1Ev+0x2c>
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a389a:	6920      	ldr	r0, [r4, #16]
 80a389c:	f7ff f822 	bl	80a28e4 <free>
 80a38a0:	6820      	ldr	r0, [r4, #0]
 80a38a2:	f7ff f81f 	bl	80a28e4 <free>
#if Wiring_LogConfig
    LOG_WITH_LOCK(mutex_) {
         destroyFactoryHandlers();
    }
#endif
}
 80a38a6:	4620      	mov	r0, r4
 80a38a8:	b002      	add	sp, #8
 80a38aa:	bd70      	pop	{r4, r5, r6, pc}

080a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>:
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a38ac:	6803      	ldr	r3, [r0, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a38ae:	680a      	ldr	r2, [r1, #0]
 80a38b0:	6002      	str	r2, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a38b2:	600b      	str	r3, [r1, #0]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a38b4:	6843      	ldr	r3, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a38b6:	684a      	ldr	r2, [r1, #4]
 80a38b8:	6042      	str	r2, [r0, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a38ba:	604b      	str	r3, [r1, #4]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a38bc:	6883      	ldr	r3, [r0, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a38be:	688a      	ldr	r2, [r1, #8]
 80a38c0:	6082      	str	r2, [r0, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a38c2:	608b      	str	r3, [r1, #8]
 80a38c4:	4770      	bx	lr

080a38c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>:
        size_ = vector.size_;
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
 80a38c6:	b510      	push	{r4, lr}
 80a38c8:	4604      	mov	r4, r0
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a38ca:	2300      	movs	r3, #0
 80a38cc:	6003      	str	r3, [r0, #0]
 80a38ce:	6043      	str	r3, [r0, #4]
 80a38d0:	6083      	str	r3, [r0, #8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a38d2:	f7ff ffeb 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
}
 80a38d6:	4620      	mov	r0, r4
 80a38d8:	bd10      	pop	{r4, pc}

080a38da <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a38da:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a38dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a38de:	4604      	mov	r4, r0
 80a38e0:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
 80a38e2:	d925      	bls.n	80a3930 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x56>
 80a38e4:	4290      	cmp	r0, r2
 80a38e6:	d224      	bcs.n	80a3932 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x58>
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
 80a38e8:	1a55      	subs	r5, r2, r1
 80a38ea:	3d14      	subs	r5, #20
 80a38ec:	442c      	add	r4, r5
 80a38ee:	f1a1 0714 	sub.w	r7, r1, #20
 80a38f2:	f1a2 050c 	sub.w	r5, r2, #12
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a38f6:	2600      	movs	r6, #0
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a38f8:	f1a5 0308 	sub.w	r3, r5, #8
 80a38fc:	429f      	cmp	r7, r3
 80a38fe:	d037      	beq.n	80a3970 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
                new(dest) T(std::move(*end));
 80a3900:	b184      	cbz	r4, 80a3924 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x4a>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a3902:	f855 3c08 	ldr.w	r3, [r5, #-8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3906:	4629      	mov	r1, r5
 80a3908:	6023      	str	r3, [r4, #0]
 80a390a:	f835 3c04 	ldrh.w	r3, [r5, #-4]
 80a390e:	f104 0008 	add.w	r0, r4, #8
 80a3912:	80a3      	strh	r3, [r4, #4]
 80a3914:	f935 3c02 	ldrsh.w	r3, [r5, #-2]
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3918:	60a6      	str	r6, [r4, #8]
 80a391a:	80e3      	strh	r3, [r4, #6]
 80a391c:	60e6      	str	r6, [r4, #12]
 80a391e:	6126      	str	r6, [r4, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3920:	f7ff ffc4 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
 80a3924:	4628      	mov	r0, r5
 80a3926:	f7ff fe37 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a392a:	3c14      	subs	r4, #20
 80a392c:	3d14      	subs	r5, #20
 80a392e:	e7e3      	b.n	80a38f8 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x1e>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a3930:	d01e      	beq.n	80a3970 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
 80a3932:	f101 0508 	add.w	r5, r1, #8
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3936:	2700      	movs	r7, #0
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a3938:	f1a5 0308 	sub.w	r3, r5, #8
 80a393c:	429e      	cmp	r6, r3
 80a393e:	d017      	beq.n	80a3970 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x96>
                new(dest) T(std::move(*p));
 80a3940:	b184      	cbz	r4, 80a3964 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x8a>
 80a3942:	f855 3c08 	ldr.w	r3, [r5, #-8]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3946:	4629      	mov	r1, r5
 80a3948:	6023      	str	r3, [r4, #0]
 80a394a:	f835 3c04 	ldrh.w	r3, [r5, #-4]
 80a394e:	f104 0008 	add.w	r0, r4, #8
 80a3952:	80a3      	strh	r3, [r4, #4]
 80a3954:	f935 3c02 	ldrsh.w	r3, [r5, #-2]
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3958:	60a7      	str	r7, [r4, #8]
 80a395a:	80e3      	strh	r3, [r4, #6]
 80a395c:	60e7      	str	r7, [r4, #12]
 80a395e:	6127      	str	r7, [r4, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3960:	f7ff ffa4 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
 80a3964:	4628      	mov	r0, r5
 80a3966:	f7ff fe17 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a396a:	3414      	adds	r4, #20
 80a396c:	3514      	adds	r5, #20
 80a396e:	e7e3      	b.n	80a3938 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_+0x5e>
 80a3970:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3972 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>:
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a3972:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a3974:	6845      	ldr	r5, [r0, #4]
 80a3976:	6883      	ldr	r3, [r0, #8]
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a3978:	4604      	mov	r4, r0
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a397a:	429d      	cmp	r5, r3
inline bool spark::Vector<T, AllocatorT>::prepend(const Vector<T, AllocatorT> &vector) {
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
 80a397c:	460e      	mov	r6, r1
 80a397e:	4617      	mov	r7, r2
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a3980:	db0e      	blt.n	80a39a0 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x2e>
 80a3982:	3501      	adds	r5, #1
    int size_, capacity_;

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
 80a3984:	2d00      	cmp	r5, #0
 80a3986:	dd05      	ble.n	80a3994 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x22>
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
}

inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
 80a3988:	00a9      	lsls	r1, r5, #2
 80a398a:	6800      	ldr	r0, [r0, #0]
 80a398c:	f7fe ffb2 	bl	80a28f4 <realloc>
    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::realloc(data_, n * sizeof(T));
            if (!d) {
 80a3990:	b920      	cbnz	r0, 80a399c <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_+0x2a>
 80a3992:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a3994:	6800      	ldr	r0, [r0, #0]
 80a3996:	f7fe ffa5 	bl	80a28e4 <free>
    T* data_;
    int size_, capacity_;

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a399a:	2000      	movs	r0, #0
                return false;
            }
        } else {
            AllocatorT::free(data_);
        }
        data_ = d;
 80a399c:	6020      	str	r0, [r4, #0]
        capacity_ = n;
 80a399e:	60a5      	str	r5, [r4, #8]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a39a0:	6825      	ldr	r5, [r4, #0]
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a39a2:	6862      	ldr	r2, [r4, #4]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a39a4:	eb05 0186 	add.w	r1, r5, r6, lsl #2
        }
    }

    template<PARTICLE_VECTOR_ENABLE_IF_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
 80a39a8:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80a39ac:	1a52      	subs	r2, r2, r1
 80a39ae:	1d08      	adds	r0, r1, #4
 80a39b0:	f001 fabb 	bl	80a4f2a <memmove>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
    move(p + 1, p, data_ + size_);
    new(p) T(std::move(value));
 80a39b4:	f845 7026 	str.w	r7, [r5, r6, lsl #2]
    ++size_;
 80a39b8:	6863      	ldr	r3, [r4, #4]
 80a39ba:	2001      	movs	r0, #1
 80a39bc:	3301      	adds	r3, #1
 80a39be:	6063      	str	r3, [r4, #4]
    return true;
}
 80a39c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a39c2 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE>:
         destroyFactoryHandlers();
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
 80a39c2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a39c4:	4604      	mov	r4, r0
    LOG_WITH_LOCK(mutex_) {
 80a39c6:	3024      	adds	r0, #36	; 0x24
         destroyFactoryHandlers();
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
 80a39c8:	460d      	mov	r5, r1
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
 80a39ca:	9001      	str	r0, [sp, #4]
      { _M_device.lock(); }
 80a39cc:	f7ff fb64 	bl	80a3098 <_ZN14RecursiveMutex4lockEv>
    return p - data_;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::contains(const T &value) const {
    return find(data_, data_ + size_, value);
 80a39d0:	6823      	ldr	r3, [r4, #0]
 80a39d2:	6861      	ldr	r1, [r4, #4]
 80a39d4:	eb03 0081 	add.w	r0, r3, r1, lsl #2
            }
        }
    }

    static T* find(T* p, const T* end, const T& value) {
        for (; p != end; ++p) {
 80a39d8:	4283      	cmp	r3, r0
 80a39da:	461a      	mov	r2, r3
 80a39dc:	d008      	beq.n	80a39f0 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x2e>
            if (*p == value) {
 80a39de:	6812      	ldr	r2, [r2, #0]
 80a39e0:	3304      	adds	r3, #4
 80a39e2:	42aa      	cmp	r2, r5
 80a39e4:	d1f8      	bne.n	80a39d8 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x16>
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.contains(handler) || !activeHandlers_.append(handler)) {
            return false;
 80a39e6:	a801      	add	r0, sp, #4
 80a39e8:	f7ff fe2f 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
 80a39ec:	2500      	movs	r5, #0
 80a39ee:	e00e      	b.n	80a3a0e <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x4c>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a39f0:	462a      	mov	r2, r5
 80a39f2:	4620      	mov	r0, r4
 80a39f4:	f7ff ffbd 	bl	80a3972 <_ZN5spark6VectorIPNS_10LogHandlerENS_16DefaultAllocatorEE6insertEiS2_>
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
        if (activeHandlers_.contains(handler) || !activeHandlers_.append(handler)) {
 80a39f8:	4605      	mov	r5, r0
 80a39fa:	2800      	cmp	r0, #0
 80a39fc:	d0f3      	beq.n	80a39e6 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x24>
            return false;
        }
        if (activeHandlers_.size() == 1) {
 80a39fe:	6863      	ldr	r3, [r4, #4]
 80a3a00:	2b01      	cmp	r3, #1
 80a3a02:	d101      	bne.n	80a3a08 <_ZN5spark10LogManager10addHandlerEPNS_10LogHandlerE+0x46>
            setSystemCallbacks();
 80a3a04:	f7ff fd06 	bl	80a3414 <_ZN5spark10LogManager18setSystemCallbacksEv>
    }
#endif
}

bool spark::LogManager::addHandler(LogHandler *handler) {
    LOG_WITH_LOCK(mutex_) {
 80a3a08:	a801      	add	r0, sp, #4
 80a3a0a:	f7ff fe1e 	bl	80a364a <_ZNSt10lock_guardI14RecursiveMutexED1Ev>
        if (activeHandlers_.size() == 1) {
            setSystemCallbacks();
        }
    }
    return true;
}
 80a3a0e:	4628      	mov	r0, r5
 80a3a10:	b003      	add	sp, #12
 80a3a12:	bd30      	pop	{r4, r5, pc}

080a3a14 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>:
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
        if (dest > p && dest < end) {
 80a3a14:	4288      	cmp	r0, r1
    static void move(T* dest, const T* p, const T* end) {
        ::memmove(dest, p, (end - p) * sizeof(T));
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    static void move(T* dest, T* p, T* end) {
 80a3a16:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3a18:	4606      	mov	r6, r0
 80a3a1a:	460c      	mov	r4, r1
 80a3a1c:	4615      	mov	r5, r2
        if (dest > p && dest < end) {
 80a3a1e:	d914      	bls.n	80a3a4a <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x36>
 80a3a20:	4290      	cmp	r0, r2
 80a3a22:	d213      	bcs.n	80a3a4c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
            // Move elements in reverse order
            --p;
            --end;
 80a3a24:	f1a2 0510 	sub.w	r5, r2, #16
            dest += end - p - 1;
 80a3a28:	1a6c      	subs	r4, r5, r1
 80a3a2a:	f1a1 0710 	sub.w	r7, r1, #16
 80a3a2e:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
 80a3a30:	42af      	cmp	r7, r5
 80a3a32:	d018      	beq.n	80a3a66 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*end));
 80a3a34:	b11c      	cbz	r4, 80a3a3e <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x2a>
 80a3a36:	4629      	mov	r1, r5
 80a3a38:	4620      	mov	r0, r4
 80a3a3a:	f000 fafe 	bl	80a403a <_ZN6StringC1EOS_>
                end->~T();
 80a3a3e:	4628      	mov	r0, r5
 80a3a40:	f000 fb0b 	bl	80a405a <_ZN6StringD1Ev>
        if (dest > p && dest < end) {
            // Move elements in reverse order
            --p;
            --end;
            dest += end - p - 1;
            for (; end != p; --end, --dest) {
 80a3a44:	3d10      	subs	r5, #16
 80a3a46:	3c10      	subs	r4, #16
 80a3a48:	e7f2      	b.n	80a3a30 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x1c>
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
 80a3a4a:	d00c      	beq.n	80a3a66 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
            for (; p != end; ++p, ++dest) {
 80a3a4c:	42ac      	cmp	r4, r5
 80a3a4e:	d00a      	beq.n	80a3a66 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x52>
                new(dest) T(std::move(*p));
 80a3a50:	b11e      	cbz	r6, 80a3a5a <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x46>
 80a3a52:	4621      	mov	r1, r4
 80a3a54:	4630      	mov	r0, r6
 80a3a56:	f000 faf0 	bl	80a403a <_ZN6StringC1EOS_>
                p->~T();
 80a3a5a:	4620      	mov	r0, r4
 80a3a5c:	f000 fafd 	bl	80a405a <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
                new(dest) T(std::move(*end));
                end->~T();
            }
        } else if (dest != p) {
            for (; p != end; ++p, ++dest) {
 80a3a60:	3410      	adds	r4, #16
 80a3a62:	3610      	adds	r6, #16
 80a3a64:	e7f2      	b.n	80a3a4c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_+0x38>
 80a3a66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3a68 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>:
        capacity_ = n;
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
 80a3a68:	b570      	push	{r4, r5, r6, lr}
        T* d = nullptr;
        if (n > 0) {
 80a3a6a:	1e0e      	subs	r6, r1, #0
        capacity_ = n;
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
 80a3a6c:	4605      	mov	r5, r0
        T* d = nullptr;
        if (n > 0) {
 80a3a6e:	dd0b      	ble.n	80a3a88 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x20>

} // namespace spark

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a3a70:	0130      	lsls	r0, r6, #4
 80a3a72:	f7fe ff2f 	bl	80a28d4 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a3a76:	4604      	mov	r4, r0
 80a3a78:	b170      	cbz	r0, 80a3a98 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x30>
                return false;
            }
            move(d, data_, data_ + size_);
 80a3a7a:	e895 0006 	ldmia.w	r5, {r1, r2}
 80a3a7e:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 80a3a82:	f7ff ffc7 	bl	80a3a14 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
 80a3a86:	e000      	b.n	80a3a8a <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi+0x22>
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a3a88:	2400      	movs	r4, #0
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a3a8a:	6828      	ldr	r0, [r5, #0]
 80a3a8c:	f7fe ff2a 	bl	80a28e4 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a3a90:	602c      	str	r4, [r5, #0]
        capacity_ = n;
 80a3a92:	60ae      	str	r6, [r5, #8]
        return true;
 80a3a94:	2001      	movs	r0, #1
 80a3a96:	bd70      	pop	{r4, r5, r6, pc}
    }
 80a3a98:	bd70      	pop	{r4, r5, r6, pc}

080a3a9a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a3a9a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3a9e:	4692      	mov	sl, r2
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3aa0:	2300      	movs	r3, #0
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a3aa2:	2246      	movs	r2, #70	; 0x46

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a3aa4:	b095      	sub	sp, #84	; 0x54
 80a3aa6:	6003      	str	r3, [r0, #0]
 80a3aa8:	6043      	str	r3, [r0, #4]
 80a3aaa:	6083      	str	r3, [r0, #8]
 80a3aac:	60c3      	str	r3, [r0, #12]
 80a3aae:	6103      	str	r3, [r0, #16]
 80a3ab0:	6143      	str	r3, [r0, #20]
        level_(LOG_LEVEL_NONE) { // Fallback level that will be used in case of construction errors
 80a3ab2:	7602      	strb	r2, [r0, #24]

spark::detail::LogFilter::LogFilter(LogLevel level) :
        level_(level) {
}

spark::detail::LogFilter::LogFilter(LogLevel level, LogCategoryFilters filters) :
 80a3ab4:	9102      	str	r1, [sp, #8]
 80a3ab6:	f8da 1004 	ldr.w	r1, [sl, #4]
 80a3aba:	4605      	mov	r5, r0
    return size_ == 0;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::reserve(int n) {
    if (n > capacity_ && !realloc(n)) {
 80a3abc:	4299      	cmp	r1, r3
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3abe:	9308      	str	r3, [sp, #32]
 80a3ac0:	9309      	str	r3, [sp, #36]	; 0x24
 80a3ac2:	930a      	str	r3, [sp, #40]	; 0x28
    return size_ == 0;
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::reserve(int n) {
    if (n > capacity_ && !realloc(n)) {
 80a3ac4:	f340 809d 	ble.w	80a3c02 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x168>
 80a3ac8:	a808      	add	r0, sp, #32
 80a3aca:	f7ff ffcd 	bl	80a3a68 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a3ace:	2800      	cmp	r0, #0
 80a3ad0:	f040 8097 	bne.w	80a3c02 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x168>
 80a3ad4:	e08e      	b.n	80a3bf4 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x15a>
    Vector<String> cats;
    if (!cats.reserve(filters.size())) {
        return;
    }
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
 80a3ad6:	4621      	mov	r1, r4
 80a3ad8:	a80b      	add	r0, sp, #44	; 0x2c
 80a3ada:	f000 faae 	bl	80a403a <_ZN6StringC1EOS_>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a3ade:	a90b      	add	r1, sp, #44	; 0x2c
 80a3ae0:	a80f      	add	r0, sp, #60	; 0x3c
 80a3ae2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80a3ae4:	f000 faa9 	bl	80a403a <_ZN6StringC1EOS_>
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a3ae8:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a3aea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a3aec:	4299      	cmp	r1, r3
 80a3aee:	f2c0 80ce 	blt.w	80a3c8e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f4>
 80a3af2:	3101      	adds	r1, #1
 80a3af4:	a808      	add	r0, sp, #32
 80a3af6:	f7ff ffb7 	bl	80a3a68 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE7reallocIS1_Li0EEEbi>
 80a3afa:	2800      	cmp	r0, #0
 80a3afc:	f040 80c7 	bne.w	80a3c8e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1f4>
    AllocatorT::free(data_);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::append(T value) {
    return insert(size_, std::move(value));
 80a3b00:	a80f      	add	r0, sp, #60	; 0x3c
 80a3b02:	f000 faaa 	bl	80a405a <_ZN6StringD1Ev>
 80a3b06:	a80b      	add	r0, sp, #44	; 0x2c
 80a3b08:	f000 faa7 	bl	80a405a <_ZN6StringD1Ev>
 80a3b0c:	3414      	adds	r4, #20
    // Store category names
    Vector<String> cats;
    if (!cats.reserve(filters.size())) {
        return;
    }
    for (LogCategoryFilter &filter: filters) {
 80a3b0e:	42a7      	cmp	r7, r4
 80a3b10:	d1e1      	bne.n	80a3ad6 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x3c>
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3b12:	2600      	movs	r6, #0
        if (!category) {
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a3b14:	46b1      	mov	r9, r6
 80a3b16:	960b      	str	r6, [sp, #44]	; 0x2c
 80a3b18:	960c      	str	r6, [sp, #48]	; 0x30
 80a3b1a:	960d      	str	r6, [sp, #52]	; 0x34
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
    for (int i = 0; i < cats.size(); ++i) {
 80a3b1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a3b1e:	429e      	cmp	r6, r3
 80a3b20:	f280 80a8 	bge.w	80a3c74 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1da>
 80a3b24:	9a08      	ldr	r2, [sp, #32]
 80a3b26:	0133      	lsls	r3, r6, #4
 80a3b28:	58d3      	ldr	r3, [r2, r3]
        const char *category = cats.at(i).c_str();
 80a3b2a:	9306      	str	r3, [sp, #24]
        if (!category) {
 80a3b2c:	2b00      	cmp	r3, #0
 80a3b2e:	f000 809f 	beq.w	80a3c70 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d6>
 80a3b32:	2314      	movs	r3, #20
 80a3b34:	4373      	muls	r3, r6
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
 80a3b36:	f8cd 901c 	str.w	r9, [sp, #28]
 80a3b3a:	9301      	str	r3, [sp, #4]
    for (int i = 0; i < cats.size(); ++i) {
        const char *category = cats.at(i).c_str();
        if (!category) {
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
 80a3b3c:	ac0b      	add	r4, sp, #44	; 0x2c
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a3b3e:	a907      	add	r1, sp, #28
 80a3b40:	a806      	add	r0, sp, #24
 80a3b42:	f7ff f9a0 	bl	80a2e86 <_ZN12_GLOBAL__N_119nextSubcategoryNameERPKcRj>
 80a3b46:	4607      	mov	r7, r0
 80a3b48:	2800      	cmp	r0, #0
 80a3b4a:	f000 8091 	beq.w	80a3c70 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d6>
            bool found = false;
 80a3b4e:	ab14      	add	r3, sp, #80	; 0x50
            const int index = nodeIndex(*pNodes, name, size, found);
 80a3b50:	4601      	mov	r1, r0
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
 80a3b52:	f803 9d39 	strb.w	r9, [r3, #-57]!
            const int index = nodeIndex(*pNodes, name, size, found);
 80a3b56:	9a07      	ldr	r2, [sp, #28]
 80a3b58:	4620      	mov	r0, r4
 80a3b5a:	f7ff fb83 	bl	80a3264 <_ZN5spark6detail9LogFilter9nodeIndexERKNS_6VectorINS1_4NodeENS_16DefaultAllocatorEEEPKcjRb>
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a3b5e:	f89d 8017 	ldrb.w	r8, [sp, #23]
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
 80a3b62:	9000      	str	r0, [sp, #0]
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a3b64:	f1b8 0f00 	cmp.w	r8, #0
 80a3b68:	d153      	bne.n	80a3c12 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x178>
 80a3b6a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    Vector<Node> nodes; // Children nodes

    Node(const char *name, uint16_t size) :
            name(name),
            size(size),
            level(-1) {
 80a3b6e:	970f      	str	r7, [sp, #60]	; 0x3c
 80a3b70:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
 80a3b74:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80a3b78:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
 80a3b7c:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
 80a3b80:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
 80a3b84:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a3b88:	6867      	ldr	r7, [r4, #4]
 80a3b8a:	68a3      	ldr	r3, [r4, #8]
 80a3b8c:	429f      	cmp	r7, r3
 80a3b8e:	da4f      	bge.n	80a3c30 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x196>
        return false;
    }
    T* const p = data_ + i;
 80a3b90:	9b00      	ldr	r3, [sp, #0]
 80a3b92:	2214      	movs	r2, #20
 80a3b94:	4353      	muls	r3, r2
 80a3b96:	f8d4 b000 	ldr.w	fp, [r4]
    move(p + 1, p, data_ + size_);
 80a3b9a:	6861      	ldr	r1, [r4, #4]
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a3b9c:	eb0b 0703 	add.w	r7, fp, r3
    move(p + 1, p, data_ + size_);
 80a3ba0:	fb02 b201 	mla	r2, r2, r1, fp
 80a3ba4:	f107 0014 	add.w	r0, r7, #20
 80a3ba8:	4639      	mov	r1, r7
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a3baa:	9303      	str	r3, [sp, #12]
    move(p + 1, p, data_ + size_);
 80a3bac:	f7ff fe95 	bl	80a38da <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
    new(p) T(std::move(value));
 80a3bb0:	b1a7      	cbz	r7, 80a3bdc <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x142>
    |
    `- aa (error) - b (warn)
*/

// spark::detail::LogFilter
struct spark::detail::LogFilter::Node {
 80a3bb2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a3bb4:	9b03      	ldr	r3, [sp, #12]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3bb6:	a911      	add	r1, sp, #68	; 0x44
 80a3bb8:	f84b 2003 	str.w	r2, [fp, r3]
 80a3bbc:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
 80a3bc0:	f107 0008 	add.w	r0, r7, #8
 80a3bc4:	80bb      	strh	r3, [r7, #4]
 80a3bc6:	f9bd 3042 	ldrsh.w	r3, [sp, #66]	; 0x42
// spark::Vector
template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector() :
        data_(nullptr),
        size_(0),
        capacity_(0) {
 80a3bca:	f8c7 9008 	str.w	r9, [r7, #8]
 80a3bce:	80fb      	strh	r3, [r7, #6]
 80a3bd0:	f8c7 900c 	str.w	r9, [r7, #12]
 80a3bd4:	f8c7 9010 	str.w	r9, [r7, #16]
    }
}

template<typename T, typename AllocatorT>
inline spark::Vector<T, AllocatorT>::Vector(Vector<T, AllocatorT>&& vector) : Vector() {
    swap(*this, vector);
 80a3bd8:	f7ff fe68 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
        return false;
    }
    T* const p = data_ + i;
    move(p + 1, p, data_ + size_);
    new(p) T(std::move(value));
    ++size_;
 80a3bdc:	6863      	ldr	r3, [r4, #4]
 80a3bde:	3301      	adds	r3, #1
 80a3be0:	6063      	str	r3, [r4, #4]
 80a3be2:	a811      	add	r0, sp, #68	; 0x44
 80a3be4:	f7ff fcd8 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a3be8:	f1b8 0f00 	cmp.w	r8, #0
 80a3bec:	d011      	beq.n	80a3c12 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x178>
    }
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
 80a3bee:	a80b      	add	r0, sp, #44	; 0x2c
 80a3bf0:	f7ff fcd2 	bl	80a3598 <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEED1Ev>
 80a3bf4:	a808      	add	r0, sp, #32
 80a3bf6:	f7ff fce3 	bl	80a35c0 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
    }
    using std::swap;
    swap(cats_, cats);
    swap(nodes_, nodes);
    level_ = level;
}
 80a3bfa:	4628      	mov	r0, r5
 80a3bfc:	b015      	add	sp, #84	; 0x54
 80a3bfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a3c02:	f8da 4000 	ldr.w	r4, [sl]
    return data_;
}

template<typename T, typename AllocatorT>
T* spark::Vector<T, AllocatorT>::end() {
    return data_ + size_;
 80a3c06:	f8da 3004 	ldr.w	r3, [sl, #4]
 80a3c0a:	2714      	movs	r7, #20
 80a3c0c:	fb07 4703 	mla	r7, r7, r3, r4
 80a3c10:	e77d      	b.n	80a3b0e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x74>
    return data_[size_ - 1];
}

template<typename T, typename AllocatorT>
inline T& spark::Vector<T, AllocatorT>::at(int i) {
    return data_[i];
 80a3c12:	6823      	ldr	r3, [r4, #0]
 80a3c14:	9a00      	ldr	r2, [sp, #0]
 80a3c16:	2414      	movs	r4, #20
 80a3c18:	fb04 3402 	mla	r4, r4, r2, r3
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
                return;
            }
            Node &node = pNodes->at(index);
            if (!*category) { // Check if it's last subcategory
 80a3c1c:	9b06      	ldr	r3, [sp, #24]
 80a3c1e:	781b      	ldrb	r3, [r3, #0]
 80a3c20:	bb23      	cbnz	r3, 80a3c6c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d2>
                node.level = filters.at(i).level_;
 80a3c22:	f8da 3000 	ldr.w	r3, [sl]
 80a3c26:	9a01      	ldr	r2, [sp, #4]
 80a3c28:	4413      	add	r3, r2
 80a3c2a:	7c1b      	ldrb	r3, [r3, #16]
 80a3c2c:	80e3      	strh	r3, [r4, #6]
 80a3c2e:	e01d      	b.n	80a3c6c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1d2>
    return insert(0, vector);
}

template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
 80a3c30:	3701      	adds	r7, #1
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
 80a3c32:	2f00      	cmp	r7, #0
 80a3c34:	dd0f      	ble.n	80a3c56 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1bc>

} // namespace spark

// spark::DefaultAllocator
inline void* spark::DefaultAllocator::malloc(size_t size) {
    return ::malloc(size);
 80a3c36:	2314      	movs	r3, #20
 80a3c38:	fb03 f007 	mul.w	r0, r3, r7
 80a3c3c:	9303      	str	r3, [sp, #12]
 80a3c3e:	f7fe fe49 	bl	80a28d4 <malloc>
    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
        if (n > 0) {
            d = (T*)AllocatorT::malloc(n * sizeof(T));
            if (!d) {
 80a3c42:	4683      	mov	fp, r0
 80a3c44:	b178      	cbz	r0, 80a3c66 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1cc>
                return false;
            }
            move(d, data_, data_ + size_);
 80a3c46:	e894 0006 	ldmia.w	r4, {r1, r2}
 80a3c4a:	9b03      	ldr	r3, [sp, #12]
 80a3c4c:	fb03 1202 	mla	r2, r3, r2, r1
 80a3c50:	f7ff fe43 	bl	80a38da <_ZN5spark6VectorINS_6detail9LogFilter4NodeENS_16DefaultAllocatorEE4moveIS3_Li0EEEvPS3_S7_S7_>
 80a3c54:	e000      	b.n	80a3c58 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x1be>
        return true;
    }

    template<PARTICLE_VECTOR_ENABLE_IF_NOT_TRIVIALLY_COPYABLE(T)>
    bool realloc(int n) {
        T* d = nullptr;
 80a3c56:	46c3      	mov	fp, r8
inline void* spark::DefaultAllocator::realloc(void* ptr, size_t size) {
    return ::realloc(ptr, size);
}

inline void spark::DefaultAllocator::free(void* ptr) {
    ::free(ptr);
 80a3c58:	6820      	ldr	r0, [r4, #0]
 80a3c5a:	f7fe fe43 	bl	80a28e4 <free>
                return false;
            }
            move(d, data_, data_ + size_);
        }
        AllocatorT::free(data_);
        data_ = d;
 80a3c5e:	f8c4 b000 	str.w	fp, [r4]
        capacity_ = n;
 80a3c62:	60a7      	str	r7, [r4, #8]
 80a3c64:	e794      	b.n	80a3b90 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xf6>
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
            bool found = false;
            const int index = nodeIndex(*pNodes, name, size, found);
            if (!found && !pNodes->insert(index, Node(name, size))) { // Add node
 80a3c66:	f04f 0801 	mov.w	r8, #1
 80a3c6a:	e7ba      	b.n	80a3be2 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x148>
            }
            Node &node = pNodes->at(index);
            if (!*category) { // Check if it's last subcategory
                node.level = filters.at(i).level_;
            }
            pNodes = &node.nodes;
 80a3c6c:	3408      	adds	r4, #8
            continue; // Invalid usage or string allocation error
        }
        Vector<Node> *pNodes = &nodes; // Root nodes
        const char *name = nullptr; // Subcategory name
        size_t size = 0; // Name length
        while ((name = nextSubcategoryName(category, size))) {
 80a3c6e:	e766      	b.n	80a3b3e <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0xa4>
    for (LogCategoryFilter &filter: filters) {
        cats.append(std::move(filter.cat_));
    }
    // Process category filters
    Vector<Node> nodes;
    for (int i = 0; i < cats.size(); ++i) {
 80a3c70:	3601      	adds	r6, #1
 80a3c72:	e753      	b.n	80a3b1c <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x82>
            }
            pNodes = &node.nodes;
        }
    }
    using std::swap;
    swap(cats_, cats);
 80a3c74:	a908      	add	r1, sp, #32
 80a3c76:	4628      	mov	r0, r5
 80a3c78:	f7ff fe18 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
    swap(nodes_, nodes);
 80a3c7c:	a90b      	add	r1, sp, #44	; 0x2c
 80a3c7e:	f105 000c 	add.w	r0, r5, #12
 80a3c82:	f7ff fe13 	bl	80a38ac <_ZN5spark4swapINS_17LogCategoryFilterENS_16DefaultAllocatorEEEvRNS_6VectorIT_T0_EES7_>
    level_ = level;
 80a3c86:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80a3c8a:	762b      	strb	r3, [r5, #24]
 80a3c8c:	e7af      	b.n	80a3bee <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x154>
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a3c8e:	9b08      	ldr	r3, [sp, #32]
    move(p + 1, p, data_ + size_);
 80a3c90:	9a09      	ldr	r2, [sp, #36]	; 0x24
template<typename T, typename AllocatorT>
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
        return false;
    }
    T* const p = data_ + i;
 80a3c92:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    move(p + 1, p, data_ + size_);
 80a3c96:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 80a3c9a:	4631      	mov	r1, r6
 80a3c9c:	f106 0010 	add.w	r0, r6, #16
 80a3ca0:	f7ff feb8 	bl	80a3a14 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEE4moveIS1_Li0EEEvPS1_S5_S5_>
    new(p) T(std::move(value));
 80a3ca4:	b11e      	cbz	r6, 80a3cae <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x214>
 80a3ca6:	a90f      	add	r1, sp, #60	; 0x3c
 80a3ca8:	4630      	mov	r0, r6
 80a3caa:	f000 f9c6 	bl	80a403a <_ZN6StringC1EOS_>
    ++size_;
 80a3cae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a3cb0:	3301      	adds	r3, #1
 80a3cb2:	9309      	str	r3, [sp, #36]	; 0x24
 80a3cb4:	e724      	b.n	80a3b00 <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x66>
	...

080a3cb8 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>:
// spark::LogHandler
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a3cb8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        filter_(level, filters) {
 80a3cba:	4604      	mov	r4, r0
// spark::LogHandler
inline spark::LogHandler::LogHandler(LogLevel level) :
        filter_(level) {
}

inline spark::LogHandler::LogHandler(LogLevel level, LogCategoryFilters filters) :
 80a3cbc:	460e      	mov	r6, r1
 80a3cbe:	4605      	mov	r5, r0
        filter_(level, filters) {
 80a3cc0:	4b08      	ldr	r3, [pc, #32]	; (80a3ce4 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE+0x2c>)
 80a3cc2:	4611      	mov	r1, r2
 80a3cc4:	f844 3b04 	str.w	r3, [r4], #4
 80a3cc8:	a801      	add	r0, sp, #4
 80a3cca:	f7fc fc80 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a3cce:	aa01      	add	r2, sp, #4
 80a3cd0:	4631      	mov	r1, r6
 80a3cd2:	4620      	mov	r0, r4
 80a3cd4:	f7ff fee1 	bl	80a3a9a <_ZN5spark6detail9LogFilterC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a3cd8:	a801      	add	r0, sp, #4
 80a3cda:	f7fc fc2d 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
}
 80a3cde:	4628      	mov	r0, r5
 80a3ce0:	b004      	add	sp, #16
 80a3ce2:	bd70      	pop	{r4, r5, r6, pc}
 80a3ce4:	080a51c8 	.word	0x080a51c8

080a3ce8 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE>:

#if Wiring_LogConfig

// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
 80a3ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a3cea:	460f      	mov	r7, r1
 80a3cec:	b08b      	sub	sp, #44	; 0x2c
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a3cee:	492b      	ldr	r1, [pc, #172]	; (80a3d9c <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb4>)
 80a3cf0:	4638      	mov	r0, r7

#if Wiring_LogConfig

// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
 80a3cf2:	4616      	mov	r6, r2
 80a3cf4:	461d      	mov	r5, r3
 80a3cf6:	9c10      	ldr	r4, [sp, #64]	; 0x40
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
 80a3cf8:	f001 f97a 	bl	80a4ff0 <strcmp>
 80a3cfc:	bb28      	cbnz	r0, 80a3d4a <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x62>
        if (!stream) {
 80a3cfe:	2c00      	cmp	r4, #0
 80a3d00:	d049      	beq.n	80a3d96 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xae>
            return nullptr; // Output stream is not specified
        }
        return new(std::nothrow) JSONStreamLogHandler(*stream, level, std::move(filters));
 80a3d02:	4629      	mov	r1, r5
 80a3d04:	a801      	add	r0, sp, #4
 80a3d06:	f7ff fdde 	bl	80a38c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a3d0a:	4925      	ldr	r1, [pc, #148]	; (80a3da0 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb8>)
 80a3d0c:	2024      	movs	r0, #36	; 0x24
 80a3d0e:	f000 ff93 	bl	80a4c38 <_ZnwjRKSt9nothrow_t>
 80a3d12:	4605      	mov	r5, r0
 80a3d14:	b1b8      	cbz	r0, 80a3d46 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0x5e>
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
public:
    using StreamLogHandler::StreamLogHandler;
 80a3d16:	a901      	add	r1, sp, #4
 80a3d18:	a804      	add	r0, sp, #16
 80a3d1a:	f7ff fdd4 	bl	80a38c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a3d1e:	a904      	add	r1, sp, #16
 80a3d20:	a807      	add	r0, sp, #28
 80a3d22:	f7fc fc54 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a3d26:	aa07      	add	r2, sp, #28
 80a3d28:	4631      	mov	r1, r6
 80a3d2a:	4628      	mov	r0, r5
 80a3d2c:	f7ff ffc4 	bl	80a3cb8 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a3d30:	a807      	add	r0, sp, #28
 80a3d32:	f7fc fc01 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a3d36:	4b1b      	ldr	r3, [pc, #108]	; (80a3da4 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xbc>)
 80a3d38:	622c      	str	r4, [r5, #32]
 80a3d3a:	602b      	str	r3, [r5, #0]
    Print *stream_;
};

class JSONStreamLogHandler: public StreamLogHandler {
public:
    using StreamLogHandler::StreamLogHandler;
 80a3d3c:	a804      	add	r0, sp, #16
 80a3d3e:	f7fc fbfb 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a3d42:	4b19      	ldr	r3, [pc, #100]	; (80a3da8 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xc0>)
 80a3d44:	602b      	str	r3, [r5, #0]
 80a3d46:	a801      	add	r0, sp, #4
 80a3d48:	e01f      	b.n	80a3d8a <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa2>
    } else if (strcmp(type, "StreamLogHandler") == 0) {
 80a3d4a:	4918      	ldr	r1, [pc, #96]	; (80a3dac <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xc4>)
 80a3d4c:	4638      	mov	r0, r7
 80a3d4e:	f001 f94f 	bl	80a4ff0 <strcmp>
 80a3d52:	b9f0      	cbnz	r0, 80a3d92 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xaa>
        if (!stream) {
 80a3d54:	b1fc      	cbz	r4, 80a3d96 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xae>
            return nullptr;
        }
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
 80a3d56:	4629      	mov	r1, r5
 80a3d58:	a804      	add	r0, sp, #16
 80a3d5a:	f7ff fdb4 	bl	80a38c6 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1EOS3_>
 80a3d5e:	4910      	ldr	r1, [pc, #64]	; (80a3da0 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb8>)
 80a3d60:	2024      	movs	r0, #36	; 0x24
 80a3d62:	f000 ff69 	bl	80a4c38 <_ZnwjRKSt9nothrow_t>
 80a3d66:	4605      	mov	r5, r0
 80a3d68:	b170      	cbz	r0, 80a3d88 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xa0>
}

// spark::StreamLogHandler
inline spark::StreamLogHandler::StreamLogHandler(Print &stream, LogLevel level, LogCategoryFilters filters) :
        LogHandler(level, filters),
        stream_(&stream) {
 80a3d6a:	a904      	add	r1, sp, #16
 80a3d6c:	a807      	add	r0, sp, #28
 80a3d6e:	f7fc fc2e 	bl	80a05ce <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEC1ERKS3_>
 80a3d72:	aa07      	add	r2, sp, #28
 80a3d74:	4631      	mov	r1, r6
 80a3d76:	4628      	mov	r0, r5
 80a3d78:	f7ff ff9e 	bl	80a3cb8 <_ZN5spark10LogHandlerC1E8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEE>
 80a3d7c:	a807      	add	r0, sp, #28
 80a3d7e:	f7fc fbdb 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a3d82:	4b08      	ldr	r3, [pc, #32]	; (80a3da4 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xbc>)
 80a3d84:	622c      	str	r4, [r5, #32]
 80a3d86:	602b      	str	r3, [r5, #0]
 80a3d88:	a804      	add	r0, sp, #16
 80a3d8a:	f7fc fbd5 	bl	80a0538 <_ZN5spark6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEED1Ev>
 80a3d8e:	4628      	mov	r0, r5
 80a3d90:	e002      	b.n	80a3d98 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb0>
// spark::DefaultLogHandlerFactory
LogHandler* spark::DefaultLogHandlerFactory::createHandler(const char *type, LogLevel level, LogCategoryFilters filters,
            Print *stream, const JSONValue &params) {
    if (strcmp(type, "JSONStreamLogHandler") == 0) {
        if (!stream) {
            return nullptr; // Output stream is not specified
 80a3d92:	2000      	movs	r0, #0
 80a3d94:	e000      	b.n	80a3d98 <_ZN5spark24DefaultLogHandlerFactory13createHandlerEPKc8LogLevelNS_6VectorINS_17LogCategoryFilterENS_16DefaultAllocatorEEEP5PrintRKNS_9JSONValueE+0xb0>
 80a3d96:	4620      	mov	r0, r4
            return nullptr;
        }
        return new(std::nothrow) StreamLogHandler(*stream, level, std::move(filters));
    }
    return nullptr; // Unknown handler type
}
 80a3d98:	b00b      	add	sp, #44	; 0x2c
 80a3d9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a3d9c:	080a5a0e 	.word	0x080a5a0e
 80a3da0:	080a5ba8 	.word	0x080a5ba8
 80a3da4:	080a5a54 	.word	0x080a5a54
 80a3da8:	080a594c 	.word	0x080a594c
 80a3dac:	080a5a12 	.word	0x080a5a12

080a3db0 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a3db0:	4a01      	ldr	r2, [pc, #4]	; (80a3db8 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a3db2:	4b02      	ldr	r3, [pc, #8]	; (80a3dbc <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a3db4:	601a      	str	r2, [r3, #0]
 80a3db6:	4770      	bx	lr
 80a3db8:	080a5a23 	.word	0x080a5a23
 80a3dbc:	200004a0 	.word	0x200004a0

080a3dc0 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a3dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3dc2:	4606      	mov	r6, r0
 80a3dc4:	460d      	mov	r5, r1
 80a3dc6:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a3dc8:	2400      	movs	r4, #0
  while (size--) {
 80a3dca:	42bd      	cmp	r5, r7
 80a3dcc:	d00c      	beq.n	80a3de8 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a3dce:	6833      	ldr	r3, [r6, #0]
 80a3dd0:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a3dd4:	689b      	ldr	r3, [r3, #8]
 80a3dd6:	4630      	mov	r0, r6
 80a3dd8:	4798      	blx	r3
     if (chunk>=0)
 80a3dda:	2800      	cmp	r0, #0
 80a3ddc:	db01      	blt.n	80a3de2 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a3dde:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a3de0:	e7f3      	b.n	80a3dca <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a3de2:	2c00      	cmp	r4, #0
 80a3de4:	bf08      	it	eq
 80a3de6:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a3de8:	4620      	mov	r0, r4
 80a3dea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3dec <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a3dec:	b570      	push	{r4, r5, r6, lr}
 80a3dee:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a3df0:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a3df2:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a3df4:	b149      	cbz	r1, 80a3e0a <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a3df6:	f001 f905 	bl	80a5004 <strlen>
 80a3dfa:	682b      	ldr	r3, [r5, #0]
 80a3dfc:	4602      	mov	r2, r0
 80a3dfe:	4621      	mov	r1, r4
 80a3e00:	4628      	mov	r0, r5
    }
 80a3e02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a3e06:	68db      	ldr	r3, [r3, #12]
 80a3e08:	4718      	bx	r3
    }
 80a3e0a:	bd70      	pop	{r4, r5, r6, pc}

080a3e0c <_ZN5Print5printEPKc>:
 80a3e0c:	b508      	push	{r3, lr}
 80a3e0e:	f7ff ffed 	bl	80a3dec <_ZN5Print5writeEPKc>
 80a3e12:	bd08      	pop	{r3, pc}

080a3e14 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a3e14:	6803      	ldr	r3, [r0, #0]
 80a3e16:	689b      	ldr	r3, [r3, #8]
 80a3e18:	4718      	bx	r3

080a3e1a <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a3e1a:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a3e1c:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a3e1e:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a3e20:	f7ff fff8 	bl	80a3e14 <_ZN5Print5printEc>
  n += print('\n');
 80a3e24:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a3e26:	4604      	mov	r4, r0
  n += print('\n');
 80a3e28:	4628      	mov	r0, r5
 80a3e2a:	f7ff fff3 	bl	80a3e14 <_ZN5Print5printEc>
  return n;
}
 80a3e2e:	4420      	add	r0, r4
 80a3e30:	bd38      	pop	{r3, r4, r5, pc}

080a3e32 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a3e32:	b538      	push	{r3, r4, r5, lr}
 80a3e34:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3e36:	f7ff ffd9 	bl	80a3dec <_ZN5Print5writeEPKc>
 80a3e3a:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a3e3c:	4628      	mov	r0, r5
 80a3e3e:	f7ff ffec 	bl	80a3e1a <_ZN5Print7printlnEv>
  return n;
}
 80a3e42:	4420      	add	r0, r4
 80a3e44:	bd38      	pop	{r3, r4, r5, pc}

080a3e46 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a3e46:	2a01      	cmp	r2, #1
 80a3e48:	bf98      	it	ls
 80a3e4a:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a3e4c:	b530      	push	{r4, r5, lr}
 80a3e4e:	460b      	mov	r3, r1
 80a3e50:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a3e52:	2100      	movs	r1, #0
 80a3e54:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a3e58:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a3e5c:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a3e60:	fb05 3312 	mls	r3, r5, r2, r3
 80a3e64:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a3e66:	2b09      	cmp	r3, #9
 80a3e68:	bf94      	ite	ls
 80a3e6a:	3330      	addls	r3, #48	; 0x30
 80a3e6c:	3337      	addhi	r3, #55	; 0x37
 80a3e6e:	b2db      	uxtb	r3, r3
 80a3e70:	4621      	mov	r1, r4
 80a3e72:	f804 3901 	strb.w	r3, [r4], #-1
 80a3e76:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a3e78:	2d00      	cmp	r5, #0
 80a3e7a:	d1ef      	bne.n	80a3e5c <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a3e7c:	f7ff ffb6 	bl	80a3dec <_ZN5Print5writeEPKc>
}
 80a3e80:	b00b      	add	sp, #44	; 0x2c
 80a3e82:	bd30      	pop	{r4, r5, pc}

080a3e84 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a3e84:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a3e86:	b922      	cbnz	r2, 80a3e92 <_ZN5Print5printEmi+0xe>
 80a3e88:	6803      	ldr	r3, [r0, #0]
 80a3e8a:	b2c9      	uxtb	r1, r1
 80a3e8c:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a3e8e:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a3e90:	4718      	bx	r3
  else return printNumber(n, base);
 80a3e92:	b2d2      	uxtb	r2, r2
}
 80a3e94:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a3e96:	f7ff bfd6 	b.w	80a3e46 <_ZN5Print11printNumberEmh>

080a3e9a <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a3e9a:	f7ff bff3 	b.w	80a3e84 <_ZN5Print5printEmi>

080a3e9e <_ZN5Print7printlnEhi>:
  n += println();
  return n;
}

size_t Print::println(unsigned char b, int base)
{
 80a3e9e:	b538      	push	{r3, r4, r5, lr}
 80a3ea0:	4605      	mov	r5, r0
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a3ea2:	f7ff ffef 	bl	80a3e84 <_ZN5Print5printEmi>
 80a3ea6:	4604      	mov	r4, r0
}

size_t Print::println(unsigned char b, int base)
{
  size_t n = print(b, base);
  n += println();
 80a3ea8:	4628      	mov	r0, r5
 80a3eaa:	f7ff ffb6 	bl	80a3e1a <_ZN5Print7printlnEv>
  return n;
}
 80a3eae:	4420      	add	r0, r4
 80a3eb0:	bd38      	pop	{r3, r4, r5, pc}

080a3eb2 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
 80a3eb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a3eb6:	4607      	mov	r7, r0
 80a3eb8:	460e      	mov	r6, r1
  if (base == 0) {
 80a3eba:	4615      	mov	r5, r2
 80a3ebc:	b92a      	cbnz	r2, 80a3eca <_ZN5Print5printEli+0x18>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a3ebe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
 80a3ec2:	6803      	ldr	r3, [r0, #0]
 80a3ec4:	b2c9      	uxtb	r1, r1
 80a3ec6:	689b      	ldr	r3, [r3, #8]
 80a3ec8:	4718      	bx	r3
  } else if (base == 10) {
 80a3eca:	2a0a      	cmp	r2, #10
 80a3ecc:	d102      	bne.n	80a3ed4 <_ZN5Print5printEli+0x22>
    if (n < 0) {
 80a3ece:	2900      	cmp	r1, #0
 80a3ed0:	da01      	bge.n	80a3ed6 <_ZN5Print5printEli+0x24>
 80a3ed2:	e004      	b.n	80a3ede <_ZN5Print5printEli+0x2c>
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a3ed4:	b2d2      	uxtb	r2, r2
  }
}
 80a3ed6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a3eda:	f7ff bfb4 	b.w	80a3e46 <_ZN5Print11printNumberEmh>
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a3ede:	212d      	movs	r1, #45	; 0x2d
 80a3ee0:	f7ff ff98 	bl	80a3e14 <_ZN5Print5printEc>
      n = -n;
      return printNumber(n, 10) + t;
 80a3ee4:	462a      	mov	r2, r5
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a3ee6:	4604      	mov	r4, r0
      n = -n;
      return printNumber(n, 10) + t;
 80a3ee8:	4271      	negs	r1, r6
 80a3eea:	4638      	mov	r0, r7
 80a3eec:	f7ff ffab 	bl	80a3e46 <_ZN5Print11printNumberEmh>
 80a3ef0:	4420      	add	r0, r4
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a3ef2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a3ef6 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
 80a3ef6:	b538      	push	{r3, r4, r5, lr}
 80a3ef8:	4605      	mov	r5, r0
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
 80a3efa:	f7ff ffda 	bl	80a3eb2 <_ZN5Print5printEli>
 80a3efe:	4604      	mov	r4, r0
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
 80a3f00:	4628      	mov	r0, r5
 80a3f02:	f7ff ff8a 	bl	80a3e1a <_ZN5Print7printlnEv>
  return n;
}
 80a3f06:	4420      	add	r0, r4
 80a3f08:	bd38      	pop	{r3, r4, r5, pc}

080a3f0a <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a3f0a:	b40c      	push	{r2, r3}
 80a3f0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a3f10:	b087      	sub	sp, #28
 80a3f12:	af00      	add	r7, sp, #0
 80a3f14:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a3f18:	f854 9b04 	ldr.w	r9, [r4], #4
 80a3f1c:	4605      	mov	r5, r0
 80a3f1e:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a3f20:	4623      	mov	r3, r4
 80a3f22:	464a      	mov	r2, r9
 80a3f24:	2114      	movs	r1, #20
 80a3f26:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a3f28:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a3f2a:	f7fe fcf3 	bl	80a2914 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a3f2e:	2813      	cmp	r0, #19
 80a3f30:	d805      	bhi.n	80a3f3e <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3f32:	1d39      	adds	r1, r7, #4
 80a3f34:	4628      	mov	r0, r5
 80a3f36:	f7ff ff59 	bl	80a3dec <_ZN5Print5writeEPKc>
 80a3f3a:	4604      	mov	r4, r0
 80a3f3c:	e013      	b.n	80a3f66 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3f3e:	f100 0308 	add.w	r3, r0, #8
 80a3f42:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a3f46:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3f48:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a3f4c:	1c41      	adds	r1, r0, #1
 80a3f4e:	4623      	mov	r3, r4
 80a3f50:	464a      	mov	r2, r9
 80a3f52:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a3f54:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a3f56:	f7fe fcdd 	bl	80a2914 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3f5a:	4669      	mov	r1, sp
 80a3f5c:	4628      	mov	r0, r5
 80a3f5e:	f7ff ff45 	bl	80a3dec <_ZN5Print5writeEPKc>
 80a3f62:	4604      	mov	r4, r0
 80a3f64:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a3f66:	b11e      	cbz	r6, 80a3f70 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a3f68:	4628      	mov	r0, r5
 80a3f6a:	f7ff ff56 	bl	80a3e1a <_ZN5Print7printlnEv>
 80a3f6e:	4404      	add	r4, r0
    return n;
}
 80a3f70:	4620      	mov	r0, r4
 80a3f72:	371c      	adds	r7, #28
 80a3f74:	46bd      	mov	sp, r7
 80a3f76:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a3f7a:	b002      	add	sp, #8
 80a3f7c:	4770      	bx	lr

080a3f7e <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a3f7e:	b510      	push	{r4, lr}
 80a3f80:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a3f82:	f7fe fcd2 	bl	80a292a <_ZNSt14_Function_baseD1Ev>
 80a3f86:	4620      	mov	r0, r4
 80a3f88:	bd10      	pop	{r4, pc}
	...

080a3f8c <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a3f8c:	4803      	ldr	r0, [pc, #12]	; (80a3f9c <_GLOBAL__sub_I_RGB+0x10>)
 80a3f8e:	2300      	movs	r3, #0
 80a3f90:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a3f92:	4a03      	ldr	r2, [pc, #12]	; (80a3fa0 <_GLOBAL__sub_I_RGB+0x14>)
 80a3f94:	4903      	ldr	r1, [pc, #12]	; (80a3fa4 <_GLOBAL__sub_I_RGB+0x18>)
 80a3f96:	f000 be41 	b.w	80a4c1c <__aeabi_atexit>
 80a3f9a:	bf00      	nop
 80a3f9c:	200004a4 	.word	0x200004a4
 80a3fa0:	2000039c 	.word	0x2000039c
 80a3fa4:	080a3f7f 	.word	0x080a3f7f

080a3fa8 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a3fa8:	4770      	bx	lr

080a3faa <_ZN8SPIClassD0Ev>:
 80a3faa:	b510      	push	{r4, lr}
 80a3fac:	4604      	mov	r4, r0
 80a3fae:	f7fc f876 	bl	80a009e <_ZdlPv>
 80a3fb2:	4620      	mov	r0, r4
 80a3fb4:	bd10      	pop	{r4, pc}
	...

080a3fb8 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a3fb8:	b570      	push	{r4, r5, r6, lr}
 80a3fba:	4604      	mov	r4, r0
 80a3fbc:	460e      	mov	r6, r1
 80a3fbe:	4b07      	ldr	r3, [pc, #28]	; (80a3fdc <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a3fc0:	2500      	movs	r5, #0
 80a3fc2:	6003      	str	r3, [r0, #0]
 80a3fc4:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a3fc8:	f7fe fa4e 	bl	80a2468 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a3fcc:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a3fce:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a3fd0:	f7fe fb54 	bl	80a267c <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a3fd4:	60a5      	str	r5, [r4, #8]
}
 80a3fd6:	4620      	mov	r0, r4
 80a3fd8:	bd70      	pop	{r4, r5, r6, pc}
 80a3fda:	bf00      	nop
 80a3fdc:	080a5a84 	.word	0x080a5a84

080a3fe0 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a3fe0:	7900      	ldrb	r0, [r0, #4]
 80a3fe2:	f7fe bb53 	b.w	80a268c <HAL_SPI_Is_Enabled>

080a3fe6 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
 80a3fe6:	b510      	push	{r4, lr}
 80a3fe8:	4604      	mov	r4, r0
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a3fea:	f7fe fa7d 	bl	80a24e8 <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
 80a3fee:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
 80a3ff0:	6823      	ldr	r3, [r4, #0]
 80a3ff2:	4620      	mov	r0, r4
 80a3ff4:	695b      	ldr	r3, [r3, #20]
 80a3ff6:	4798      	blx	r3
    if (c >= 0) return c;
 80a3ff8:	2800      	cmp	r0, #0
 80a3ffa:	da08      	bge.n	80a400e <_ZN6Stream9timedReadEv+0x28>
 80a3ffc:	f7fe fa74 	bl	80a24e8 <HAL_Timer_Get_Milli_Seconds>
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  _startMillis = millis();
  do {
 80a4000:	68e3      	ldr	r3, [r4, #12]
 80a4002:	1ac0      	subs	r0, r0, r3
 80a4004:	68a3      	ldr	r3, [r4, #8]
 80a4006:	4298      	cmp	r0, r3
 80a4008:	d3f2      	bcc.n	80a3ff0 <_ZN6Stream9timedReadEv+0xa>
    c = read();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
 80a400a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a400e:	bd10      	pop	{r4, pc}

080a4010 <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
 80a4010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4014:	4680      	mov	r8, r0
 80a4016:	460d      	mov	r5, r1
 80a4018:	460c      	mov	r4, r1
 80a401a:	188f      	adds	r7, r1, r2
  size_t count = 0;
  while (count < length) {
 80a401c:	42bc      	cmp	r4, r7
 80a401e:	eba4 0605 	sub.w	r6, r4, r5
 80a4022:	d007      	beq.n	80a4034 <_ZN6Stream9readBytesEPcj+0x24>
    int c = timedRead();
 80a4024:	4640      	mov	r0, r8
 80a4026:	f7ff ffde 	bl	80a3fe6 <_ZN6Stream9timedReadEv>
    if (c < 0) break;
 80a402a:	2800      	cmp	r0, #0
 80a402c:	db02      	blt.n	80a4034 <_ZN6Stream9readBytesEPcj+0x24>
    *buffer++ = (char)c;
 80a402e:	f804 0b01 	strb.w	r0, [r4], #1
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
  size_t count = 0;
  while (count < length) {
 80a4032:	e7f3      	b.n	80a401c <_ZN6Stream9readBytesEPcj+0xc>
    if (c < 0) break;
    *buffer++ = (char)c;
    count++;
  }
  return count;
}
 80a4034:	4630      	mov	r0, r6
 80a4036:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a403a <_ZN6StringC1EOS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a403a:	2300      	movs	r3, #0
 80a403c:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a403e:	6043      	str	r3, [r0, #4]
	len = 0;
 80a4040:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a4042:	7303      	strb	r3, [r0, #12]
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
 80a4044:	b510      	push	{r4, lr}
			return;
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
 80a4046:	680c      	ldr	r4, [r1, #0]
 80a4048:	6004      	str	r4, [r0, #0]
	capacity = rhs.capacity;
 80a404a:	684c      	ldr	r4, [r1, #4]
 80a404c:	6044      	str	r4, [r0, #4]
	len = rhs.len;
 80a404e:	688c      	ldr	r4, [r1, #8]
 80a4050:	6084      	str	r4, [r0, #8]
	rhs.buffer = NULL;
 80a4052:	600b      	str	r3, [r1, #0]
	rhs.capacity = 0;
 80a4054:	604b      	str	r3, [r1, #4]
	rhs.len = 0;
 80a4056:	608b      	str	r3, [r1, #8]
#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
{
	init();
	move(rval);
}
 80a4058:	bd10      	pop	{r4, pc}

080a405a <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a405a:	b510      	push	{r4, lr}
 80a405c:	4604      	mov	r4, r0
{
	free(buffer);
 80a405e:	6800      	ldr	r0, [r0, #0]
 80a4060:	f7fe fc40 	bl	80a28e4 <free>
}
 80a4064:	4620      	mov	r0, r4
 80a4066:	bd10      	pop	{r4, pc}

080a4068 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a4068:	b510      	push	{r4, lr}
 80a406a:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a406c:	6800      	ldr	r0, [r0, #0]
 80a406e:	b108      	cbz	r0, 80a4074 <_ZN6String10invalidateEv+0xc>
 80a4070:	f7fe fc38 	bl	80a28e4 <free>
	buffer = NULL;
 80a4074:	2300      	movs	r3, #0
 80a4076:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a4078:	60a3      	str	r3, [r4, #8]
 80a407a:	6063      	str	r3, [r4, #4]
 80a407c:	bd10      	pop	{r4, pc}

080a407e <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a407e:	b538      	push	{r3, r4, r5, lr}
 80a4080:	4604      	mov	r4, r0
 80a4082:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a4084:	6800      	ldr	r0, [r0, #0]
 80a4086:	3101      	adds	r1, #1
 80a4088:	f7fe fc34 	bl	80a28f4 <realloc>
	if (newbuffer) {
 80a408c:	b110      	cbz	r0, 80a4094 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a408e:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a4092:	2001      	movs	r0, #1
	}
	return 0;
}
 80a4094:	bd38      	pop	{r3, r4, r5, pc}

080a4096 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a4096:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a4098:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a409a:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a409c:	b113      	cbz	r3, 80a40a4 <_ZN6String7reserveEj+0xe>
 80a409e:	6843      	ldr	r3, [r0, #4]
 80a40a0:	428b      	cmp	r3, r1
 80a40a2:	d207      	bcs.n	80a40b4 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a40a4:	4620      	mov	r0, r4
 80a40a6:	f7ff ffea 	bl	80a407e <_ZN6String12changeBufferEj>
 80a40aa:	b120      	cbz	r0, 80a40b6 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a40ac:	68a3      	ldr	r3, [r4, #8]
 80a40ae:	b90b      	cbnz	r3, 80a40b4 <_ZN6String7reserveEj+0x1e>
 80a40b0:	6822      	ldr	r2, [r4, #0]
 80a40b2:	7013      	strb	r3, [r2, #0]
 80a40b4:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a40b6:	bd10      	pop	{r4, pc}

080a40b8 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a40b8:	b570      	push	{r4, r5, r6, lr}
 80a40ba:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a40bc:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a40be:	4604      	mov	r4, r0
 80a40c0:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a40c2:	f7ff ffe8 	bl	80a4096 <_ZN6String7reserveEj>
 80a40c6:	b918      	cbnz	r0, 80a40d0 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a40c8:	4620      	mov	r0, r4
 80a40ca:	f7ff ffcd 	bl	80a4068 <_ZN6String10invalidateEv>
		return *this;
 80a40ce:	e009      	b.n	80a40e4 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a40d0:	462a      	mov	r2, r5
 80a40d2:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a40d4:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a40d6:	6820      	ldr	r0, [r4, #0]
 80a40d8:	f000 ff1c 	bl	80a4f14 <memcpy>
	buffer[len] = 0;
 80a40dc:	6822      	ldr	r2, [r4, #0]
 80a40de:	68a3      	ldr	r3, [r4, #8]
 80a40e0:	2100      	movs	r1, #0
 80a40e2:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a40e4:	4620      	mov	r0, r4
 80a40e6:	bd70      	pop	{r4, r5, r6, pc}

080a40e8 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a40e8:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a40ea:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a40ec:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a40ee:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a40f0:	6043      	str	r3, [r0, #4]
	len = 0;
 80a40f2:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a40f4:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a40f6:	460d      	mov	r5, r1
 80a40f8:	b139      	cbz	r1, 80a410a <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a40fa:	4608      	mov	r0, r1
 80a40fc:	f000 ff82 	bl	80a5004 <strlen>
 80a4100:	4629      	mov	r1, r5
 80a4102:	4602      	mov	r2, r0
 80a4104:	4620      	mov	r0, r4
 80a4106:	f7ff ffd7 	bl	80a40b8 <_ZN6String4copyEPKcj>
}
 80a410a:	4620      	mov	r0, r4
 80a410c:	bd38      	pop	{r3, r4, r5, pc}

080a410e <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a410e:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a4110:	b510      	push	{r4, lr}
 80a4112:	460b      	mov	r3, r1
 80a4114:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a4116:	d007      	beq.n	80a4128 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a4118:	6809      	ldr	r1, [r1, #0]
 80a411a:	b119      	cbz	r1, 80a4124 <_ZN6StringaSERKS_+0x16>
 80a411c:	689a      	ldr	r2, [r3, #8]
 80a411e:	f7ff ffcb 	bl	80a40b8 <_ZN6String4copyEPKcj>
 80a4122:	e001      	b.n	80a4128 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a4124:	f7ff ffa0 	bl	80a4068 <_ZN6String10invalidateEv>

	return *this;
}
 80a4128:	4620      	mov	r0, r4
 80a412a:	bd10      	pop	{r4, pc}

080a412c <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a412c:	b510      	push	{r4, lr}
 80a412e:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a4130:	2300      	movs	r3, #0
 80a4132:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a4134:	6043      	str	r3, [r0, #4]
	len = 0;
 80a4136:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a4138:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a413a:	f7ff ffe8 	bl	80a410e <_ZN6StringaSERKS_>
}
 80a413e:	4620      	mov	r0, r4
 80a4140:	bd10      	pop	{r4, pc}
	...

080a4144 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a4144:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a4148:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a414a:	4c0d      	ldr	r4, [pc, #52]	; (80a4180 <_GLOBAL__sub_I_System+0x3c>)
 80a414c:	2500      	movs	r5, #0
 80a414e:	8063      	strh	r3, [r4, #2]
 80a4150:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a4154:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a4156:	80a3      	strh	r3, [r4, #4]
 80a4158:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a415a:	f7fe fb67 	bl	80a282c <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a415e:	a802      	add	r0, sp, #8
 80a4160:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a4164:	462a      	mov	r2, r5
 80a4166:	4629      	mov	r1, r5
 80a4168:	f7fe f99e 	bl	80a24a8 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a416c:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a416e:	2b1e      	cmp	r3, #30
 80a4170:	d104      	bne.n	80a417c <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a4172:	2303      	movs	r3, #3
 80a4174:	7023      	strb	r3, [r4, #0]
 80a4176:	2311      	movs	r3, #17
 80a4178:	8065      	strh	r5, [r4, #2]
 80a417a:	80a3      	strh	r3, [r4, #4]
 80a417c:	b003      	add	sp, #12
 80a417e:	bd30      	pop	{r4, r5, pc}
 80a4180:	200004b4 	.word	0x200004b4

080a4184 <_ZN9TCPClient5writeEh>:
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a4184:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4186:	ac02      	add	r4, sp, #8
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a4188:	6803      	ldr	r3, [r0, #0]
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a418a:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a418e:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a4190:	2201      	movs	r2, #1
 80a4192:	f247 5330 	movw	r3, #30000	; 0x7530
 80a4196:	4621      	mov	r1, r4
 80a4198:	47a8      	blx	r5
}
 80a419a:	b003      	add	sp, #12
 80a419c:	bd30      	pop	{r4, r5, pc}

080a419e <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
 80a419e:	b410      	push	{r4}
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a41a0:	6803      	ldr	r3, [r0, #0]
 80a41a2:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80a41a4:	f247 5330 	movw	r3, #30000	; 0x7530
 80a41a8:	46a4      	mov	ip, r4
}
 80a41aa:	bc10      	pop	{r4}
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a41ac:	4760      	bx	ip

080a41ae <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a41ae:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a41b0:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
 80a41b2:	6803      	ldr	r3, [r0, #0]
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a41b4:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
 80a41b8:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a41ba:	4621      	mov	r1, r4
 80a41bc:	4613      	mov	r3, r2
 80a41be:	2201      	movs	r2, #1
 80a41c0:	47a8      	blx	r5
}
 80a41c2:	b003      	add	sp, #12
 80a41c4:	bd30      	pop	{r4, r5, pc}

080a41c6 <_ZN9TCPClient5flushEv>:
  d_->offset = 0;
  d_->total = 0;
}

void TCPClient::flush()
{
 80a41c6:	4770      	bx	lr

080a41c8 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a41c8:	4770      	bx	lr

080a41ca <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
 80a41ca:	2000      	movs	r0, #0
 80a41cc:	4770      	bx	lr

080a41ce <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a41ce:	b510      	push	{r4, lr}
 80a41d0:	4604      	mov	r4, r0
 80a41d2:	f7fb ff64 	bl	80a009e <_ZdlPv>
 80a41d6:	4620      	mov	r0, r4
 80a41d8:	bd10      	pop	{r4, pc}

080a41da <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a41da:	f7fb bf60 	b.w	80a009e <_ZdlPv>
	...

080a41e0 <_ZN9TCPClient7connectEPKctm>:
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a41e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a41e4:	461f      	mov	r7, r3
    stop();
 80a41e6:	6803      	ldr	r3, [r0, #0]
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a41e8:	b08f      	sub	sp, #60	; 0x3c
    stop();
 80a41ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a41ec:	4606      	mov	r6, r0
 80a41ee:	460c      	mov	r4, r1
 80a41f0:	4690      	mov	r8, r2
    stop();
 80a41f2:	4798      	blx	r3
      int rv = 0;
      if(Network.ready())
 80a41f4:	4b13      	ldr	r3, [pc, #76]	; (80a4244 <_ZN9TCPClient7connectEPKctm+0x64>)
 80a41f6:	6818      	ldr	r0, [r3, #0]
 80a41f8:	6803      	ldr	r3, [r0, #0]
 80a41fa:	681b      	ldr	r3, [r3, #0]
 80a41fc:	4798      	blx	r3
 80a41fe:	b1f0      	cbz	r0, 80a423e <_ZN9TCPClient7connectEPKctm+0x5e>
      {
        IPAddress ip_addr;
 80a4200:	a802      	add	r0, sp, #8
 80a4202:	f7fe fc19 	bl	80a2a38 <_ZN9IPAddressC1Ev>

        if((rv = inet_gethostbyname(host, strlen(host), ip_addr, nif, NULL)) == 0)
 80a4206:	4620      	mov	r0, r4
 80a4208:	f000 fefc 	bl	80a5004 <strlen>
 80a420c:	2300      	movs	r3, #0
 80a420e:	9300      	str	r3, [sp, #0]
 80a4210:	b281      	uxth	r1, r0
 80a4212:	463b      	mov	r3, r7
 80a4214:	aa03      	add	r2, sp, #12
 80a4216:	4620      	mov	r0, r4
 80a4218:	f7fe fad8 	bl	80a27cc <inet_gethostbyname>
 80a421c:	b978      	cbnz	r0, 80a423e <_ZN9TCPClient7connectEPKctm+0x5e>
        {
                return connect(ip_addr, port, nif);
 80a421e:	6833      	ldr	r3, [r6, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a4220:	ad09      	add	r5, sp, #36	; 0x24
 80a4222:	f8d3 9020 	ldr.w	r9, [r3, #32]
 80a4226:	4b08      	ldr	r3, [pc, #32]	; (80a4248 <_ZN9TCPClient7connectEPKctm+0x68>)
 80a4228:	ac03      	add	r4, sp, #12
 80a422a:	9308      	str	r3, [sp, #32]
 80a422c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a422e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a4230:	6823      	ldr	r3, [r4, #0]
 80a4232:	4642      	mov	r2, r8
 80a4234:	702b      	strb	r3, [r5, #0]
 80a4236:	a908      	add	r1, sp, #32
 80a4238:	463b      	mov	r3, r7
 80a423a:	4630      	mov	r0, r6
 80a423c:	47c8      	blx	r9
        }
        else
            DEBUG("unable to get IP for hostname");
      }
      return rv;
}
 80a423e:	b00f      	add	sp, #60	; 0x3c
 80a4240:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a4244:	080a5ba4 	.word	0x080a5ba4
 80a4248:	080a58fc 	.word	0x080a58fc

080a424c <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a424c:	b510      	push	{r4, lr}
 80a424e:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a4250:	6803      	ldr	r3, [r0, #0]
 80a4252:	689b      	ldr	r3, [r3, #8]
 80a4254:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a4256:	68a3      	ldr	r3, [r4, #8]
 80a4258:	3b01      	subs	r3, #1
 80a425a:	60a3      	str	r3, [r4, #8]
 80a425c:	b92b      	cbnz	r3, 80a426a <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30+0x1e>
            _M_destroy();
 80a425e:	6823      	ldr	r3, [r4, #0]
 80a4260:	4620      	mov	r0, r4
        }
    }
 80a4262:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a4266:	68db      	ldr	r3, [r3, #12]
 80a4268:	4718      	bx	r3
 80a426a:	bd10      	pop	{r4, pc}

080a426c <_ZN9TCPClient8remoteIPEv>:
{
   return (status()!=0);
}

IPAddress TCPClient::remoteIP()
{
 80a426c:	b570      	push	{r4, r5, r6, lr}
 80a426e:	4604      	mov	r4, r0
 80a4270:	4606      	mov	r6, r0
 80a4272:	694d      	ldr	r5, [r1, #20]
 80a4274:	4b04      	ldr	r3, [pc, #16]	; (80a4288 <_ZN9TCPClient8remoteIPEv+0x1c>)
 80a4276:	358c      	adds	r5, #140	; 0x8c
 80a4278:	f844 3b04 	str.w	r3, [r4], #4
 80a427c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a427e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a4280:	682b      	ldr	r3, [r5, #0]
    return d_->remoteIP;
}
 80a4282:	4630      	mov	r0, r6
 80a4284:	7023      	strb	r3, [r4, #0]
 80a4286:	bd70      	pop	{r4, r5, r6, pc}
 80a4288:	080a58fc 	.word	0x080a58fc

080a428c <_ZN9TCPClient4peekEv>:
        }
        return read;
}

int TCPClient::peek()
{
 80a428c:	b510      	push	{r4, lr}
 80a428e:	6943      	ldr	r3, [r0, #20]
 80a4290:	4604      	mov	r4, r0
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
 80a4292:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a4296:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a429a:	429a      	cmp	r2, r3
 80a429c:	d005      	beq.n	80a42aa <_ZN9TCPClient4peekEv+0x1e>
 80a429e:	6962      	ldr	r2, [r4, #20]
 80a42a0:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a42a4:	4413      	add	r3, r2
 80a42a6:	7918      	ldrb	r0, [r3, #4]
 80a42a8:	bd10      	pop	{r4, pc}
 80a42aa:	6803      	ldr	r3, [r0, #0]
 80a42ac:	691b      	ldr	r3, [r3, #16]
 80a42ae:	4798      	blx	r3
 80a42b0:	2800      	cmp	r0, #0
 80a42b2:	d1f4      	bne.n	80a429e <_ZN9TCPClient4peekEv+0x12>
 80a42b4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a42b8:	bd10      	pop	{r4, pc}

080a42ba <_ZN9TCPClient4readEv>:
    avail = bufferCount();
    return avail;
}

int TCPClient::read()
{
 80a42ba:	b510      	push	{r4, lr}
 80a42bc:	6943      	ldr	r3, [r0, #20]
 80a42be:	4604      	mov	r4, r0
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
 80a42c0:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a42c4:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a42c8:	429a      	cmp	r2, r3
 80a42ca:	d008      	beq.n	80a42de <_ZN9TCPClient4readEv+0x24>
 80a42cc:	6962      	ldr	r2, [r4, #20]
 80a42ce:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a42d2:	1c59      	adds	r1, r3, #1
 80a42d4:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
 80a42d8:	4413      	add	r3, r2
 80a42da:	7918      	ldrb	r0, [r3, #4]
 80a42dc:	bd10      	pop	{r4, pc}
 80a42de:	6803      	ldr	r3, [r0, #0]
 80a42e0:	691b      	ldr	r3, [r3, #16]
 80a42e2:	4798      	blx	r3
 80a42e4:	2800      	cmp	r0, #0
 80a42e6:	d1f1      	bne.n	80a42cc <_ZN9TCPClient4readEv+0x12>
 80a42e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a42ec:	bd10      	pop	{r4, pc}

080a42ee <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
 80a42ee:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
 80a42f0:	6904      	ldr	r4, [r0, #16]
                offset(0),
                total(0) {
        }

        ~Data() {
            if (socket_handle_valid(sock)) {
 80a42f2:	6820      	ldr	r0, [r4, #0]
 80a42f4:	f7fe f98a 	bl	80a260c <socket_handle_valid>
 80a42f8:	b110      	cbz	r0, 80a4300 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x12>
                socket_close(sock);
 80a42fa:	6820      	ldr	r0, [r4, #0]
 80a42fc:	f7fe f9a6 	bl	80a264c <socket_close>
 80a4300:	4620      	mov	r0, r4
 80a4302:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a4306:	f7fb beca 	b.w	80a009e <_ZdlPv>

080a430a <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a430a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a430c:	6943      	ldr	r3, [r0, #20]
 80a430e:	4617      	mov	r7, r2
        int read = -1;
        if (bufferCount() || available())
 80a4310:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a4314:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a4318:	4605      	mov	r5, r0
        int read = -1;
        if (bufferCount() || available())
 80a431a:	429a      	cmp	r2, r3
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a431c:	460e      	mov	r6, r1
        int read = -1;
        if (bufferCount() || available())
 80a431e:	d106      	bne.n	80a432e <_ZN9TCPClient4readEPhj+0x24>
 80a4320:	6803      	ldr	r3, [r0, #0]
 80a4322:	691b      	ldr	r3, [r3, #16]
 80a4324:	4798      	blx	r3
 80a4326:	b910      	cbnz	r0, 80a432e <_ZN9TCPClient4readEPhj+0x24>
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
 80a4328:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80a432c:	e014      	b.n	80a4358 <_ZN9TCPClient4readEPhj+0x4e>
 80a432e:	6969      	ldr	r1, [r5, #20]
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a4330:	4630      	mov	r0, r6
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a4332:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
 80a4336:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a433a:	4419      	add	r1, r3
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a433c:	1ae4      	subs	r4, r4, r3
int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
 80a433e:	42bc      	cmp	r4, r7
 80a4340:	bf28      	it	cs
 80a4342:	463c      	movcs	r4, r7
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a4344:	3104      	adds	r1, #4
 80a4346:	4622      	mov	r2, r4
 80a4348:	f000 fde4 	bl	80a4f14 <memcpy>
 80a434c:	696a      	ldr	r2, [r5, #20]
          d_->offset += read;
 80a434e:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a4352:	4423      	add	r3, r4
 80a4354:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
        }
        return read;
}
 80a4358:	4620      	mov	r0, r4
 80a435a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a435c <_ZN9TCPClient12flush_bufferEv>:
{
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer()
{
 80a435c:	6942      	ldr	r2, [r0, #20]
  d_->offset = 0;
 80a435e:	2300      	movs	r3, #0
 80a4360:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
 80a4364:	6942      	ldr	r2, [r0, #20]
  d_->total = 0;
 80a4366:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
 80a436a:	4770      	bx	lr

080a436c <_ZN9TCPClient9availableEv>:
{
  return d_->total - d_->offset;
}

int TCPClient::available()
{
 80a436c:	b538      	push	{r3, r4, r5, lr}
 80a436e:	6942      	ldr	r2, [r0, #20]
 80a4370:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
 80a4372:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a4376:	b11b      	cbz	r3, 80a4380 <_ZN9TCPClient9availableEv+0x14>
 80a4378:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
 80a437c:	429a      	cmp	r2, r3
 80a437e:	d00b      	beq.n	80a4398 <_ZN9TCPClient9availableEv+0x2c>
    }


    static NetworkClass& from(network_interface_t nif) {
        // hard-code for now until multiple-networks are implemented.
        return Network;
 80a4380:	4b18      	ldr	r3, [pc, #96]	; (80a43e4 <_ZN9TCPClient9availableEv+0x78>)
 80a4382:	6818      	ldr	r0, [r3, #0]
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a4384:	6803      	ldr	r3, [r0, #0]
 80a4386:	681b      	ldr	r3, [r3, #0]
 80a4388:	4798      	blx	r3
 80a438a:	b318      	cbz	r0, 80a43d4 <_ZN9TCPClient9availableEv+0x68>
 80a438c:	6963      	ldr	r3, [r4, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a438e:	6818      	ldr	r0, [r3, #0]
 80a4390:	f7fe f93c 	bl	80a260c <socket_handle_valid>
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a4394:	b918      	cbnz	r0, 80a439e <_ZN9TCPClient9availableEv+0x32>
 80a4396:	e01d      	b.n	80a43d4 <_ZN9TCPClient9availableEv+0x68>
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
 80a4398:	f7ff ffe0 	bl	80a435c <_ZN9TCPClient12flush_bufferEv>
 80a439c:	e7f0      	b.n	80a4380 <_ZN9TCPClient9availableEv+0x14>
 80a439e:	6960      	ldr	r0, [r4, #20]
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
    {
        // Have room
        if ( d_->total < arraySize(d_->buffer))
 80a43a0:	f8b0 1086 	ldrh.w	r1, [r0, #134]	; 0x86
 80a43a4:	297f      	cmp	r1, #127	; 0x7f
 80a43a6:	d815      	bhi.n	80a43d4 <_ZN9TCPClient9availableEv+0x68>
        {
            int ret = socket_receive(d_->sock, d_->buffer + d_->total , arraySize(d_->buffer)-d_->total, 0);
 80a43a8:	1d05      	adds	r5, r0, #4
 80a43aa:	f1c1 0280 	rsb	r2, r1, #128	; 0x80
 80a43ae:	2300      	movs	r3, #0
 80a43b0:	4429      	add	r1, r5
 80a43b2:	6800      	ldr	r0, [r0, #0]
 80a43b4:	f7fe f942 	bl	80a263c <socket_receive>
            if (ret > 0)
 80a43b8:	2800      	cmp	r0, #0
 80a43ba:	dd0b      	ble.n	80a43d4 <_ZN9TCPClient9availableEv+0x68>
 80a43bc:	6963      	ldr	r3, [r4, #20]
            {
                DEBUG("recv(=%d)",ret);
                if (d_->total == 0) d_->offset = 0;
 80a43be:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a43c2:	b90a      	cbnz	r2, 80a43c8 <_ZN9TCPClient9availableEv+0x5c>
 80a43c4:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
 80a43c8:	6962      	ldr	r2, [r4, #20]
                d_->total += ret;
 80a43ca:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a43ce:	4418      	add	r0, r3
 80a43d0:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
 80a43d4:	6962      	ldr	r2, [r4, #20]
            }
        } // Have Space
    } // WiFi.ready() && isOpen(d_->sock)
    avail = bufferCount();
    return avail;
 80a43d6:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a43da:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
 80a43de:	1a18      	subs	r0, r3, r0
}
 80a43e0:	bd38      	pop	{r3, r4, r5, pc}
 80a43e2:	bf00      	nop
 80a43e4:	080a5ba4 	.word	0x080a5ba4

080a43e8 <_ZN9TCPClient4stopEv>:
{
}


void TCPClient::stop()
{
 80a43e8:	b538      	push	{r3, r4, r5, lr}
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a43ea:	6943      	ldr	r3, [r0, #20]
{
}


void TCPClient::stop()
{
 80a43ec:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a43ee:	6818      	ldr	r0, [r3, #0]
 80a43f0:	f7fe f90c 	bl	80a260c <socket_handle_valid>
void TCPClient::stop()
{
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a43f4:	b118      	cbz	r0, 80a43fe <_ZN9TCPClient4stopEv+0x16>
      socket_close(d_->sock);
 80a43f6:	6963      	ldr	r3, [r4, #20]
 80a43f8:	6818      	ldr	r0, [r3, #0]
 80a43fa:	f7fe f927 	bl	80a264c <socket_close>
 80a43fe:	6965      	ldr	r5, [r4, #20]
  d_->sock = socket_handle_invalid();
 80a4400:	f7fe f92c 	bl	80a265c <socket_handle_invalid>
 80a4404:	6028      	str	r0, [r5, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a4406:	6960      	ldr	r0, [r4, #20]
 80a4408:	2211      	movs	r2, #17
 80a440a:	2100      	movs	r1, #0
 80a440c:	308c      	adds	r0, #140	; 0x8c
 80a440e:	f000 fda7 	bl	80a4f60 <memset>
  d_->remoteIP.clear();
  flush_buffer();
 80a4412:	4620      	mov	r0, r4
}
 80a4414:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  if (isOpen(d_->sock))
      socket_close(d_->sock);
  d_->sock = socket_handle_invalid();
  d_->remoteIP.clear();
  flush_buffer();
 80a4418:	f7ff bfa0 	b.w	80a435c <_ZN9TCPClient12flush_bufferEv>

080a441c <_ZN9TCPClientC1Em>:

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a441c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a441e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a4422:	6083      	str	r3, [r0, #8]
        d_(std::make_shared<Data>(sock))
 80a4424:	4b17      	ldr	r3, [pc, #92]	; (80a4484 <_ZN9TCPClientC1Em+0x68>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a4426:	2600      	movs	r6, #0
 80a4428:	6046      	str	r6, [r0, #4]
 80a442a:	6003      	str	r3, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
 80a442c:	6146      	str	r6, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a442e:	6186      	str	r6, [r0, #24]

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a4430:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a4432:	20a0      	movs	r0, #160	; 0xa0
 80a4434:	460f      	mov	r7, r1
 80a4436:	f7fb fe30 	bl	80a009a <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 80a443a:	4605      	mov	r5, r0
 80a443c:	b138      	cbz	r0, 80a444e <_ZN9TCPClientC1Em+0x32>
        IPAddress remoteIP;

        explicit Data(sock_handle_t sock) :
                sock(sock),
                offset(0),
                total(0) {
 80a443e:	6007      	str	r7, [r0, #0]
 80a4440:	f8a0 6084 	strh.w	r6, [r0, #132]	; 0x84
 80a4444:	f8a0 6086 	strh.w	r6, [r0, #134]	; 0x86
 80a4448:	3088      	adds	r0, #136	; 0x88
 80a444a:	f7fe faf5 	bl	80a2a38 <_ZN9IPAddressC1Ev>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a444e:	2014      	movs	r0, #20
 80a4450:	f7fb fe23 	bl	80a009a <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 80a4454:	4603      	mov	r3, r0
 80a4456:	b128      	cbz	r0, 80a4464 <_ZN9TCPClientC1Em+0x48>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a4458:	2201      	movs	r2, #1
 80a445a:	6042      	str	r2, [r0, #4]
 80a445c:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a445e:	4a0a      	ldr	r2, [pc, #40]	; (80a4488 <_ZN9TCPClientC1Em+0x6c>)
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 80a4460:	6105      	str	r5, [r0, #16]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a4462:	6002      	str	r2, [r0, #0]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a4464:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
 80a4466:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a4468:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a446a:	b128      	cbz	r0, 80a4478 <_ZN9TCPClientC1Em+0x5c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a446c:	6843      	ldr	r3, [r0, #4]
 80a446e:	3b01      	subs	r3, #1
 80a4470:	6043      	str	r3, [r0, #4]
 80a4472:	b90b      	cbnz	r3, 80a4478 <_ZN9TCPClientC1Em+0x5c>
 80a4474:	f7ff feea 	bl	80a424c <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30>
        d_(std::make_shared<Data>(sock))
{
  flush_buffer();
 80a4478:	4620      	mov	r0, r4
 80a447a:	f7ff ff6f 	bl	80a435c <_ZN9TCPClient12flush_bufferEv>
}
 80a447e:	4620      	mov	r0, r4
 80a4480:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a4482:	bf00      	nop
 80a4484:	080a5ab0 	.word	0x080a5ab0
 80a4488:	080a5a94 	.word	0x080a5a94

080a448c <_ZN9TCPClientC1Ev>:
static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
}

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
 80a448c:	b510      	push	{r4, lr}
 80a448e:	4604      	mov	r4, r0
 80a4490:	f7fe f8e4 	bl	80a265c <socket_handle_invalid>
 80a4494:	4601      	mov	r1, r0
 80a4496:	4620      	mov	r0, r4
 80a4498:	f7ff ffc0 	bl	80a441c <_ZN9TCPClientC1Em>
{
}
 80a449c:	4620      	mov	r0, r4
 80a449e:	bd10      	pop	{r4, pc}

080a44a0 <_ZN9TCPClient7connectE9IPAddresstm>:
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a44a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a44a4:	4698      	mov	r8, r3
    stop();
 80a44a6:	6803      	ldr	r3, [r0, #0]
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a44a8:	b08a      	sub	sp, #40	; 0x28
    stop();
 80a44aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a44ac:	4606      	mov	r6, r0
 80a44ae:	460c      	mov	r4, r1
 80a44b0:	4615      	mov	r5, r2
    stop();
 80a44b2:	4798      	blx	r3
 80a44b4:	4b2f      	ldr	r3, [pc, #188]	; (80a4574 <_ZN9TCPClient7connectE9IPAddresstm+0xd4>)
 80a44b6:	6818      	ldr	r0, [r3, #0]
        int connected = 0;
        if(Network.from(nif).ready())
 80a44b8:	6803      	ldr	r3, [r0, #0]
 80a44ba:	681b      	ldr	r3, [r3, #0]
 80a44bc:	4798      	blx	r3
 80a44be:	2800      	cmp	r0, #0
 80a44c0:	d055      	beq.n	80a456e <_ZN9TCPClient7connectE9IPAddresstm+0xce>
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a44c2:	462b      	mov	r3, r5
 80a44c4:	2206      	movs	r2, #6
 80a44c6:	2101      	movs	r1, #1
 80a44c8:	f8cd 8000 	str.w	r8, [sp]
 80a44cc:	2002      	movs	r0, #2
 80a44ce:	6977      	ldr	r7, [r6, #20]
 80a44d0:	f7fe f8a4 	bl	80a261c <socket_create>
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a44d4:	2320      	movs	r3, #32
    stop();
        int connected = 0;
        if(Network.from(nif).ready())
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a44d6:	6038      	str	r0, [r7, #0]
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a44d8:	9302      	str	r3, [sp, #8]
 80a44da:	2700      	movs	r7, #0
 80a44dc:	6973      	ldr	r3, [r6, #20]
 80a44de:	9703      	str	r7, [sp, #12]
 80a44e0:	681b      	ldr	r3, [r3, #0]
 80a44e2:	2001      	movs	r0, #1
 80a44e4:	9301      	str	r3, [sp, #4]
 80a44e6:	4b24      	ldr	r3, [pc, #144]	; (80a4578 <_ZN9TCPClient7connectE9IPAddresstm+0xd8>)
 80a44e8:	aa02      	add	r2, sp, #8
 80a44ea:	9300      	str	r3, [sp, #0]
 80a44ec:	4923      	ldr	r1, [pc, #140]	; (80a457c <_ZN9TCPClient7connectE9IPAddresstm+0xdc>)
 80a44ee:	463b      	mov	r3, r7
 80a44f0:	f7fe f97c 	bl	80a27ec <log_message>

          if (socket_handle_valid(d_->sock))
 80a44f4:	6973      	ldr	r3, [r6, #20]
 80a44f6:	6818      	ldr	r0, [r3, #0]
 80a44f8:	f7fe f888 	bl	80a260c <socket_handle_valid>
 80a44fc:	2800      	cmp	r0, #0
 80a44fe:	d036      	beq.n	80a456e <_ZN9TCPClient7connectE9IPAddresstm+0xce>
          {
            flush_buffer();
 80a4500:	4630      	mov	r0, r6
 80a4502:	f7ff ff2b 	bl	80a435c <_ZN9TCPClient12flush_bufferEv>

            tSocketAddr.sa_family = AF_INET;
 80a4506:	2302      	movs	r3, #2
 80a4508:	f8ad 3008 	strh.w	r3, [sp, #8]

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a450c:	0a2b      	lsrs	r3, r5, #8
 80a450e:	f88d 300a 	strb.w	r3, [sp, #10]
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a4512:	79e3      	ldrb	r3, [r4, #7]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a4514:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a4518:	f88d 300c 	strb.w	r3, [sp, #12]
            tSocketAddr.sa_data[3] = ip[1];
 80a451c:	79a3      	ldrb	r3, [r4, #6]
            flush_buffer();

            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);
 80a451e:	f88d 500b 	strb.w	r5, [sp, #11]

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
            tSocketAddr.sa_data[3] = ip[1];
 80a4522:	f88d 300d 	strb.w	r3, [sp, #13]
            tSocketAddr.sa_data[4] = ip[2];
 80a4526:	7963      	ldrb	r3, [r4, #5]
 80a4528:	f88d 300e 	strb.w	r3, [sp, #14]
            tSocketAddr.sa_data[5] = ip[3];
 80a452c:	f814 3f04 	ldrb.w	r3, [r4, #4]!
 80a4530:	f88d 300f 	strb.w	r3, [sp, #15]


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a4534:	f7fe f942 	bl	80a27bc <HAL_NET_SetNetWatchDog>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a4538:	6973      	ldr	r3, [r6, #20]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a453a:	4605      	mov	r5, r0
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a453c:	2210      	movs	r2, #16
 80a453e:	a902      	add	r1, sp, #8
 80a4540:	6818      	ldr	r0, [r3, #0]
 80a4542:	f7fe f873 	bl	80a262c <socket_connect>
 80a4546:	4680      	mov	r8, r0
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
 80a4548:	4628      	mov	r0, r5
 80a454a:	f7fe f937 	bl	80a27bc <HAL_NET_SetNetWatchDog>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a454e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a4550:	6975      	ldr	r5, [r6, #20]
 80a4552:	358c      	adds	r5, #140	; 0x8c
 80a4554:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a4556:	6823      	ldr	r3, [r4, #0]
 80a4558:	702b      	strb	r3, [r5, #0]
            d_->remoteIP = ip;
            if(!connected)
 80a455a:	f1b8 0f00 	cmp.w	r8, #0
 80a455e:	d005      	beq.n	80a456c <_ZN9TCPClient7connectE9IPAddresstm+0xcc>
            {
                stop();
 80a4560:	6833      	ldr	r3, [r6, #0]
 80a4562:	4630      	mov	r0, r6
 80a4564:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a4566:	4798      	blx	r3
 80a4568:	4638      	mov	r0, r7
 80a456a:	e000      	b.n	80a456e <_ZN9TCPClient7connectE9IPAddresstm+0xce>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
            d_->remoteIP = ip;
            if(!connected)
 80a456c:	2001      	movs	r0, #1
                stop();
            }
          }
        }
        return connected;
}
 80a456e:	b00a      	add	sp, #40	; 0x28
 80a4570:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a4574:	080a5ba4 	.word	0x080a5ba4
 80a4578:	080a5afb 	.word	0x080a5afb
 80a457c:	080a5af4 	.word	0x080a5af4

080a4580 <_ZN9TCPClient6statusEv>:
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a4580:	b510      	push	{r4, lr}
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a4582:	6943      	ldr	r3, [r0, #20]
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a4584:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a4586:	6818      	ldr	r0, [r3, #0]
 80a4588:	f7fe f840 	bl	80a260c <socket_handle_valid>
  return rv;
}

uint8_t TCPClient::status()
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a458c:	b908      	cbnz	r0, 80a4592 <_ZN9TCPClient6statusEv+0x12>
 80a458e:	2000      	movs	r0, #0
 80a4590:	bd10      	pop	{r4, pc}
 80a4592:	4b07      	ldr	r3, [pc, #28]	; (80a45b0 <_ZN9TCPClient6statusEv+0x30>)
 80a4594:	6818      	ldr	r0, [r3, #0]
 80a4596:	6803      	ldr	r3, [r0, #0]
 80a4598:	681b      	ldr	r3, [r3, #0]
 80a459a:	4798      	blx	r3
 80a459c:	2800      	cmp	r0, #0
 80a459e:	d0f6      	beq.n	80a458e <_ZN9TCPClient6statusEv+0xe>
 80a45a0:	6963      	ldr	r3, [r4, #20]
 80a45a2:	6818      	ldr	r0, [r3, #0]
 80a45a4:	f7fe f82a 	bl	80a25fc <socket_active_status>
 80a45a8:	fab0 f080 	clz	r0, r0
 80a45ac:	0940      	lsrs	r0, r0, #5
}
 80a45ae:	bd10      	pop	{r4, pc}
 80a45b0:	080a5ba4 	.word	0x080a5ba4

080a45b4 <_ZN9TCPClient5writeEPKhjm>:
{
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
 80a45b4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 80a45b8:	2500      	movs	r5, #0
 80a45ba:	6045      	str	r5, [r0, #4]
 80a45bc:	4604      	mov	r4, r0
 80a45be:	460e      	mov	r6, r1
 80a45c0:	4617      	mov	r7, r2
 80a45c2:	4698      	mov	r8, r3
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a45c4:	f7ff ffdc 	bl	80a4580 <_ZN9TCPClient6statusEv>
 80a45c8:	b160      	cbz	r0, 80a45e4 <_ZN9TCPClient5writeEPKhjm+0x30>
 80a45ca:	6960      	ldr	r0, [r4, #20]
 80a45cc:	9501      	str	r5, [sp, #4]
 80a45ce:	f8cd 8000 	str.w	r8, [sp]
 80a45d2:	462b      	mov	r3, r5
 80a45d4:	463a      	mov	r2, r7
 80a45d6:	4631      	mov	r1, r6
 80a45d8:	6800      	ldr	r0, [r0, #0]
 80a45da:	f7fe f847 	bl	80a266c <socket_send_ex>
    if (ret < 0) {
 80a45de:	2800      	cmp	r0, #0
 80a45e0:	da03      	bge.n	80a45ea <_ZN9TCPClient5writeEPKhjm+0x36>
 80a45e2:	e001      	b.n	80a45e8 <_ZN9TCPClient5writeEPKhjm+0x34>
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a45e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a45e8:	6060      	str	r0, [r4, #4]

    /*
     * FIXME: We should not be returning negative numbers here
     */
    return ret;
}
 80a45ea:	b002      	add	sp, #8
 80a45ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a45f0 <_ZN9TCPClient9connectedEv>:
  d_->remoteIP.clear();
  flush_buffer();
}

uint8_t TCPClient::connected()
{
 80a45f0:	b538      	push	{r3, r4, r5, lr}
 80a45f2:	4604      	mov	r4, r0
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a45f4:	f7ff ffc4 	bl	80a4580 <_ZN9TCPClient6statusEv>
 80a45f8:	bb00      	cbnz	r0, 80a463c <_ZN9TCPClient9connectedEv+0x4c>
 80a45fa:	6963      	ldr	r3, [r4, #20]
 80a45fc:	f8b3 1086 	ldrh.w	r1, [r3, #134]	; 0x86
 80a4600:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
 80a4604:	4291      	cmp	r1, r2
 80a4606:	d119      	bne.n	80a463c <_ZN9TCPClient9connectedEv+0x4c>

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a4608:	6818      	ldr	r0, [r3, #0]
 80a460a:	f7fd ffff 	bl	80a260c <socket_handle_valid>
uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
 80a460e:	b128      	cbz	r0, 80a461c <_ZN9TCPClient9connectedEv+0x2c>
 80a4610:	6963      	ldr	r3, [r4, #20]
 80a4612:	6818      	ldr	r0, [r3, #0]
 80a4614:	f7fd fff2 	bl	80a25fc <socket_active_status>
 80a4618:	2801      	cmp	r0, #1
 80a461a:	d001      	beq.n	80a4620 <_ZN9TCPClient9connectedEv+0x30>
}

uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a461c:	2500      	movs	r5, #0
 80a461e:	e00e      	b.n	80a463e <_ZN9TCPClient9connectedEv+0x4e>
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
    {
      rv = available(); // Try CC3000
 80a4620:	6823      	ldr	r3, [r4, #0]
 80a4622:	4620      	mov	r0, r4
 80a4624:	691b      	ldr	r3, [r3, #16]
 80a4626:	4798      	blx	r3
 80a4628:	2800      	cmp	r0, #0
 80a462a:	bf14      	ite	ne
 80a462c:	2501      	movne	r5, #1
 80a462e:	2500      	moveq	r5, #0
      if (!rv) {        // No more Data and CLOSE_WAIT
 80a4630:	d105      	bne.n	80a463e <_ZN9TCPClient9connectedEv+0x4e>
          DEBUG("caling Stop No more Data and in CLOSE_WAIT");
          stop();       // Close our side
 80a4632:	6823      	ldr	r3, [r4, #0]
 80a4634:	4620      	mov	r0, r4
 80a4636:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a4638:	4798      	blx	r3
 80a463a:	e000      	b.n	80a463e <_ZN9TCPClient9connectedEv+0x4e>
 80a463c:	2501      	movs	r5, #1
      }
  }
  return rv;
}
 80a463e:	4628      	mov	r0, r5
 80a4640:	bd38      	pop	{r3, r4, r5, pc}

080a4642 <_ZN9TCPClientcvbEv>:
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
}

TCPClient::operator bool()
{
 80a4642:	b508      	push	{r3, lr}
   return (status()!=0);
 80a4644:	f7ff ff9c 	bl	80a4580 <_ZN9TCPClient6statusEv>
}
 80a4648:	3000      	adds	r0, #0
 80a464a:	bf18      	it	ne
 80a464c:	2001      	movne	r0, #1
 80a464e:	bd08      	pop	{r3, pc}

080a4650 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a4650:	4b02      	ldr	r3, [pc, #8]	; (80a465c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a4652:	681a      	ldr	r2, [r3, #0]
 80a4654:	4b02      	ldr	r3, [pc, #8]	; (80a4660 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a4656:	601a      	str	r2, [r3, #0]
 80a4658:	4770      	bx	lr
 80a465a:	bf00      	nop
 80a465c:	20000330 	.word	0x20000330
 80a4660:	200004bc 	.word	0x200004bc

080a4664 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a4664:	4770      	bx	lr

080a4666 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a4666:	7441      	strb	r1, [r0, #17]
 80a4668:	4770      	bx	lr

080a466a <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a466a:	7c00      	ldrb	r0, [r0, #16]
 80a466c:	f7fe b856 	b.w	80a271c <HAL_USART_Available_Data_For_Write>

080a4670 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a4670:	7c00      	ldrb	r0, [r0, #16]
 80a4672:	f7fe b82b 	b.w	80a26cc <HAL_USART_Available_Data>

080a4676 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a4676:	7c00      	ldrb	r0, [r0, #16]
 80a4678:	f7fe b838 	b.w	80a26ec <HAL_USART_Peek_Data>

080a467c <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a467c:	7c00      	ldrb	r0, [r0, #16]
 80a467e:	f7fe b82d 	b.w	80a26dc <HAL_USART_Read_Data>

080a4682 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a4682:	7c00      	ldrb	r0, [r0, #16]
 80a4684:	f7fe b83a 	b.w	80a26fc <HAL_USART_Flush_Data>

080a4688 <_ZN11USARTSerialD0Ev>:
 80a4688:	b510      	push	{r4, lr}
 80a468a:	4604      	mov	r4, r0
 80a468c:	f7fb fd07 	bl	80a009e <_ZdlPv>
 80a4690:	4620      	mov	r0, r4
 80a4692:	bd10      	pop	{r4, pc}

080a4694 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a4694:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a4696:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a4698:	4604      	mov	r4, r0
 80a469a:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a469c:	b925      	cbnz	r5, 80a46a8 <_ZN11USARTSerial5writeEh+0x14>
 80a469e:	7c00      	ldrb	r0, [r0, #16]
 80a46a0:	f7fe f83c 	bl	80a271c <HAL_USART_Available_Data_For_Write>
 80a46a4:	2800      	cmp	r0, #0
 80a46a6:	dd05      	ble.n	80a46b4 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46a8:	4631      	mov	r1, r6
 80a46aa:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a46ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46b0:	f7fe b804 	b.w	80a26bc <HAL_USART_Write_Data>
  }
  return 0;
}
 80a46b4:	4628      	mov	r0, r5
 80a46b6:	bd70      	pop	{r4, r5, r6, pc}

080a46b8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a46b8:	b510      	push	{r4, lr}
 80a46ba:	4604      	mov	r4, r0
 80a46bc:	4608      	mov	r0, r1
 80a46be:	4611      	mov	r1, r2
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a46c0:	2200      	movs	r2, #0
 80a46c2:	6062      	str	r2, [r4, #4]
 80a46c4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a46c8:	60a2      	str	r2, [r4, #8]
 80a46ca:	4a05      	ldr	r2, [pc, #20]	; (80a46e0 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a46cc:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a46ce:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a46d0:	2201      	movs	r2, #1
 80a46d2:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a46d4:	461a      	mov	r2, r3
 80a46d6:	f7fd ffe1 	bl	80a269c <HAL_USART_Init>
}
 80a46da:	4620      	mov	r0, r4
 80a46dc:	bd10      	pop	{r4, pc}
 80a46de:	bf00      	nop
 80a46e0:	080a5b40 	.word	0x080a5b40

080a46e4 <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a46e4:	2300      	movs	r3, #0
 80a46e6:	7c00      	ldrb	r0, [r0, #16]
 80a46e8:	f7fe b820 	b.w	80a272c <HAL_USART_BeginConfig>

080a46ec <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a46ec:	2200      	movs	r2, #0
 80a46ee:	f7ff bff9 	b.w	80a46e4 <_ZN11USARTSerial5beginEmm>

080a46f2 <_ZN11USARTSerial3endEv>:
  HAL_USART_BeginConfig(_serial, baud, config, 0);
}

void USARTSerial::end()
{
  HAL_USART_End(_serial);
 80a46f2:	7c00      	ldrb	r0, [r0, #16]
 80a46f4:	f7fd bfda 	b.w	80a26ac <HAL_USART_End>

080a46f8 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a46f8:	7c00      	ldrb	r0, [r0, #16]
 80a46fa:	f7fe b807 	b.w	80a270c <HAL_USART_Is_Enabled>
	...

080a4700 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a4700:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a4702:	4d0c      	ldr	r5, [pc, #48]	; (80a4734 <_Z22__fetch_global_Serial1v+0x34>)
 80a4704:	6829      	ldr	r1, [r5, #0]
 80a4706:	f011 0401 	ands.w	r4, r1, #1
 80a470a:	d111      	bne.n	80a4730 <_Z22__fetch_global_Serial1v+0x30>
 80a470c:	4628      	mov	r0, r5
 80a470e:	f7fb fcd3 	bl	80a00b8 <__cxa_guard_acquire>
 80a4712:	b168      	cbz	r0, 80a4730 <_Z22__fetch_global_Serial1v+0x30>
 80a4714:	4a08      	ldr	r2, [pc, #32]	; (80a4738 <_Z22__fetch_global_Serial1v+0x38>)
 80a4716:	4621      	mov	r1, r4
 80a4718:	4b08      	ldr	r3, [pc, #32]	; (80a473c <_Z22__fetch_global_Serial1v+0x3c>)
 80a471a:	4809      	ldr	r0, [pc, #36]	; (80a4740 <_Z22__fetch_global_Serial1v+0x40>)
 80a471c:	f7ff ffcc 	bl	80a46b8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a4720:	4628      	mov	r0, r5
 80a4722:	f7fb fcce 	bl	80a00c2 <__cxa_guard_release>
 80a4726:	4a07      	ldr	r2, [pc, #28]	; (80a4744 <_Z22__fetch_global_Serial1v+0x44>)
 80a4728:	4907      	ldr	r1, [pc, #28]	; (80a4748 <_Z22__fetch_global_Serial1v+0x48>)
 80a472a:	4805      	ldr	r0, [pc, #20]	; (80a4740 <_Z22__fetch_global_Serial1v+0x40>)
 80a472c:	f000 fa76 	bl	80a4c1c <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a4730:	4803      	ldr	r0, [pc, #12]	; (80a4740 <_Z22__fetch_global_Serial1v+0x40>)
 80a4732:	bd38      	pop	{r3, r4, r5, pc}
 80a4734:	20000558 	.word	0x20000558
 80a4738:	2000055c 	.word	0x2000055c
 80a473c:	200004d4 	.word	0x200004d4
 80a4740:	200004c0 	.word	0x200004c0
 80a4744:	2000039c 	.word	0x2000039c
 80a4748:	080a4665 	.word	0x080a4665

080a474c <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a474c:	7441      	strb	r1, [r0, #17]
 80a474e:	4770      	bx	lr

080a4750 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a4750:	4770      	bx	lr

080a4752 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a4752:	2100      	movs	r1, #0
 80a4754:	7c00      	ldrb	r0, [r0, #16]
 80a4756:	f7fe b819 	b.w	80a278c <HAL_USB_USART_Receive_Data>

080a475a <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a475a:	2101      	movs	r1, #1
 80a475c:	7c00      	ldrb	r0, [r0, #16]
 80a475e:	f7fe b815 	b.w	80a278c <HAL_USB_USART_Receive_Data>

080a4762 <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a4762:	7c00      	ldrb	r0, [r0, #16]
 80a4764:	f7fe b80a 	b.w	80a277c <HAL_USB_USART_Available_Data_For_Write>

080a4768 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a4768:	7c00      	ldrb	r0, [r0, #16]
 80a476a:	f7fd bfff 	b.w	80a276c <HAL_USB_USART_Available_Data>

080a476e <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a476e:	b538      	push	{r3, r4, r5, lr}
 80a4770:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a4772:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a4774:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a4776:	f7fe f801 	bl	80a277c <HAL_USB_USART_Available_Data_For_Write>
 80a477a:	2800      	cmp	r0, #0
 80a477c:	dc01      	bgt.n	80a4782 <_ZN9USBSerial5writeEh+0x14>
 80a477e:	7c60      	ldrb	r0, [r4, #17]
 80a4780:	b120      	cbz	r0, 80a478c <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a4782:	4629      	mov	r1, r5
 80a4784:	7c20      	ldrb	r0, [r4, #16]
 80a4786:	f7fe f809 	bl	80a279c <HAL_USB_USART_Send_Data>
    return 1;
 80a478a:	2001      	movs	r0, #1
  }
  return 0;
}
 80a478c:	bd38      	pop	{r3, r4, r5, pc}

080a478e <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a478e:	7c00      	ldrb	r0, [r0, #16]
 80a4790:	f7fe b80c 	b.w	80a27ac <HAL_USB_USART_Flush_Data>

080a4794 <_ZN9USBSerialD0Ev>:
 80a4794:	b510      	push	{r4, lr}
 80a4796:	4604      	mov	r4, r0
 80a4798:	f7fb fc81 	bl	80a009e <_ZdlPv>
 80a479c:	4620      	mov	r0, r4
 80a479e:	bd10      	pop	{r4, pc}

080a47a0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a47a0:	b510      	push	{r4, lr}
 80a47a2:	4604      	mov	r4, r0
 80a47a4:	2300      	movs	r3, #0
 80a47a6:	6063      	str	r3, [r4, #4]
 80a47a8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a47ac:	60a3      	str	r3, [r4, #8]
 80a47ae:	4b05      	ldr	r3, [pc, #20]	; (80a47c4 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a47b0:	4608      	mov	r0, r1
 80a47b2:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a47b4:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a47b6:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a47b8:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a47ba:	4611      	mov	r1, r2
 80a47bc:	f7fd ffbe 	bl	80a273c <HAL_USB_USART_Init>
}
 80a47c0:	4620      	mov	r0, r4
 80a47c2:	bd10      	pop	{r4, pc}
 80a47c4:	080a5b70 	.word	0x080a5b70

080a47c8 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a47c8:	2200      	movs	r2, #0
 80a47ca:	7c00      	ldrb	r0, [r0, #16]
 80a47cc:	f7fd bfbe 	b.w	80a274c <HAL_USB_USART_Begin>

080a47d0 <_ZN9USBSerial3endEv>:
}

void USBSerial::end()
{
    HAL_USB_USART_End(_serial);
 80a47d0:	7c00      	ldrb	r0, [r0, #16]
 80a47d2:	f7fd bfc3 	b.w	80a275c <HAL_USB_USART_End>
	...

080a47d8 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a47d8:	b510      	push	{r4, lr}
 80a47da:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a47dc:	2214      	movs	r2, #20
 80a47de:	2100      	movs	r1, #0
 80a47e0:	f000 fbbe 	bl	80a4f60 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a47e4:	4b05      	ldr	r3, [pc, #20]	; (80a47fc <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a47e6:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a47e8:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a47ea:	4b05      	ldr	r3, [pc, #20]	; (80a4800 <_Z19acquireSerialBufferv+0x28>)
 80a47ec:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a47ee:	f240 1301 	movw	r3, #257	; 0x101
 80a47f2:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a47f4:	2381      	movs	r3, #129	; 0x81
 80a47f6:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a47f8:	bd10      	pop	{r4, pc}
 80a47fa:	bf00      	nop
 80a47fc:	20000665 	.word	0x20000665
 80a4800:	200005e4 	.word	0x200005e4

080a4804 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a4804:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a4806:	4d0e      	ldr	r5, [pc, #56]	; (80a4840 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a4808:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a480a:	a801      	add	r0, sp, #4
 80a480c:	f7ff ffe4 	bl	80a47d8 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a4810:	6829      	ldr	r1, [r5, #0]
 80a4812:	f011 0401 	ands.w	r4, r1, #1
 80a4816:	d110      	bne.n	80a483a <_Z16_fetch_usbserialv+0x36>
 80a4818:	4628      	mov	r0, r5
 80a481a:	f7fb fc4d 	bl	80a00b8 <__cxa_guard_acquire>
 80a481e:	b160      	cbz	r0, 80a483a <_Z16_fetch_usbserialv+0x36>
 80a4820:	aa01      	add	r2, sp, #4
 80a4822:	4621      	mov	r1, r4
 80a4824:	4807      	ldr	r0, [pc, #28]	; (80a4844 <_Z16_fetch_usbserialv+0x40>)
 80a4826:	f7ff ffbb 	bl	80a47a0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a482a:	4628      	mov	r0, r5
 80a482c:	f7fb fc49 	bl	80a00c2 <__cxa_guard_release>
 80a4830:	4a05      	ldr	r2, [pc, #20]	; (80a4848 <_Z16_fetch_usbserialv+0x44>)
 80a4832:	4906      	ldr	r1, [pc, #24]	; (80a484c <_Z16_fetch_usbserialv+0x48>)
 80a4834:	4803      	ldr	r0, [pc, #12]	; (80a4844 <_Z16_fetch_usbserialv+0x40>)
 80a4836:	f000 f9f1 	bl	80a4c1c <__aeabi_atexit>
	return _usbserial;
}
 80a483a:	4802      	ldr	r0, [pc, #8]	; (80a4844 <_Z16_fetch_usbserialv+0x40>)
 80a483c:	b007      	add	sp, #28
 80a483e:	bd30      	pop	{r4, r5, pc}
 80a4840:	200005e0 	.word	0x200005e0
 80a4844:	20000768 	.word	0x20000768
 80a4848:	2000039c 	.word	0x2000039c
 80a484c:	080a4751 	.word	0x080a4751

080a4850 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a4850:	b510      	push	{r4, lr}
 80a4852:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a4854:	2214      	movs	r2, #20
 80a4856:	2100      	movs	r1, #0
 80a4858:	f000 fb82 	bl	80a4f60 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a485c:	4b05      	ldr	r3, [pc, #20]	; (80a4874 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a485e:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a4860:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a4862:	4b05      	ldr	r3, [pc, #20]	; (80a4878 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a4864:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a4866:	f240 1301 	movw	r3, #257	; 0x101
 80a486a:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a486c:	2381      	movs	r3, #129	; 0x81
 80a486e:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a4870:	bd10      	pop	{r4, pc}
 80a4872:	bf00      	nop
 80a4874:	20000818 	.word	0x20000818
 80a4878:	20000780 	.word	0x20000780

080a487c <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a487c:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a487e:	4c0e      	ldr	r4, [pc, #56]	; (80a48b8 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a4880:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a4882:	a801      	add	r0, sp, #4
 80a4884:	f7ff ffe4 	bl	80a4850 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a4888:	6823      	ldr	r3, [r4, #0]
 80a488a:	07db      	lsls	r3, r3, #31
 80a488c:	d410      	bmi.n	80a48b0 <_Z17_fetch_usbserial1v+0x34>
 80a488e:	4620      	mov	r0, r4
 80a4890:	f7fb fc12 	bl	80a00b8 <__cxa_guard_acquire>
 80a4894:	b160      	cbz	r0, 80a48b0 <_Z17_fetch_usbserial1v+0x34>
 80a4896:	aa01      	add	r2, sp, #4
 80a4898:	2101      	movs	r1, #1
 80a489a:	4808      	ldr	r0, [pc, #32]	; (80a48bc <_Z17_fetch_usbserial1v+0x40>)
 80a489c:	f7ff ff80 	bl	80a47a0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a48a0:	4620      	mov	r0, r4
 80a48a2:	f7fb fc0e 	bl	80a00c2 <__cxa_guard_release>
 80a48a6:	4a06      	ldr	r2, [pc, #24]	; (80a48c0 <_Z17_fetch_usbserial1v+0x44>)
 80a48a8:	4906      	ldr	r1, [pc, #24]	; (80a48c4 <_Z17_fetch_usbserial1v+0x48>)
 80a48aa:	4804      	ldr	r0, [pc, #16]	; (80a48bc <_Z17_fetch_usbserial1v+0x40>)
 80a48ac:	f000 f9b6 	bl	80a4c1c <__aeabi_atexit>
  return _usbserial1;
}
 80a48b0:	4802      	ldr	r0, [pc, #8]	; (80a48bc <_Z17_fetch_usbserial1v+0x40>)
 80a48b2:	b006      	add	sp, #24
 80a48b4:	bd10      	pop	{r4, pc}
 80a48b6:	bf00      	nop
 80a48b8:	2000077c 	.word	0x2000077c
 80a48bc:	20000804 	.word	0x20000804
 80a48c0:	2000039c 	.word	0x2000039c
 80a48c4:	080a4751 	.word	0x080a4751

080a48c8 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a48c8:	4770      	bx	lr

080a48ca <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a48ca:	2200      	movs	r2, #0
 80a48cc:	4611      	mov	r1, r2
 80a48ce:	4610      	mov	r0, r2
 80a48d0:	f7fd bff0 	b.w	80a28b4 <network_ready>

080a48d4 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a48d4:	4803      	ldr	r0, [pc, #12]	; (80a48e4 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a48d6:	4b04      	ldr	r3, [pc, #16]	; (80a48e8 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a48d8:	4a04      	ldr	r2, [pc, #16]	; (80a48ec <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a48da:	4905      	ldr	r1, [pc, #20]	; (80a48f0 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a48dc:	6003      	str	r3, [r0, #0]
 80a48de:	f000 b99d 	b.w	80a4c1c <__aeabi_atexit>
 80a48e2:	bf00      	nop
 80a48e4:	2000091c 	.word	0x2000091c
 80a48e8:	080a5ba0 	.word	0x080a5ba0
 80a48ec:	2000039c 	.word	0x2000039c
 80a48f0:	080a48c9 	.word	0x080a48c9

080a48f4 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a48f4:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a48f6:	4b14      	ldr	r3, [pc, #80]	; (80a4948 <serialEventRun+0x54>)
 80a48f8:	b133      	cbz	r3, 80a4908 <serialEventRun+0x14>
 80a48fa:	f7ff ff83 	bl	80a4804 <_Z16_fetch_usbserialv>
 80a48fe:	6803      	ldr	r3, [r0, #0]
 80a4900:	691b      	ldr	r3, [r3, #16]
 80a4902:	4798      	blx	r3
 80a4904:	2800      	cmp	r0, #0
 80a4906:	dc16      	bgt.n	80a4936 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a4908:	4b10      	ldr	r3, [pc, #64]	; (80a494c <serialEventRun+0x58>)
 80a490a:	b133      	cbz	r3, 80a491a <serialEventRun+0x26>
 80a490c:	f7ff fef8 	bl	80a4700 <_Z22__fetch_global_Serial1v>
 80a4910:	6803      	ldr	r3, [r0, #0]
 80a4912:	691b      	ldr	r3, [r3, #16]
 80a4914:	4798      	blx	r3
 80a4916:	2800      	cmp	r0, #0
 80a4918:	dc10      	bgt.n	80a493c <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a491a:	4b0d      	ldr	r3, [pc, #52]	; (80a4950 <serialEventRun+0x5c>)
 80a491c:	b10b      	cbz	r3, 80a4922 <serialEventRun+0x2e>
 80a491e:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a4922:	4b0c      	ldr	r3, [pc, #48]	; (80a4954 <serialEventRun+0x60>)
 80a4924:	b17b      	cbz	r3, 80a4946 <serialEventRun+0x52>
 80a4926:	f7ff ffa9 	bl	80a487c <_Z17_fetch_usbserial1v>
 80a492a:	6803      	ldr	r3, [r0, #0]
 80a492c:	691b      	ldr	r3, [r3, #16]
 80a492e:	4798      	blx	r3
 80a4930:	2800      	cmp	r0, #0
 80a4932:	dc06      	bgt.n	80a4942 <serialEventRun+0x4e>
 80a4934:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a4936:	f3af 8000 	nop.w
 80a493a:	e7e5      	b.n	80a4908 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a493c:	f3af 8000 	nop.w
 80a4940:	e7eb      	b.n	80a491a <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a4942:	f3af 8000 	nop.w
 80a4946:	bd08      	pop	{r3, pc}
	...

080a4958 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a4958:	b508      	push	{r3, lr}
	serialEventRun();
 80a495a:	f7ff ffcb 	bl	80a48f4 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a495e:	f7fd fdc3 	bl	80a24e8 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a4962:	4b01      	ldr	r3, [pc, #4]	; (80a4968 <_post_loop+0x10>)
 80a4964:	6018      	str	r0, [r3, #0]
 80a4966:	bd08      	pop	{r3, pc}
 80a4968:	20000928 	.word	0x20000928

080a496c <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a496c:	4802      	ldr	r0, [pc, #8]	; (80a4978 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a496e:	4a03      	ldr	r2, [pc, #12]	; (80a497c <_Z33system_initialize_user_backup_ramv+0x10>)
 80a4970:	4903      	ldr	r1, [pc, #12]	; (80a4980 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a4972:	1a12      	subs	r2, r2, r0
 80a4974:	f000 bace 	b.w	80a4f14 <memcpy>
 80a4978:	40024000 	.word	0x40024000
 80a497c:	40024004 	.word	0x40024004
 80a4980:	080a5d50 	.word	0x080a5d50

080a4984 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a4984:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a4986:	2300      	movs	r3, #0
 80a4988:	9300      	str	r3, [sp, #0]
 80a498a:	461a      	mov	r2, r3
 80a498c:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a4990:	f7fd ff66 	bl	80a2860 <system_ctrl_set_result>
}
 80a4994:	b003      	add	sp, #12
 80a4996:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a499c <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a499c:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a499e:	8843      	ldrh	r3, [r0, #2]
 80a49a0:	2b0a      	cmp	r3, #10
 80a49a2:	d008      	beq.n	80a49b6 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a49a4:	2b50      	cmp	r3, #80	; 0x50
 80a49a6:	d109      	bne.n	80a49bc <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a49a8:	4b09      	ldr	r3, [pc, #36]	; (80a49d0 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a49aa:	681b      	ldr	r3, [r3, #0]
 80a49ac:	b13b      	cbz	r3, 80a49be <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a49ae:	b003      	add	sp, #12
 80a49b0:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a49b4:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a49b6:	f7ff ffe5 	bl	80a4984 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a49ba:	e006      	b.n	80a49ca <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a49bc:	2300      	movs	r3, #0
 80a49be:	9300      	str	r3, [sp, #0]
 80a49c0:	461a      	mov	r2, r3
 80a49c2:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a49c6:	f7fd ff4b 	bl	80a2860 <system_ctrl_set_result>
        break;
    }
}
 80a49ca:	b003      	add	sp, #12
 80a49cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80a49d0:	20000920 	.word	0x20000920

080a49d4 <module_user_init_hook>:

void module_user_init_hook()
{
 80a49d4:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a49d6:	4c10      	ldr	r4, [pc, #64]	; (80a4a18 <module_user_init_hook+0x44>)
 80a49d8:	4d10      	ldr	r5, [pc, #64]	; (80a4a1c <module_user_init_hook+0x48>)
 80a49da:	6823      	ldr	r3, [r4, #0]
 80a49dc:	42ab      	cmp	r3, r5
 80a49de:	4b10      	ldr	r3, [pc, #64]	; (80a4a20 <module_user_init_hook+0x4c>)
 80a49e0:	bf0c      	ite	eq
 80a49e2:	2201      	moveq	r2, #1
 80a49e4:	2200      	movne	r2, #0
 80a49e6:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a49e8:	d002      	beq.n	80a49f0 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a49ea:	f7ff ffbf 	bl	80a496c <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a49ee:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a49f0:	f7fd fd62 	bl	80a24b8 <HAL_RNG_GetRandomNumber>
 80a49f4:	f000 fabc 	bl	80a4f70 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a49f8:	4b0a      	ldr	r3, [pc, #40]	; (80a4a24 <module_user_init_hook+0x50>)
 80a49fa:	b11b      	cbz	r3, 80a4a04 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a49fc:	f7fd fd5c 	bl	80a24b8 <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a4a00:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a4a04:	2100      	movs	r1, #0
 80a4a06:	4807      	ldr	r0, [pc, #28]	; (80a4a24 <module_user_init_hook+0x50>)
 80a4a08:	f7fd ff4c 	bl	80a28a4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a4a0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a4a10:	2100      	movs	r1, #0
 80a4a12:	4805      	ldr	r0, [pc, #20]	; (80a4a28 <module_user_init_hook+0x54>)
 80a4a14:	f7fd bf1a 	b.w	80a284c <system_ctrl_set_app_request_handler>
 80a4a18:	40024000 	.word	0x40024000
 80a4a1c:	9a271c1e 	.word	0x9a271c1e
 80a4a20:	20000924 	.word	0x20000924
 80a4a24:	00000000 	.word	0x00000000
 80a4a28:	080a499d 	.word	0x080a499d

080a4a2c <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a4a2c:	b510      	push	{r4, lr}
 80a4a2e:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a4a30:	480f      	ldr	r0, [pc, #60]	; (80a4a70 <pinAvailable+0x44>)
 80a4a32:	f7ff fad5 	bl	80a3fe0 <_ZN8SPIClass9isEnabledEv>
 80a4a36:	b128      	cbz	r0, 80a4a44 <pinAvailable+0x18>
 80a4a38:	f1a4 030d 	sub.w	r3, r4, #13
 80a4a3c:	2b02      	cmp	r3, #2
 80a4a3e:	d801      	bhi.n	80a4a44 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a4a40:	2000      	movs	r0, #0
 80a4a42:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a4a44:	f000 f890 	bl	80a4b68 <_Z19__fetch_global_Wirev>
 80a4a48:	f7fd ffd2 	bl	80a29f0 <_ZN7TwoWire9isEnabledEv>
 80a4a4c:	b108      	cbz	r0, 80a4a52 <pinAvailable+0x26>
 80a4a4e:	2c01      	cmp	r4, #1
 80a4a50:	d9f6      	bls.n	80a4a40 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a4a52:	f7ff fe55 	bl	80a4700 <_Z22__fetch_global_Serial1v>
 80a4a56:	f7ff fe4f 	bl	80a46f8 <_ZN11USARTSerial9isEnabledEv>
 80a4a5a:	b118      	cbz	r0, 80a4a64 <pinAvailable+0x38>
 80a4a5c:	f1a4 0312 	sub.w	r3, r4, #18
 80a4a60:	2b01      	cmp	r3, #1
 80a4a62:	d9ed      	bls.n	80a4a40 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a4a64:	2c17      	cmp	r4, #23
 80a4a66:	bf8c      	ite	hi
 80a4a68:	2000      	movhi	r0, #0
 80a4a6a:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a4a6c:	bd10      	pop	{r4, pc}
 80a4a6e:	bf00      	nop
 80a4a70:	2000095c 	.word	0x2000095c

080a4a74 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a4a74:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a4a76:	b538      	push	{r3, r4, r5, lr}
 80a4a78:	4604      	mov	r4, r0
 80a4a7a:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a4a7c:	d80a      	bhi.n	80a4a94 <pinMode+0x20>
 80a4a7e:	29ff      	cmp	r1, #255	; 0xff
 80a4a80:	d008      	beq.n	80a4a94 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a4a82:	f7ff ffd3 	bl	80a4a2c <pinAvailable>
 80a4a86:	b128      	cbz	r0, 80a4a94 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a4a88:	4629      	mov	r1, r5
 80a4a8a:	4620      	mov	r0, r4
}
 80a4a8c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a4a90:	f7fd bd42 	b.w	80a2518 <HAL_Pin_Mode>
 80a4a94:	bd38      	pop	{r3, r4, r5, pc}

080a4a96 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a4a96:	b538      	push	{r3, r4, r5, lr}
 80a4a98:	4604      	mov	r4, r0
 80a4a9a:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a4a9c:	f7fd fd44 	bl	80a2528 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a4aa0:	28ff      	cmp	r0, #255	; 0xff
 80a4aa2:	d010      	beq.n	80a4ac6 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a4aa4:	2806      	cmp	r0, #6
 80a4aa6:	d804      	bhi.n	80a4ab2 <digitalWrite+0x1c>
 80a4aa8:	234d      	movs	r3, #77	; 0x4d
 80a4aaa:	fa23 f000 	lsr.w	r0, r3, r0
 80a4aae:	07c3      	lsls	r3, r0, #31
 80a4ab0:	d409      	bmi.n	80a4ac6 <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a4ab2:	4620      	mov	r0, r4
 80a4ab4:	f7ff ffba 	bl	80a4a2c <pinAvailable>
 80a4ab8:	b128      	cbz	r0, 80a4ac6 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a4aba:	4629      	mov	r1, r5
 80a4abc:	4620      	mov	r0, r4
}
 80a4abe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a4ac2:	f7fd bd39 	b.w	80a2538 <HAL_GPIO_Write>
 80a4ac6:	bd38      	pop	{r3, r4, r5, pc}

080a4ac8 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a4ac8:	b510      	push	{r4, lr}
 80a4aca:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a4acc:	f7fd fd2c 	bl	80a2528 <HAL_Get_Pin_Mode>
    if (is_af_output_mode(mode))
 80a4ad0:	3804      	subs	r0, #4
 80a4ad2:	b2c0      	uxtb	r0, r0
 80a4ad4:	2801      	cmp	r0, #1
 80a4ad6:	d908      	bls.n	80a4aea <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a4ad8:	4620      	mov	r0, r4
 80a4ada:	f7ff ffa7 	bl	80a4a2c <pinAvailable>
 80a4ade:	b120      	cbz	r0, 80a4aea <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a4ae0:	4620      	mov	r0, r4
}
 80a4ae2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a4ae6:	f7fd bd2f 	b.w	80a2548 <HAL_GPIO_Read>
}
 80a4aea:	2000      	movs	r0, #0
 80a4aec:	bd10      	pop	{r4, pc}

080a4aee <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a4aee:	b510      	push	{r4, lr}
 80a4af0:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a4af2:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a4af4:	bf9c      	itt	ls
 80a4af6:	340a      	addls	r4, #10
 80a4af8:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a4afa:	4620      	mov	r0, r4
 80a4afc:	f7ff ff96 	bl	80a4a2c <pinAvailable>
 80a4b00:	b150      	cbz	r0, 80a4b18 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a4b02:	2103      	movs	r1, #3
 80a4b04:	4620      	mov	r0, r4
 80a4b06:	f7fd fcff 	bl	80a2508 <HAL_Validate_Pin_Function>
 80a4b0a:	2803      	cmp	r0, #3
 80a4b0c:	d104      	bne.n	80a4b18 <analogRead+0x2a>
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a4b0e:	4620      	mov	r0, r4
}
 80a4b10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a4b14:	f7fd bd28 	b.w	80a2568 <HAL_ADC_Read>
}
 80a4b18:	2000      	movs	r0, #0
 80a4b1a:	bd10      	pop	{r4, pc}

080a4b1c <_Z11analogWritetm>:
/*
 * @brief Should take an integer 0-255 and create a 500Hz PWM signal with a duty cycle from 0-100%.
 * On Photon, DAC1 and DAC2 act as true analog outputs(values: 0 to 4095) using onchip DAC peripheral
 */
void analogWrite(pin_t pin, uint32_t value)
{
 80a4b1c:	b538      	push	{r3, r4, r5, lr}
 80a4b1e:	4604      	mov	r4, r0
 80a4b20:	460d      	mov	r5, r1
    // Safety check
    if (!pinAvailable(pin))
 80a4b22:	f7ff ff83 	bl	80a4a2c <pinAvailable>
 80a4b26:	b1f0      	cbz	r0, 80a4b66 <_Z11analogWritetm+0x4a>
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a4b28:	2104      	movs	r1, #4
 80a4b2a:	4620      	mov	r0, r4
 80a4b2c:	f7fd fcec 	bl	80a2508 <HAL_Validate_Pin_Function>
 80a4b30:	2804      	cmp	r0, #4
 80a4b32:	d105      	bne.n	80a4b40 <_Z11analogWritetm+0x24>
    {
        HAL_DAC_Write(pin, value);
 80a4b34:	b2a9      	uxth	r1, r5
 80a4b36:	4620      	mov	r0, r4
            return;
        }

        HAL_PWM_Write_Ext(pin, value);
    }
}
 80a4b38:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
    {
        HAL_DAC_Write(pin, value);
 80a4b3c:	f7fd bd0c 	b.w	80a2558 <HAL_DAC_Write>
    }
    else if (HAL_Validate_Pin_Function(pin, PF_TIMER) == PF_TIMER)
 80a4b40:	2102      	movs	r1, #2
 80a4b42:	4620      	mov	r0, r4
 80a4b44:	f7fd fce0 	bl	80a2508 <HAL_Validate_Pin_Function>
 80a4b48:	2802      	cmp	r0, #2
 80a4b4a:	d10c      	bne.n	80a4b66 <_Z11analogWritetm+0x4a>
    {
        PinMode mode = HAL_Get_Pin_Mode(pin);
 80a4b4c:	4620      	mov	r0, r4
 80a4b4e:	f7fd fceb 	bl	80a2528 <HAL_Get_Pin_Mode>

        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
 80a4b52:	2801      	cmp	r0, #1
 80a4b54:	d001      	beq.n	80a4b5a <_Z11analogWritetm+0x3e>
 80a4b56:	2804      	cmp	r0, #4
 80a4b58:	d105      	bne.n	80a4b66 <_Z11analogWritetm+0x4a>
        {
            return;
        }

        HAL_PWM_Write_Ext(pin, value);
 80a4b5a:	4629      	mov	r1, r5
 80a4b5c:	4620      	mov	r0, r4
    }
}
 80a4b5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
        {
            return;
        }

        HAL_PWM_Write_Ext(pin, value);
 80a4b62:	f7fd bd09 	b.w	80a2578 <HAL_PWM_Write_Ext>
 80a4b66:	bd38      	pop	{r3, r4, r5, pc}

080a4b68 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a4b68:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a4b6a:	4d0b      	ldr	r5, [pc, #44]	; (80a4b98 <_Z19__fetch_global_Wirev+0x30>)
 80a4b6c:	6829      	ldr	r1, [r5, #0]
 80a4b6e:	f011 0401 	ands.w	r4, r1, #1
 80a4b72:	d10f      	bne.n	80a4b94 <_Z19__fetch_global_Wirev+0x2c>
 80a4b74:	4628      	mov	r0, r5
 80a4b76:	f7fb fa9f 	bl	80a00b8 <__cxa_guard_acquire>
 80a4b7a:	b158      	cbz	r0, 80a4b94 <_Z19__fetch_global_Wirev+0x2c>
 80a4b7c:	4621      	mov	r1, r4
 80a4b7e:	4807      	ldr	r0, [pc, #28]	; (80a4b9c <_Z19__fetch_global_Wirev+0x34>)
 80a4b80:	f7fd ff24 	bl	80a29cc <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a4b84:	4628      	mov	r0, r5
 80a4b86:	f7fb fa9c 	bl	80a00c2 <__cxa_guard_release>
 80a4b8a:	4a05      	ldr	r2, [pc, #20]	; (80a4ba0 <_Z19__fetch_global_Wirev+0x38>)
 80a4b8c:	4905      	ldr	r1, [pc, #20]	; (80a4ba4 <_Z19__fetch_global_Wirev+0x3c>)
 80a4b8e:	4803      	ldr	r0, [pc, #12]	; (80a4b9c <_Z19__fetch_global_Wirev+0x34>)
 80a4b90:	f000 f844 	bl	80a4c1c <__aeabi_atexit>
	return wire;
}
 80a4b94:	4801      	ldr	r0, [pc, #4]	; (80a4b9c <_Z19__fetch_global_Wirev+0x34>)
 80a4b96:	bd38      	pop	{r3, r4, r5, pc}
 80a4b98:	2000092c 	.word	0x2000092c
 80a4b9c:	20000930 	.word	0x20000930
 80a4ba0:	2000039c 	.word	0x2000039c
 80a4ba4:	080a2977 	.word	0x080a2977

080a4ba8 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a4ba8:	b513      	push	{r0, r1, r4, lr}
 80a4baa:	4c08      	ldr	r4, [pc, #32]	; (80a4bcc <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a4bac:	2300      	movs	r3, #0
 80a4bae:	461a      	mov	r2, r3
 80a4bb0:	4619      	mov	r1, r3
 80a4bb2:	9300      	str	r3, [sp, #0]
 80a4bb4:	4620      	mov	r0, r4
 80a4bb6:	f7fd ff5b 	bl	80a2a70 <_ZN9IPAddressC1Ehhhh>
 80a4bba:	4620      	mov	r0, r4
 80a4bbc:	4a04      	ldr	r2, [pc, #16]	; (80a4bd0 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a4bbe:	4905      	ldr	r1, [pc, #20]	; (80a4bd4 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a4bc0:	b002      	add	sp, #8
 80a4bc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a4bc6:	f000 b829 	b.w	80a4c1c <__aeabi_atexit>
 80a4bca:	bf00      	nop
 80a4bcc:	20000944 	.word	0x20000944
 80a4bd0:	2000039c 	.word	0x2000039c
 80a4bd4:	080a29f9 	.word	0x080a29f9

080a4bd8 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4bd8:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a4bda:	4c0c      	ldr	r4, [pc, #48]	; (80a4c0c <_GLOBAL__sub_I_SPI+0x34>)
 80a4bdc:	4e0c      	ldr	r6, [pc, #48]	; (80a4c10 <_GLOBAL__sub_I_SPI+0x38>)
 80a4bde:	4d0d      	ldr	r5, [pc, #52]	; (80a4c14 <_GLOBAL__sub_I_SPI+0x3c>)
 80a4be0:	2100      	movs	r1, #0
 80a4be2:	4620      	mov	r0, r4
 80a4be4:	f7ff f9e8 	bl	80a3fb8 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a4be8:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4bea:	4c0b      	ldr	r4, [pc, #44]	; (80a4c18 <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a4bec:	4632      	mov	r2, r6
 80a4bee:	4629      	mov	r1, r5
 80a4bf0:	f000 f814 	bl	80a4c1c <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4bf4:	2101      	movs	r1, #1
 80a4bf6:	4620      	mov	r0, r4
 80a4bf8:	f7ff f9de 	bl	80a3fb8 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a4bfc:	4632      	mov	r2, r6
 80a4bfe:	4629      	mov	r1, r5
 80a4c00:	4620      	mov	r0, r4
 80a4c02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a4c06:	f000 b809 	b.w	80a4c1c <__aeabi_atexit>
 80a4c0a:	bf00      	nop
 80a4c0c:	2000095c 	.word	0x2000095c
 80a4c10:	2000039c 	.word	0x2000039c
 80a4c14:	080a3fa9 	.word	0x080a3fa9
 80a4c18:	2000096c 	.word	0x2000096c

080a4c1c <__aeabi_atexit>:
 80a4c1c:	460b      	mov	r3, r1
 80a4c1e:	4601      	mov	r1, r0
 80a4c20:	4618      	mov	r0, r3
 80a4c22:	f000 b969 	b.w	80a4ef8 <__cxa_atexit>
	...

080a4c28 <_ZSt15get_new_handlerv>:
 80a4c28:	4b02      	ldr	r3, [pc, #8]	; (80a4c34 <_ZSt15get_new_handlerv+0xc>)
 80a4c2a:	6818      	ldr	r0, [r3, #0]
 80a4c2c:	f3bf 8f5f 	dmb	sy
 80a4c30:	4770      	bx	lr
 80a4c32:	bf00      	nop
 80a4c34:	2000097c 	.word	0x2000097c

080a4c38 <_ZnwjRKSt9nothrow_t>:
 80a4c38:	b510      	push	{r4, lr}
 80a4c3a:	2800      	cmp	r0, #0
 80a4c3c:	bf14      	ite	ne
 80a4c3e:	4604      	movne	r4, r0
 80a4c40:	2401      	moveq	r4, #1
 80a4c42:	4620      	mov	r0, r4
 80a4c44:	f7fd fe46 	bl	80a28d4 <malloc>
 80a4c48:	b920      	cbnz	r0, 80a4c54 <_ZnwjRKSt9nothrow_t+0x1c>
 80a4c4a:	f7ff ffed 	bl	80a4c28 <_ZSt15get_new_handlerv>
 80a4c4e:	b108      	cbz	r0, 80a4c54 <_ZnwjRKSt9nothrow_t+0x1c>
 80a4c50:	4780      	blx	r0
 80a4c52:	e7f6      	b.n	80a4c42 <_ZnwjRKSt9nothrow_t+0xa>
 80a4c54:	bd10      	pop	{r4, pc}
	...

080a4c58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a4c58:	4b24      	ldr	r3, [pc, #144]	; (80a4cec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a4c5a:	681a      	ldr	r2, [r3, #0]
 80a4c5c:	07d0      	lsls	r0, r2, #31
 80a4c5e:	bf5c      	itt	pl
 80a4c60:	2201      	movpl	r2, #1
 80a4c62:	601a      	strpl	r2, [r3, #0]
 80a4c64:	4b22      	ldr	r3, [pc, #136]	; (80a4cf0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a4c66:	681a      	ldr	r2, [r3, #0]
 80a4c68:	07d1      	lsls	r1, r2, #31
 80a4c6a:	bf5c      	itt	pl
 80a4c6c:	2201      	movpl	r2, #1
 80a4c6e:	601a      	strpl	r2, [r3, #0]
 80a4c70:	4b20      	ldr	r3, [pc, #128]	; (80a4cf4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a4c72:	681a      	ldr	r2, [r3, #0]
 80a4c74:	07d2      	lsls	r2, r2, #31
 80a4c76:	bf5c      	itt	pl
 80a4c78:	2201      	movpl	r2, #1
 80a4c7a:	601a      	strpl	r2, [r3, #0]
 80a4c7c:	4b1e      	ldr	r3, [pc, #120]	; (80a4cf8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a4c7e:	681a      	ldr	r2, [r3, #0]
 80a4c80:	07d0      	lsls	r0, r2, #31
 80a4c82:	bf5c      	itt	pl
 80a4c84:	2201      	movpl	r2, #1
 80a4c86:	601a      	strpl	r2, [r3, #0]
 80a4c88:	4b1c      	ldr	r3, [pc, #112]	; (80a4cfc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a4c8a:	681a      	ldr	r2, [r3, #0]
 80a4c8c:	07d1      	lsls	r1, r2, #31
 80a4c8e:	bf5c      	itt	pl
 80a4c90:	2201      	movpl	r2, #1
 80a4c92:	601a      	strpl	r2, [r3, #0]
 80a4c94:	4b1a      	ldr	r3, [pc, #104]	; (80a4d00 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a4c96:	681a      	ldr	r2, [r3, #0]
 80a4c98:	07d2      	lsls	r2, r2, #31
 80a4c9a:	bf5c      	itt	pl
 80a4c9c:	2201      	movpl	r2, #1
 80a4c9e:	601a      	strpl	r2, [r3, #0]
 80a4ca0:	4b18      	ldr	r3, [pc, #96]	; (80a4d04 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a4ca2:	681a      	ldr	r2, [r3, #0]
 80a4ca4:	07d0      	lsls	r0, r2, #31
 80a4ca6:	bf5c      	itt	pl
 80a4ca8:	2201      	movpl	r2, #1
 80a4caa:	601a      	strpl	r2, [r3, #0]
 80a4cac:	4b16      	ldr	r3, [pc, #88]	; (80a4d08 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a4cae:	681a      	ldr	r2, [r3, #0]
 80a4cb0:	07d1      	lsls	r1, r2, #31
 80a4cb2:	bf5c      	itt	pl
 80a4cb4:	2201      	movpl	r2, #1
 80a4cb6:	601a      	strpl	r2, [r3, #0]
 80a4cb8:	4b14      	ldr	r3, [pc, #80]	; (80a4d0c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a4cba:	681a      	ldr	r2, [r3, #0]
 80a4cbc:	07d2      	lsls	r2, r2, #31
 80a4cbe:	bf5c      	itt	pl
 80a4cc0:	2201      	movpl	r2, #1
 80a4cc2:	601a      	strpl	r2, [r3, #0]
 80a4cc4:	4b12      	ldr	r3, [pc, #72]	; (80a4d10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a4cc6:	681a      	ldr	r2, [r3, #0]
 80a4cc8:	07d0      	lsls	r0, r2, #31
 80a4cca:	bf5c      	itt	pl
 80a4ccc:	2201      	movpl	r2, #1
 80a4cce:	601a      	strpl	r2, [r3, #0]
 80a4cd0:	4b10      	ldr	r3, [pc, #64]	; (80a4d14 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a4cd2:	681a      	ldr	r2, [r3, #0]
 80a4cd4:	07d1      	lsls	r1, r2, #31
 80a4cd6:	bf5c      	itt	pl
 80a4cd8:	2201      	movpl	r2, #1
 80a4cda:	601a      	strpl	r2, [r3, #0]
 80a4cdc:	4b0e      	ldr	r3, [pc, #56]	; (80a4d18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a4cde:	681a      	ldr	r2, [r3, #0]
 80a4ce0:	07d2      	lsls	r2, r2, #31
 80a4ce2:	bf5c      	itt	pl
 80a4ce4:	2201      	movpl	r2, #1
 80a4ce6:	601a      	strpl	r2, [r3, #0]
 80a4ce8:	4770      	bx	lr
 80a4cea:	bf00      	nop
 80a4cec:	200009ac 	.word	0x200009ac
 80a4cf0:	200009a8 	.word	0x200009a8
 80a4cf4:	200009a4 	.word	0x200009a4
 80a4cf8:	200009a0 	.word	0x200009a0
 80a4cfc:	2000099c 	.word	0x2000099c
 80a4d00:	20000998 	.word	0x20000998
 80a4d04:	20000994 	.word	0x20000994
 80a4d08:	20000990 	.word	0x20000990
 80a4d0c:	2000098c 	.word	0x2000098c
 80a4d10:	20000988 	.word	0x20000988
 80a4d14:	20000984 	.word	0x20000984
 80a4d18:	20000980 	.word	0x20000980

080a4d1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a4d1c:	4b18      	ldr	r3, [pc, #96]	; (80a4d80 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a4d1e:	681a      	ldr	r2, [r3, #0]
 80a4d20:	07d1      	lsls	r1, r2, #31
 80a4d22:	bf5c      	itt	pl
 80a4d24:	2201      	movpl	r2, #1
 80a4d26:	601a      	strpl	r2, [r3, #0]
 80a4d28:	4b16      	ldr	r3, [pc, #88]	; (80a4d84 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a4d2a:	681a      	ldr	r2, [r3, #0]
 80a4d2c:	07d2      	lsls	r2, r2, #31
 80a4d2e:	bf5c      	itt	pl
 80a4d30:	2201      	movpl	r2, #1
 80a4d32:	601a      	strpl	r2, [r3, #0]
 80a4d34:	4b14      	ldr	r3, [pc, #80]	; (80a4d88 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a4d36:	681a      	ldr	r2, [r3, #0]
 80a4d38:	07d0      	lsls	r0, r2, #31
 80a4d3a:	bf5c      	itt	pl
 80a4d3c:	2201      	movpl	r2, #1
 80a4d3e:	601a      	strpl	r2, [r3, #0]
 80a4d40:	4b12      	ldr	r3, [pc, #72]	; (80a4d8c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4d42:	681a      	ldr	r2, [r3, #0]
 80a4d44:	07d1      	lsls	r1, r2, #31
 80a4d46:	bf5c      	itt	pl
 80a4d48:	2201      	movpl	r2, #1
 80a4d4a:	601a      	strpl	r2, [r3, #0]
 80a4d4c:	4b10      	ldr	r3, [pc, #64]	; (80a4d90 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a4d4e:	681a      	ldr	r2, [r3, #0]
 80a4d50:	07d2      	lsls	r2, r2, #31
 80a4d52:	bf5c      	itt	pl
 80a4d54:	2201      	movpl	r2, #1
 80a4d56:	601a      	strpl	r2, [r3, #0]
 80a4d58:	4b0e      	ldr	r3, [pc, #56]	; (80a4d94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a4d5a:	681a      	ldr	r2, [r3, #0]
 80a4d5c:	07d0      	lsls	r0, r2, #31
 80a4d5e:	bf5c      	itt	pl
 80a4d60:	2201      	movpl	r2, #1
 80a4d62:	601a      	strpl	r2, [r3, #0]
 80a4d64:	4b0c      	ldr	r3, [pc, #48]	; (80a4d98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a4d66:	681a      	ldr	r2, [r3, #0]
 80a4d68:	07d1      	lsls	r1, r2, #31
 80a4d6a:	bf5c      	itt	pl
 80a4d6c:	2201      	movpl	r2, #1
 80a4d6e:	601a      	strpl	r2, [r3, #0]
 80a4d70:	4b0a      	ldr	r3, [pc, #40]	; (80a4d9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4d72:	681a      	ldr	r2, [r3, #0]
 80a4d74:	07d2      	lsls	r2, r2, #31
 80a4d76:	bf5c      	itt	pl
 80a4d78:	2201      	movpl	r2, #1
 80a4d7a:	601a      	strpl	r2, [r3, #0]
 80a4d7c:	4770      	bx	lr
 80a4d7e:	bf00      	nop
 80a4d80:	200009cc 	.word	0x200009cc
 80a4d84:	200009c8 	.word	0x200009c8
 80a4d88:	200009c4 	.word	0x200009c4
 80a4d8c:	200009c0 	.word	0x200009c0
 80a4d90:	200009bc 	.word	0x200009bc
 80a4d94:	200009b8 	.word	0x200009b8
 80a4d98:	200009b4 	.word	0x200009b4
 80a4d9c:	200009b0 	.word	0x200009b0

080a4da0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a4da0:	4b18      	ldr	r3, [pc, #96]	; (80a4e04 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a4da2:	681a      	ldr	r2, [r3, #0]
 80a4da4:	07d1      	lsls	r1, r2, #31
 80a4da6:	bf5c      	itt	pl
 80a4da8:	2201      	movpl	r2, #1
 80a4daa:	601a      	strpl	r2, [r3, #0]
 80a4dac:	4b16      	ldr	r3, [pc, #88]	; (80a4e08 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a4dae:	681a      	ldr	r2, [r3, #0]
 80a4db0:	07d2      	lsls	r2, r2, #31
 80a4db2:	bf5c      	itt	pl
 80a4db4:	2201      	movpl	r2, #1
 80a4db6:	601a      	strpl	r2, [r3, #0]
 80a4db8:	4b14      	ldr	r3, [pc, #80]	; (80a4e0c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a4dba:	681a      	ldr	r2, [r3, #0]
 80a4dbc:	07d0      	lsls	r0, r2, #31
 80a4dbe:	bf5c      	itt	pl
 80a4dc0:	2201      	movpl	r2, #1
 80a4dc2:	601a      	strpl	r2, [r3, #0]
 80a4dc4:	4b12      	ldr	r3, [pc, #72]	; (80a4e10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4dc6:	681a      	ldr	r2, [r3, #0]
 80a4dc8:	07d1      	lsls	r1, r2, #31
 80a4dca:	bf5c      	itt	pl
 80a4dcc:	2201      	movpl	r2, #1
 80a4dce:	601a      	strpl	r2, [r3, #0]
 80a4dd0:	4b10      	ldr	r3, [pc, #64]	; (80a4e14 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a4dd2:	681a      	ldr	r2, [r3, #0]
 80a4dd4:	07d2      	lsls	r2, r2, #31
 80a4dd6:	bf5c      	itt	pl
 80a4dd8:	2201      	movpl	r2, #1
 80a4dda:	601a      	strpl	r2, [r3, #0]
 80a4ddc:	4b0e      	ldr	r3, [pc, #56]	; (80a4e18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a4dde:	681a      	ldr	r2, [r3, #0]
 80a4de0:	07d0      	lsls	r0, r2, #31
 80a4de2:	bf5c      	itt	pl
 80a4de4:	2201      	movpl	r2, #1
 80a4de6:	601a      	strpl	r2, [r3, #0]
 80a4de8:	4b0c      	ldr	r3, [pc, #48]	; (80a4e1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a4dea:	681a      	ldr	r2, [r3, #0]
 80a4dec:	07d1      	lsls	r1, r2, #31
 80a4dee:	bf5c      	itt	pl
 80a4df0:	2201      	movpl	r2, #1
 80a4df2:	601a      	strpl	r2, [r3, #0]
 80a4df4:	4b0a      	ldr	r3, [pc, #40]	; (80a4e20 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4df6:	681a      	ldr	r2, [r3, #0]
 80a4df8:	07d2      	lsls	r2, r2, #31
 80a4dfa:	bf5c      	itt	pl
 80a4dfc:	2201      	movpl	r2, #1
 80a4dfe:	601a      	strpl	r2, [r3, #0]
 80a4e00:	4770      	bx	lr
 80a4e02:	bf00      	nop
 80a4e04:	200009ec 	.word	0x200009ec
 80a4e08:	200009e8 	.word	0x200009e8
 80a4e0c:	200009e4 	.word	0x200009e4
 80a4e10:	200009e0 	.word	0x200009e0
 80a4e14:	200009dc 	.word	0x200009dc
 80a4e18:	200009d8 	.word	0x200009d8
 80a4e1c:	200009d4 	.word	0x200009d4
 80a4e20:	200009d0 	.word	0x200009d0

080a4e24 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a4e24:	4b24      	ldr	r3, [pc, #144]	; (80a4eb8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a4e26:	681a      	ldr	r2, [r3, #0]
 80a4e28:	07d0      	lsls	r0, r2, #31
 80a4e2a:	bf5c      	itt	pl
 80a4e2c:	2201      	movpl	r2, #1
 80a4e2e:	601a      	strpl	r2, [r3, #0]
 80a4e30:	4b22      	ldr	r3, [pc, #136]	; (80a4ebc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a4e32:	681a      	ldr	r2, [r3, #0]
 80a4e34:	07d1      	lsls	r1, r2, #31
 80a4e36:	bf5c      	itt	pl
 80a4e38:	2201      	movpl	r2, #1
 80a4e3a:	601a      	strpl	r2, [r3, #0]
 80a4e3c:	4b20      	ldr	r3, [pc, #128]	; (80a4ec0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a4e3e:	681a      	ldr	r2, [r3, #0]
 80a4e40:	07d2      	lsls	r2, r2, #31
 80a4e42:	bf5c      	itt	pl
 80a4e44:	2201      	movpl	r2, #1
 80a4e46:	601a      	strpl	r2, [r3, #0]
 80a4e48:	4b1e      	ldr	r3, [pc, #120]	; (80a4ec4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a4e4a:	681a      	ldr	r2, [r3, #0]
 80a4e4c:	07d0      	lsls	r0, r2, #31
 80a4e4e:	bf5c      	itt	pl
 80a4e50:	2201      	movpl	r2, #1
 80a4e52:	601a      	strpl	r2, [r3, #0]
 80a4e54:	4b1c      	ldr	r3, [pc, #112]	; (80a4ec8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a4e56:	681a      	ldr	r2, [r3, #0]
 80a4e58:	07d1      	lsls	r1, r2, #31
 80a4e5a:	bf5c      	itt	pl
 80a4e5c:	2201      	movpl	r2, #1
 80a4e5e:	601a      	strpl	r2, [r3, #0]
 80a4e60:	4b1a      	ldr	r3, [pc, #104]	; (80a4ecc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a4e62:	681a      	ldr	r2, [r3, #0]
 80a4e64:	07d2      	lsls	r2, r2, #31
 80a4e66:	bf5c      	itt	pl
 80a4e68:	2201      	movpl	r2, #1
 80a4e6a:	601a      	strpl	r2, [r3, #0]
 80a4e6c:	4b18      	ldr	r3, [pc, #96]	; (80a4ed0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a4e6e:	681a      	ldr	r2, [r3, #0]
 80a4e70:	07d0      	lsls	r0, r2, #31
 80a4e72:	bf5c      	itt	pl
 80a4e74:	2201      	movpl	r2, #1
 80a4e76:	601a      	strpl	r2, [r3, #0]
 80a4e78:	4b16      	ldr	r3, [pc, #88]	; (80a4ed4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a4e7a:	681a      	ldr	r2, [r3, #0]
 80a4e7c:	07d1      	lsls	r1, r2, #31
 80a4e7e:	bf5c      	itt	pl
 80a4e80:	2201      	movpl	r2, #1
 80a4e82:	601a      	strpl	r2, [r3, #0]
 80a4e84:	4b14      	ldr	r3, [pc, #80]	; (80a4ed8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a4e86:	681a      	ldr	r2, [r3, #0]
 80a4e88:	07d2      	lsls	r2, r2, #31
 80a4e8a:	bf5c      	itt	pl
 80a4e8c:	2201      	movpl	r2, #1
 80a4e8e:	601a      	strpl	r2, [r3, #0]
 80a4e90:	4b12      	ldr	r3, [pc, #72]	; (80a4edc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a4e92:	681a      	ldr	r2, [r3, #0]
 80a4e94:	07d0      	lsls	r0, r2, #31
 80a4e96:	bf5c      	itt	pl
 80a4e98:	2201      	movpl	r2, #1
 80a4e9a:	601a      	strpl	r2, [r3, #0]
 80a4e9c:	4b10      	ldr	r3, [pc, #64]	; (80a4ee0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a4e9e:	681a      	ldr	r2, [r3, #0]
 80a4ea0:	07d1      	lsls	r1, r2, #31
 80a4ea2:	bf5c      	itt	pl
 80a4ea4:	2201      	movpl	r2, #1
 80a4ea6:	601a      	strpl	r2, [r3, #0]
 80a4ea8:	4b0e      	ldr	r3, [pc, #56]	; (80a4ee4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a4eaa:	681a      	ldr	r2, [r3, #0]
 80a4eac:	07d2      	lsls	r2, r2, #31
 80a4eae:	bf5c      	itt	pl
 80a4eb0:	2201      	movpl	r2, #1
 80a4eb2:	601a      	strpl	r2, [r3, #0]
 80a4eb4:	4770      	bx	lr
 80a4eb6:	bf00      	nop
 80a4eb8:	20000a1c 	.word	0x20000a1c
 80a4ebc:	20000a18 	.word	0x20000a18
 80a4ec0:	20000a14 	.word	0x20000a14
 80a4ec4:	20000a10 	.word	0x20000a10
 80a4ec8:	20000a0c 	.word	0x20000a0c
 80a4ecc:	20000a08 	.word	0x20000a08
 80a4ed0:	20000a04 	.word	0x20000a04
 80a4ed4:	20000a00 	.word	0x20000a00
 80a4ed8:	200009fc 	.word	0x200009fc
 80a4edc:	200009f8 	.word	0x200009f8
 80a4ee0:	200009f4 	.word	0x200009f4
 80a4ee4:	200009f0 	.word	0x200009f0

080a4ee8 <atoi>:
 80a4ee8:	220a      	movs	r2, #10
 80a4eea:	2100      	movs	r1, #0
 80a4eec:	f000 b954 	b.w	80a5198 <strtol>

080a4ef0 <atol>:
 80a4ef0:	220a      	movs	r2, #10
 80a4ef2:	2100      	movs	r1, #0
 80a4ef4:	f000 b950 	b.w	80a5198 <strtol>

080a4ef8 <__cxa_atexit>:
 80a4ef8:	b510      	push	{r4, lr}
 80a4efa:	4c05      	ldr	r4, [pc, #20]	; (80a4f10 <__cxa_atexit+0x18>)
 80a4efc:	4613      	mov	r3, r2
 80a4efe:	b12c      	cbz	r4, 80a4f0c <__cxa_atexit+0x14>
 80a4f00:	460a      	mov	r2, r1
 80a4f02:	4601      	mov	r1, r0
 80a4f04:	2002      	movs	r0, #2
 80a4f06:	f3af 8000 	nop.w
 80a4f0a:	bd10      	pop	{r4, pc}
 80a4f0c:	4620      	mov	r0, r4
 80a4f0e:	bd10      	pop	{r4, pc}
 80a4f10:	00000000 	.word	0x00000000

080a4f14 <memcpy>:
 80a4f14:	b510      	push	{r4, lr}
 80a4f16:	1e43      	subs	r3, r0, #1
 80a4f18:	440a      	add	r2, r1
 80a4f1a:	4291      	cmp	r1, r2
 80a4f1c:	d004      	beq.n	80a4f28 <memcpy+0x14>
 80a4f1e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a4f22:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a4f26:	e7f8      	b.n	80a4f1a <memcpy+0x6>
 80a4f28:	bd10      	pop	{r4, pc}

080a4f2a <memmove>:
 80a4f2a:	4288      	cmp	r0, r1
 80a4f2c:	b510      	push	{r4, lr}
 80a4f2e:	eb01 0302 	add.w	r3, r1, r2
 80a4f32:	d801      	bhi.n	80a4f38 <memmove+0xe>
 80a4f34:	1e42      	subs	r2, r0, #1
 80a4f36:	e00b      	b.n	80a4f50 <memmove+0x26>
 80a4f38:	4298      	cmp	r0, r3
 80a4f3a:	d2fb      	bcs.n	80a4f34 <memmove+0xa>
 80a4f3c:	1881      	adds	r1, r0, r2
 80a4f3e:	1ad2      	subs	r2, r2, r3
 80a4f40:	42d3      	cmn	r3, r2
 80a4f42:	d004      	beq.n	80a4f4e <memmove+0x24>
 80a4f44:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80a4f48:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80a4f4c:	e7f8      	b.n	80a4f40 <memmove+0x16>
 80a4f4e:	bd10      	pop	{r4, pc}
 80a4f50:	4299      	cmp	r1, r3
 80a4f52:	d004      	beq.n	80a4f5e <memmove+0x34>
 80a4f54:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a4f58:	f802 4f01 	strb.w	r4, [r2, #1]!
 80a4f5c:	e7f8      	b.n	80a4f50 <memmove+0x26>
 80a4f5e:	bd10      	pop	{r4, pc}

080a4f60 <memset>:
 80a4f60:	4603      	mov	r3, r0
 80a4f62:	4402      	add	r2, r0
 80a4f64:	4293      	cmp	r3, r2
 80a4f66:	d002      	beq.n	80a4f6e <memset+0xe>
 80a4f68:	f803 1b01 	strb.w	r1, [r3], #1
 80a4f6c:	e7fa      	b.n	80a4f64 <memset+0x4>
 80a4f6e:	4770      	bx	lr

080a4f70 <srand>:
 80a4f70:	b538      	push	{r3, r4, r5, lr}
 80a4f72:	4b12      	ldr	r3, [pc, #72]	; (80a4fbc <srand+0x4c>)
 80a4f74:	4605      	mov	r5, r0
 80a4f76:	681c      	ldr	r4, [r3, #0]
 80a4f78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a4f7a:	b9d3      	cbnz	r3, 80a4fb2 <srand+0x42>
 80a4f7c:	2018      	movs	r0, #24
 80a4f7e:	f7fd fca9 	bl	80a28d4 <malloc>
 80a4f82:	f243 330e 	movw	r3, #13070	; 0x330e
 80a4f86:	63a0      	str	r0, [r4, #56]	; 0x38
 80a4f88:	8003      	strh	r3, [r0, #0]
 80a4f8a:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a4f8e:	8043      	strh	r3, [r0, #2]
 80a4f90:	f241 2334 	movw	r3, #4660	; 0x1234
 80a4f94:	8083      	strh	r3, [r0, #4]
 80a4f96:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a4f9a:	80c3      	strh	r3, [r0, #6]
 80a4f9c:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a4fa0:	8103      	strh	r3, [r0, #8]
 80a4fa2:	2305      	movs	r3, #5
 80a4fa4:	8143      	strh	r3, [r0, #10]
 80a4fa6:	230b      	movs	r3, #11
 80a4fa8:	8183      	strh	r3, [r0, #12]
 80a4faa:	2201      	movs	r2, #1
 80a4fac:	2300      	movs	r3, #0
 80a4fae:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a4fb2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a4fb4:	2200      	movs	r2, #0
 80a4fb6:	611d      	str	r5, [r3, #16]
 80a4fb8:	615a      	str	r2, [r3, #20]
 80a4fba:	bd38      	pop	{r3, r4, r5, pc}
 80a4fbc:	20000398 	.word	0x20000398

080a4fc0 <strchr>:
 80a4fc0:	b2c9      	uxtb	r1, r1
 80a4fc2:	4603      	mov	r3, r0
 80a4fc4:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a4fc8:	b11a      	cbz	r2, 80a4fd2 <strchr+0x12>
 80a4fca:	4291      	cmp	r1, r2
 80a4fcc:	d1f9      	bne.n	80a4fc2 <strchr+0x2>
 80a4fce:	4618      	mov	r0, r3
 80a4fd0:	4770      	bx	lr
 80a4fd2:	2900      	cmp	r1, #0
 80a4fd4:	bf0c      	ite	eq
 80a4fd6:	4618      	moveq	r0, r3
 80a4fd8:	2000      	movne	r0, #0
 80a4fda:	4770      	bx	lr

080a4fdc <strchrnul>:
 80a4fdc:	b510      	push	{r4, lr}
 80a4fde:	4604      	mov	r4, r0
 80a4fe0:	f7ff ffee 	bl	80a4fc0 <strchr>
 80a4fe4:	b918      	cbnz	r0, 80a4fee <strchrnul+0x12>
 80a4fe6:	4620      	mov	r0, r4
 80a4fe8:	f000 f80c 	bl	80a5004 <strlen>
 80a4fec:	4420      	add	r0, r4
 80a4fee:	bd10      	pop	{r4, pc}

080a4ff0 <strcmp>:
 80a4ff0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a4ff4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a4ff8:	2a01      	cmp	r2, #1
 80a4ffa:	bf28      	it	cs
 80a4ffc:	429a      	cmpcs	r2, r3
 80a4ffe:	d0f7      	beq.n	80a4ff0 <strcmp>
 80a5000:	1ad0      	subs	r0, r2, r3
 80a5002:	4770      	bx	lr

080a5004 <strlen>:
 80a5004:	4603      	mov	r3, r0
 80a5006:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a500a:	2a00      	cmp	r2, #0
 80a500c:	d1fb      	bne.n	80a5006 <strlen+0x2>
 80a500e:	1a18      	subs	r0, r3, r0
 80a5010:	3801      	subs	r0, #1
 80a5012:	4770      	bx	lr

080a5014 <strncmp>:
 80a5014:	b530      	push	{r4, r5, lr}
 80a5016:	b182      	cbz	r2, 80a503a <strncmp+0x26>
 80a5018:	1e45      	subs	r5, r0, #1
 80a501a:	3901      	subs	r1, #1
 80a501c:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80a5020:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a5024:	42a3      	cmp	r3, r4
 80a5026:	d106      	bne.n	80a5036 <strncmp+0x22>
 80a5028:	43ec      	mvns	r4, r5
 80a502a:	4414      	add	r4, r2
 80a502c:	42e0      	cmn	r0, r4
 80a502e:	d001      	beq.n	80a5034 <strncmp+0x20>
 80a5030:	2b00      	cmp	r3, #0
 80a5032:	d1f3      	bne.n	80a501c <strncmp+0x8>
 80a5034:	461c      	mov	r4, r3
 80a5036:	1b18      	subs	r0, r3, r4
 80a5038:	bd30      	pop	{r4, r5, pc}
 80a503a:	4610      	mov	r0, r2
 80a503c:	bd30      	pop	{r4, r5, pc}

080a503e <strncpy>:
 80a503e:	4603      	mov	r3, r0
 80a5040:	b510      	push	{r4, lr}
 80a5042:	b142      	cbz	r2, 80a5056 <strncpy+0x18>
 80a5044:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a5048:	3a01      	subs	r2, #1
 80a504a:	f803 4b01 	strb.w	r4, [r3], #1
 80a504e:	2c00      	cmp	r4, #0
 80a5050:	d1f7      	bne.n	80a5042 <strncpy+0x4>
 80a5052:	441a      	add	r2, r3
 80a5054:	e000      	b.n	80a5058 <strncpy+0x1a>
 80a5056:	bd10      	pop	{r4, pc}
 80a5058:	4293      	cmp	r3, r2
 80a505a:	d002      	beq.n	80a5062 <strncpy+0x24>
 80a505c:	f803 4b01 	strb.w	r4, [r3], #1
 80a5060:	e7fa      	b.n	80a5058 <strncpy+0x1a>
 80a5062:	bd10      	pop	{r4, pc}

080a5064 <strrchr>:
 80a5064:	b538      	push	{r3, r4, r5, lr}
 80a5066:	4603      	mov	r3, r0
 80a5068:	460d      	mov	r5, r1
 80a506a:	b141      	cbz	r1, 80a507e <strrchr+0x1a>
 80a506c:	2400      	movs	r4, #0
 80a506e:	4629      	mov	r1, r5
 80a5070:	4618      	mov	r0, r3
 80a5072:	f7ff ffa5 	bl	80a4fc0 <strchr>
 80a5076:	b130      	cbz	r0, 80a5086 <strrchr+0x22>
 80a5078:	1c43      	adds	r3, r0, #1
 80a507a:	4604      	mov	r4, r0
 80a507c:	e7f7      	b.n	80a506e <strrchr+0xa>
 80a507e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a5082:	f7ff bf9d 	b.w	80a4fc0 <strchr>
 80a5086:	4620      	mov	r0, r4
 80a5088:	bd38      	pop	{r3, r4, r5, pc}
	...

080a508c <_strtol_r>:
 80a508c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a5090:	460f      	mov	r7, r1
 80a5092:	4680      	mov	r8, r0
 80a5094:	483f      	ldr	r0, [pc, #252]	; (80a5194 <_strtol_r+0x108>)
 80a5096:	f8d0 9000 	ldr.w	r9, [r0]
 80a509a:	463d      	mov	r5, r7
 80a509c:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a50a0:	eb09 0004 	add.w	r0, r9, r4
 80a50a4:	7840      	ldrb	r0, [r0, #1]
 80a50a6:	f000 0008 	and.w	r0, r0, #8
 80a50aa:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a50ae:	b108      	cbz	r0, 80a50b4 <_strtol_r+0x28>
 80a50b0:	462f      	mov	r7, r5
 80a50b2:	e7f2      	b.n	80a509a <_strtol_r+0xe>
 80a50b4:	2c2d      	cmp	r4, #45	; 0x2d
 80a50b6:	d103      	bne.n	80a50c0 <_strtol_r+0x34>
 80a50b8:	1cbd      	adds	r5, r7, #2
 80a50ba:	787c      	ldrb	r4, [r7, #1]
 80a50bc:	2601      	movs	r6, #1
 80a50be:	e003      	b.n	80a50c8 <_strtol_r+0x3c>
 80a50c0:	2c2b      	cmp	r4, #43	; 0x2b
 80a50c2:	bf04      	itt	eq
 80a50c4:	787c      	ldrbeq	r4, [r7, #1]
 80a50c6:	1cbd      	addeq	r5, r7, #2
 80a50c8:	b113      	cbz	r3, 80a50d0 <_strtol_r+0x44>
 80a50ca:	2b10      	cmp	r3, #16
 80a50cc:	d10a      	bne.n	80a50e4 <_strtol_r+0x58>
 80a50ce:	e05b      	b.n	80a5188 <_strtol_r+0xfc>
 80a50d0:	2c30      	cmp	r4, #48	; 0x30
 80a50d2:	d157      	bne.n	80a5184 <_strtol_r+0xf8>
 80a50d4:	7828      	ldrb	r0, [r5, #0]
 80a50d6:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a50da:	2858      	cmp	r0, #88	; 0x58
 80a50dc:	d14d      	bne.n	80a517a <_strtol_r+0xee>
 80a50de:	786c      	ldrb	r4, [r5, #1]
 80a50e0:	2310      	movs	r3, #16
 80a50e2:	3502      	adds	r5, #2
 80a50e4:	2e00      	cmp	r6, #0
 80a50e6:	bf14      	ite	ne
 80a50e8:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a50ec:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a50f0:	fbbc faf3 	udiv	sl, ip, r3
 80a50f4:	2700      	movs	r7, #0
 80a50f6:	4638      	mov	r0, r7
 80a50f8:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a50fc:	eb09 0e04 	add.w	lr, r9, r4
 80a5100:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a5104:	f01e 0f04 	tst.w	lr, #4
 80a5108:	d001      	beq.n	80a510e <_strtol_r+0x82>
 80a510a:	3c30      	subs	r4, #48	; 0x30
 80a510c:	e00b      	b.n	80a5126 <_strtol_r+0x9a>
 80a510e:	f01e 0e03 	ands.w	lr, lr, #3
 80a5112:	d01b      	beq.n	80a514c <_strtol_r+0xc0>
 80a5114:	f1be 0f01 	cmp.w	lr, #1
 80a5118:	bf0c      	ite	eq
 80a511a:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a511e:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a5122:	ebce 0404 	rsb	r4, lr, r4
 80a5126:	42a3      	cmp	r3, r4
 80a5128:	dd10      	ble.n	80a514c <_strtol_r+0xc0>
 80a512a:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 80a512e:	d00a      	beq.n	80a5146 <_strtol_r+0xba>
 80a5130:	4550      	cmp	r0, sl
 80a5132:	d806      	bhi.n	80a5142 <_strtol_r+0xb6>
 80a5134:	d101      	bne.n	80a513a <_strtol_r+0xae>
 80a5136:	4564      	cmp	r4, ip
 80a5138:	dc03      	bgt.n	80a5142 <_strtol_r+0xb6>
 80a513a:	fb03 4000 	mla	r0, r3, r0, r4
 80a513e:	2701      	movs	r7, #1
 80a5140:	e001      	b.n	80a5146 <_strtol_r+0xba>
 80a5142:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a5146:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a514a:	e7d7      	b.n	80a50fc <_strtol_r+0x70>
 80a514c:	1c7b      	adds	r3, r7, #1
 80a514e:	d10c      	bne.n	80a516a <_strtol_r+0xde>
 80a5150:	2e00      	cmp	r6, #0
 80a5152:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a5156:	bf14      	ite	ne
 80a5158:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a515c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a5160:	f8c8 3000 	str.w	r3, [r8]
 80a5164:	b92a      	cbnz	r2, 80a5172 <_strtol_r+0xe6>
 80a5166:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a516a:	b106      	cbz	r6, 80a516e <_strtol_r+0xe2>
 80a516c:	4240      	negs	r0, r0
 80a516e:	b172      	cbz	r2, 80a518e <_strtol_r+0x102>
 80a5170:	b107      	cbz	r7, 80a5174 <_strtol_r+0xe8>
 80a5172:	1e69      	subs	r1, r5, #1
 80a5174:	6011      	str	r1, [r2, #0]
 80a5176:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a517a:	2430      	movs	r4, #48	; 0x30
 80a517c:	2b00      	cmp	r3, #0
 80a517e:	d1b1      	bne.n	80a50e4 <_strtol_r+0x58>
 80a5180:	2308      	movs	r3, #8
 80a5182:	e7af      	b.n	80a50e4 <_strtol_r+0x58>
 80a5184:	230a      	movs	r3, #10
 80a5186:	e7ad      	b.n	80a50e4 <_strtol_r+0x58>
 80a5188:	2c30      	cmp	r4, #48	; 0x30
 80a518a:	d0a3      	beq.n	80a50d4 <_strtol_r+0x48>
 80a518c:	e7aa      	b.n	80a50e4 <_strtol_r+0x58>
 80a518e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5192:	bf00      	nop
 80a5194:	20000334 	.word	0x20000334

080a5198 <strtol>:
 80a5198:	4613      	mov	r3, r2
 80a519a:	460a      	mov	r2, r1
 80a519c:	4601      	mov	r1, r0
 80a519e:	4802      	ldr	r0, [pc, #8]	; (80a51a8 <strtol+0x10>)
 80a51a0:	6800      	ldr	r0, [r0, #0]
 80a51a2:	f7ff bf73 	b.w	80a508c <_strtol_r>
 80a51a6:	bf00      	nop
 80a51a8:	20000398 	.word	0x20000398

080a51ac <dynalib_user>:
 80a51ac:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a51bc:	00000000                                ....

080a51c0 <_ZTVN5spark10LogHandlerE>:
	...
 80a51d0:	080a00a5 080a00c9                       ........

080a51d8 <_ZTVN5spark16SerialLogHandlerE>:
	...
 80a51e0:	080a0109 080a013d 080a30d1 080a00cb     ....=....0......

080a51f0 <_ZZN8BlynkApiI13BlynkProtocolI22BlynkTransportParticleEE8sendInfoEvE7profile>:
 80a51f0:	6b6e6c62 00666e69 00726576 2e352e30     blnkinf.ver.0.5.
 80a5200:	2d680034 74616562 00303100 66667562     4.h-beat.10.buff
 80a5210:	006e692d 34323031 76656400 72615000     -in.1024.dev.Par
 80a5220:	6c636974 68502065 6e6f746f 69756200     ticle Photon.bui
 80a5230:	4d00646c 31207261 30322033 32203931     ld.Mar 13 2019 2
 80a5240:	37313a33 0036333a 205d0000 00692500     3:17:36...] .%i.
 80a5250:	00696c25 6e6e6f43 69746365 7420676e     %li.Connecting t
 80a5260:	4e00206f 6d207765 2065646f 25207369     o .New mode is %
 80a5270:	4e002e64 74207765 20656d69 25207369     d..New time is %
 80a5280:	4e002e73 72207765 76206465 65756c61     s..New red value
 80a5290:	20736920 002e6425 2077654e 65657267      is %d..New gree
 80a52a0:	6176206e 2065756c 25207369 4e002e64     n value is %d..N
 80a52b0:	62207765 2065756c 756c6176 73692065     ew blue value is
 80a52c0:	2e642520 77654e00 69726220 6e746867      %d..New brightn
 80a52d0:	20737365 756c6176 73692065 2e642520     ess value is %d.
 80a52e0:	006e6900 006d7770 61007764 6e490077     .in.pwm.dw.aw.In
 80a52f0:	696c6176 57482064 646d6320 5200203a     valid HW cmd: .R
 80a5300:	79646165 69702820 203a676e 29736d00     eady (ping: .ms)
 80a5310:	6e49002e 696c6176 75612064 74206874     ..Invalid auth t
 80a5320:	6e656b6f 6e6f4300 7463656e 69616620     oken.Connect fai
 80a5330:	2e64656c 646f6320 00203a65 6b636150     led. code: .Pack
 80a5340:	74207465 62206f6f 203a6769 61655200     et too big: .Rea
 80a5350:	52007964 72696465 69746365 7420676e     dy.Redirecting t
 80a5360:	5300206f 65767265 00203a72 72616548     o .Server: .Hear
 80a5370:	61656274 69742074 756f656d 6f4c0074     tbeat timeout.Lo
 80a5380:	206e6967 656d6974 0074756f 72617453     gin timeout.Star
 80a5390:	676e6974 74657320 002e7075 36545441     ting setup..ATT6
 80a53a0:	35355747 34005973 33706763 69753477     GW55sY.4cgp3w4ui
 80a53b0:	0032346b 69466957 61657220 002e7964     k42.WiFi ready..
 80a53c0:	69466957 74657320 66207075 656c6961     WiFi setup faile
 80a53d0:	50002e64 69747261 20656c63 6e6e6f63     d..Particle conn
 80a53e0:	65746365 6f742064 4f4c4320 002e4455     ected to CLOUD..
 80a53f0:	74726150 656c6369 746f6e20 6e6f6320     Particle not con
 80a5400:	7463656e 74206465 4c43206f 2e44554f     nected to CLOUD.
 80a5410:	200a0d00 5f202020 20205f5f 20205f5f     ...    ___  __  
 80a5420:	20202020 20202020 0a0d5f5f 2f202020             __..   /
 80a5430:	29205f20 5f2f202f 5f5f5f20 20205f5f      _ )/ /_ _____  
 80a5440:	5f2f202f 200a0d5f 5f202f20 202f2020     / /__..  / _  / 
 80a5450:	2f2f202f 5f202f20 202f5c20 2f5f2720     / // / _ \/  '_/
 80a5460:	2f200a0d 5f5f5f5f 5c2f5f2f 2f202c5f     .. /____/_/\_, /
 80a5470:	5f2f2f5f 5c2f5f2f 0a0d5c5f 20202020     _//_/_/\_\..    
 80a5480:	20202020 5f5f5f2f 3076202f 342e352e         /___/ v0.5.4
 80a5490:	206e6f20 74726150 656c6369 6f685020      on Particle Pho
 80a54a0:	0d6e6f74 6c62000a 2d6b6e79 756f6c63     ton...blynk-clou
 80a54b0:	6f632e64 0000006d                       d.com...

080a54b8 <_ZL23BlynkWriteHandlerVector>:
 80a54b8:	080a03a9 080a03d9 080a0419 080a0449     ............I...
 80a54c8:	080a0479 080a04a9 080a1187 080a1187     y...............
 80a54d8:	080a1187 080a1187 080a1187 080a1187     ................
 80a54e8:	080a1187 080a1187 080a1187 080a1187     ................
 80a54f8:	080a1187 080a1187 080a1187 080a1187     ................
 80a5508:	080a1187 080a1187 080a1187 080a1187     ................
 80a5518:	080a1187 080a1187 080a1187 080a1187     ................
 80a5528:	080a1187 080a1187 080a1187 080a1187     ................
 80a5538:	080a1187 080a1187 080a1187 080a1187     ................
 80a5548:	080a1187 080a1187 080a1187 080a1187     ................
 80a5558:	080a1187 080a1187 080a1187 080a1187     ................
 80a5568:	080a1187 080a1187 080a1187 080a1187     ................
 80a5578:	080a1187 080a1187 080a1187 080a1187     ................
 80a5588:	080a1187 080a1187 080a1187 080a1187     ................
 80a5598:	080a1187 080a1187 080a1187 080a1187     ................
 80a55a8:	080a1187 080a1187 080a1187 080a1187     ................
 80a55b8:	080a1187 080a1187 080a1187 080a1187     ................
 80a55c8:	080a1187 080a1187 080a1187 080a1187     ................
 80a55d8:	080a1187 080a1187 080a1187 080a1187     ................
 80a55e8:	080a1187 080a1187 080a1187 080a1187     ................
 80a55f8:	080a1187 080a1187 080a1187 080a1187     ................
 80a5608:	080a1187 080a1187 080a1187 080a1187     ................
 80a5618:	080a1187 080a1187 080a1187 080a1187     ................
 80a5628:	080a1187 080a1187 080a1187 080a1187     ................
 80a5638:	080a1187 080a1187 080a1187 080a1187     ................
 80a5648:	080a1187 080a1187 080a1187 080a1187     ................
 80a5658:	080a1187 080a1187 080a1187 080a1187     ................
 80a5668:	080a1187 080a1187 080a1187 080a1187     ................
 80a5678:	080a1187 080a1187 080a1187 080a1187     ................
 80a5688:	080a1187 080a1187 080a1187 080a1187     ................
 80a5698:	080a1187 080a1187 080a1187 080a1187     ................
 80a56a8:	080a1187 080a1187 080a1187 080a1187     ................

080a56b8 <_ZL22BlynkReadHandlerVector>:
 80a56b8:	080a1185 080a1185 080a1185 080a1185     ................
 80a56c8:	080a1185 080a1185 080a1185 080a1185     ................
 80a56d8:	080a1185 080a1185 080a1185 080a1185     ................
 80a56e8:	080a1185 080a1185 080a1185 080a1185     ................
 80a56f8:	080a1185 080a1185 080a1185 080a1185     ................
 80a5708:	080a1185 080a1185 080a1185 080a1185     ................
 80a5718:	080a1185 080a1185 080a1185 080a1185     ................
 80a5728:	080a1185 080a1185 080a1185 080a1185     ................
 80a5738:	080a1185 080a1185 080a1185 080a1185     ................
 80a5748:	080a1185 080a1185 080a1185 080a1185     ................
 80a5758:	080a1185 080a1185 080a1185 080a1185     ................
 80a5768:	080a1185 080a1185 080a1185 080a1185     ................
 80a5778:	080a1185 080a1185 080a1185 080a1185     ................
 80a5788:	080a1185 080a1185 080a1185 080a1185     ................
 80a5798:	080a1185 080a1185 080a1185 080a1185     ................
 80a57a8:	080a1185 080a1185 080a1185 080a1185     ................
 80a57b8:	080a1185 080a1185 080a1185 080a1185     ................
 80a57c8:	080a1185 080a1185 080a1185 080a1185     ................
 80a57d8:	080a1185 080a1185 080a1185 080a1185     ................
 80a57e8:	080a1185 080a1185 080a1185 080a1185     ................
 80a57f8:	080a1185 080a1185 080a1185 080a1185     ................
 80a5808:	080a1185 080a1185 080a1185 080a1185     ................
 80a5818:	080a1185 080a1185 080a1185 080a1185     ................
 80a5828:	080a1185 080a1185 080a1185 080a1185     ................
 80a5838:	080a1185 080a1185 080a1185 080a1185     ................
 80a5848:	080a1185 080a1185 080a1185 080a1185     ................
 80a5858:	080a1185 080a1185 080a1185 080a1185     ................
 80a5868:	080a1185 080a1185 080a1185 080a1185     ................
 80a5878:	080a1185 080a1185 080a1185 080a1185     ................
 80a5888:	080a1185 080a1185 080a1185 080a1185     ................
 80a5898:	080a1185 080a1185 080a1185 080a1185     ................
 80a58a8:	080a1185 080a1185 080a1185 080a1185     ................

080a58b8 <CSWTCH.215>:
 80a58b8:	0000012c 00000018 000001f4 0000012c     ,...........,...
 80a58c8:	00000050                                P...

080a58cc <_ZTV7TwoWire>:
	...
 80a58d4:	080a2977 080a29c1 080a2999 080a2979     w)...)...)..y)..
 80a58e4:	080a29a1 080a29a9 080a29b1 080a29b9     .)...)...)...)..

080a58f4 <_ZTV9IPAddress>:
	...
 80a58fc:	080a2a07 080a29f9 080a29fb 00302e30     .*...)...)..0.0.
 80a590c:	736c6166 72740065 25006575 75250064     false.true.%d.%u
 80a591c:	00672500 6c6c756e 30257500 00007834     .%g.null.u%04x..

080a592c <_ZTVN5spark16JSONStreamWriterE>:
	...
 80a5934:	080a2e85 080a2eab 080a2e5f 080a2ab7     ........_....*..

080a5944 <_ZTVN5spark20JSONStreamLogHandlerE>:
	...
 80a594c:	080a3625 080a3639 080a2f3d 080a2e67     %6..96..=/..g...

080a595c <_ZTVN5spark26DefaultOutputStreamFactoryE>:
	...
 80a5964:	080a2e81 080a2ec3 080a351d 080a2ecf     .........5......
 80a5974:	6e6c0066 006e6600 65646f63 74656400     f.ln.fn.code.det
 80a5984:	006c6961 30313025 2c002075 29280020     ail.%010u ., .()
 80a5994:	2000203a 6f63005b 3d206564 65640020     : . [.code = .de
 80a59a4:	6c696174 203d2073 75616200 65530064     tails = .baud.Se
 80a59b4:	6c616972 42535500 69726553 00316c61     rial.USBSerial1.
 80a59c4:	65707974 72617000 63006d61 6900646d     type.param.cmd.i
 80a59d4:	6e680064 74730064 66006d72 00746c69     d.hnd.strm.filt.
 80a59e4:	006c766c 48646461 6c646e61 72007265     lvl.addHandler.r
 80a59f4:	766f6d65 6e614865 72656c64 756e6500     emoveHandler.enu
 80a5a04:	6e61486d 72656c64 534a0073 74534e4f     mHandlers.JSONSt
 80a5a14:	6d616572 48676f4c 6c646e61 61007265     reamLogHandler.a
 80a5a24:	6e007070 00656e6f 63617274 6e690065     pp.none.trace.in
 80a5a34:	77006f66 006e7261 6f727265 61700072     fo.warn.error.pa
 80a5a44:	0063696e 006c6c61                       nic.all.

080a5a4c <_ZTVN5spark16StreamLogHandlerE>:
	...
 80a5a54:	080a35f9 080a3611 080a30d1 080a00cb     .5...6...0......

080a5a64 <_ZTVN5spark24DefaultLogHandlerFactoryE>:
	...
 80a5a6c:	080a2e83 080a2eb7 080a3ce9 080a2e69     .........<..i...

080a5a7c <_ZTV8SPIClass>:
	...
 80a5a84:	080a3fa9 080a3fab                       .?...?..

080a5a8c <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
 80a5a94:	080a41c9 080a41cf 080a42ef 080a41db     .A...A...B...A..
 80a5aa4:	080a41cb                                .A..

080a5aa8 <_ZTV9TCPClient>:
	...
 80a5ab0:	080a0169 080a01a9 080a4185 080a419f     i........A...A..
 80a5ac0:	080a436d 080a42bb 080a428d 080a41c7     mC...B...B...A..
 80a5ad0:	080a44a1 080a41e1 080a430b 080a43e9     .D...A...C...C..
 80a5ae0:	080a45f1 080a4643 080a41af 080a45b5     .E..CF...A...E..
 80a5af0:	080a426d 69726977 5400676e 6c435043     mB..wiring.TCPCl
 80a5b00:	746e6569 636f7320 3d74656b 5a007825     ient socket=%x.Z
 80a5b10:	302b2500 253a6433 00753230 252d5925     .%+03d:%02u.%Y-%
 80a5b20:	64252d6d 3a482554 253a4d25 007a2553     m-%dT%H:%M:%S%z.
 80a5b30:	74637361 00656d69                       asctime.

080a5b38 <_ZTV11USARTSerial>:
	...
 80a5b40:	080a4665 080a4689 080a4695 080a3dc1     eF...F...F...=..
 80a5b50:	080a4671 080a467d 080a4677 080a4683     qF..}F..wF...F..
 80a5b60:	080a4667 080a466b                       gF..kF..

080a5b68 <_ZTV9USBSerial>:
	...
 80a5b70:	080a4751 080a4795 080a476f 080a3dc1     QG...G..oG...=..
 80a5b80:	080a4769 080a4753 080a475b 080a478f     iG..SG..[G...G..
 80a5b90:	080a4763 080a474d                       cG..MG..

080a5b98 <_ZTVN5spark9WiFiClassE>:
	...
 80a5ba0:	080a48cb                                .H..

080a5ba4 <_ZN5spark7NetworkE>:
 80a5ba4:	2000091c                                ... 

080a5ba8 <_ZSt7nothrow>:
	...

080a5ba9 <_ctype_>:
 80a5ba9:	20202000 20202020 28282020 20282828     .         ((((( 
 80a5bb9:	20202020 20202020 20202020 20202020                     
 80a5bc9:	10108820 10101010 10101010 10101010      ...............
 80a5bd9:	04040410 04040404 10040404 10101010     ................
 80a5be9:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a5bf9:	01010101 01010101 01010101 10101010     ................
 80a5c09:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a5c19:	02020202 02020202 02020202 10101010     ................
 80a5c29:	00000020 00000000 00000000 00000000      ...............
	...

080a5cac <__sf_fake_stdin>:
	...

080a5ccc <__sf_fake_stdout>:
	...

080a5cec <__sf_fake_stderr>:
	...
 80a5d0c:	00000043                                         C.

080a5d0e <link_const_variable_data_end>:
	...

080a5d10 <link_constructors_location>:
 80a5d10:	080a1029 	.word	0x080a1029
 80a5d14:	080a1181 	.word	0x080a1181
 80a5d18:	080a11b5 	.word	0x080a11b5
 80a5d1c:	080a11b9 	.word	0x080a11b9
 80a5d20:	080a2455 	.word	0x080a2455
 80a5d24:	080a3db1 	.word	0x080a3db1
 80a5d28:	080a3f8d 	.word	0x080a3f8d
 80a5d2c:	080a4145 	.word	0x080a4145
 80a5d30:	080a4651 	.word	0x080a4651
 80a5d34:	080a48d5 	.word	0x080a48d5
 80a5d38:	080a4ba9 	.word	0x080a4ba9
 80a5d3c:	080a4bd9 	.word	0x080a4bd9
 80a5d40:	080a4c59 	.word	0x080a4c59
 80a5d44:	080a4d1d 	.word	0x080a4d1d
 80a5d48:	080a4da1 	.word	0x080a4da1
 80a5d4c:	080a4e25 	.word	0x080a4e25
